/******/ (function (modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/ var installedModules = {}; // The require function
  /******/
  /******/ /******/ function __webpack_require__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/ if (installedModules[moduleId]) {
      /******/ return installedModules[moduleId].exports;
      /******/
    } // Create a new module (and put it into the cache)
    /******/ /******/ var module = (installedModules[moduleId] = {
      /******/ i: moduleId,
      /******/ l: false,
      /******/ exports: {},
      /******/
    }); // Execute the module function
    /******/
    /******/ /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded
    /******/
    /******/ /******/ module.l = true; // Return the exports of the module
    /******/
    /******/ /******/ return module.exports;
    /******/
  } // expose the modules object (__webpack_modules__)
  /******/
  /******/
  /******/ /******/ __webpack_require__.m = modules; // expose the module cache
  /******/
  /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports
  /******/
  /******/ /******/ __webpack_require__.d = function (exports, name, getter) {
    /******/ if (!__webpack_require__.o(exports, name)) {
      /******/ Object.defineProperty(exports, name, { enumerable: true, get: getter });
      /******/
    }
    /******/
  }; // define __esModule on exports
  /******/
  /******/ /******/ __webpack_require__.r = function (exports) {
    /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      /******/
    }
    /******/ Object.defineProperty(exports, "__esModule", { value: true });
    /******/
  }; // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
  /******/
  /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function (value, mode) {
    /******/ if (mode & 1) value = __webpack_require__(value);
    /******/ if (mode & 8) return value;
    /******/ if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
    /******/ var ns = Object.create(null);
    /******/ __webpack_require__.r(ns);
    /******/ Object.defineProperty(ns, "default", { enumerable: true, value: value });
    /******/ if (mode & 2 && typeof value != "string")
      for (var key in value)
        __webpack_require__.d(
          ns,
          key,
          function (key) {
            return value[key];
          }.bind(null, key)
        );
    /******/ return ns;
    /******/
  }; // getDefaultExport function for compatibility with non-harmony modules
  /******/
  /******/ /******/ __webpack_require__.n = function (module) {
    /******/ var getter =
      module && module.__esModule
        ? /******/ function getDefault() {
            return module["default"];
          }
        : /******/ function getModuleExports() {
            return module;
          };
    /******/ __webpack_require__.d(getter, "a", getter);
    /******/ return getter;
    /******/
  }; // Object.prototype.hasOwnProperty.call
  /******/
  /******/ /******/ __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }; // __webpack_public_path__
  /******/
  /******/ /******/ __webpack_require__.p = ""; // Load entry module and return exports
  /******/
  /******/
  /******/ /******/ return __webpack_require__((__webpack_require__.s = 16));
  /******/
})(
  /************************************************************************/
  /******/ [
    /* 0 */
    /***/ function (module, exports, __webpack_require__) {
      (function (window, factory) {
        var lazySizes = factory(window, window.document, Date);
        window.lazySizes = lazySizes;
        if (true && module.exports) {
          module.exports = lazySizes;
        }
      })(typeof window != "undefined" ? window : {}, function l(window, document, Date) {
        // Pass in the windoe Date function also for SSR because the Date class can be lost
        "use strict";
        /*jshint eqnull:true */

        var lazysizes, lazySizesCfg;

        (function () {
          var prop;

          var lazySizesDefaults = {
            lazyClass: "lazyload",
            loadedClass: "lazyloaded",
            loadingClass: "lazyloading",
            preloadClass: "lazypreload",
            errorClass: "lazyerror",
            //strictClass: 'lazystrict',
            autosizesClass: "lazyautosizes",
            srcAttr: "data-src",
            srcsetAttr: "data-srcset",
            sizesAttr: "data-sizes",
            //preloadAfterLoad: false,
            minSize: 40,
            customMedia: {},
            init: true,
            expFactor: 1.5,
            hFac: 0.8,
            loadMode: 2,
            loadHidden: true,
            ricTimeout: 0,
            throttleDelay: 125,
          };

          lazySizesCfg = window.lazySizesConfig || window.lazysizesConfig || {};

          for (prop in lazySizesDefaults) {
            if (!(prop in lazySizesCfg)) {
              lazySizesCfg[prop] = lazySizesDefaults[prop];
            }
          }
        })();

        if (!document || !document.getElementsByClassName) {
          return {
            init: function () {},
            cfg: lazySizesCfg,
            noSupport: true,
          };
        }

        var docElem = document.documentElement;

        var supportPicture = window.HTMLPictureElement;

        var _addEventListener = "addEventListener";

        var _getAttribute = "getAttribute";

        /**
         * Update to bind to window because 'this' becomes null during SSR
         * builds.
         */
        var addEventListener = window[_addEventListener].bind(window);

        var setTimeout = window.setTimeout;

        var requestAnimationFrame = window.requestAnimationFrame || setTimeout;

        var requestIdleCallback = window.requestIdleCallback;

        var regPicture = /^picture$/i;

        var loadEvents = ["load", "error", "lazyincluded", "_lazyloaded"];

        var regClassCache = {};

        var forEach = Array.prototype.forEach;

        var hasClass = function (ele, cls) {
          if (!regClassCache[cls]) {
            regClassCache[cls] = new RegExp("(\\s|^)" + cls + "(\\s|$)");
          }
          return regClassCache[cls].test(ele[_getAttribute]("class") || "") && regClassCache[cls];
        };

        var addClass = function (ele, cls) {
          if (!hasClass(ele, cls)) {
            ele.setAttribute("class", (ele[_getAttribute]("class") || "").trim() + " " + cls);
          }
        };

        var removeClass = function (ele, cls) {
          var reg;
          if ((reg = hasClass(ele, cls))) {
            ele.setAttribute("class", (ele[_getAttribute]("class") || "").replace(reg, " "));
          }
        };

        var addRemoveLoadEvents = function (dom, fn, add) {
          var action = add ? _addEventListener : "removeEventListener";
          if (add) {
            addRemoveLoadEvents(dom, fn);
          }
          loadEvents.forEach(function (evt) {
            dom[action](evt, fn);
          });
        };

        var triggerEvent = function (elem, name, detail, noBubbles, noCancelable) {
          var event = document.createEvent("Event");

          if (!detail) {
            detail = {};
          }

          detail.instance = lazysizes;

          event.initEvent(name, !noBubbles, !noCancelable);

          event.detail = detail;

          elem.dispatchEvent(event);
          return event;
        };

        var updatePolyfill = function (el, full) {
          var polyfill;
          if (!supportPicture && (polyfill = window.picturefill || lazySizesCfg.pf)) {
            if (full && full.src && !el[_getAttribute]("srcset")) {
              el.setAttribute("srcset", full.src);
            }
            polyfill({ reevaluate: true, elements: [el] });
          } else if (full && full.src) {
            el.src = full.src;
          }
        };

        var getCSS = function (elem, style) {
          return (getComputedStyle(elem, null) || {})[style];
        };

        var getWidth = function (elem, parent, width) {
          width = width || elem.offsetWidth;

          while (width < lazySizesCfg.minSize && parent && !elem._lazysizesWidth) {
            width = parent.offsetWidth;
            parent = parent.parentNode;
          }

          return width;
        };

        var rAF = (function () {
          var running, waiting;
          var firstFns = [];
          var secondFns = [];
          var fns = firstFns;

          var run = function () {
            var runFns = fns;

            fns = firstFns.length ? secondFns : firstFns;

            running = true;
            waiting = false;

            while (runFns.length) {
              runFns.shift()();
            }

            running = false;
          };

          var rafBatch = function (fn, queue) {
            if (running && !queue) {
              fn.apply(this, arguments);
            } else {
              fns.push(fn);

              if (!waiting) {
                waiting = true;
                (document.hidden ? setTimeout : requestAnimationFrame)(run);
              }
            }
          };

          rafBatch._lsFlush = run;

          return rafBatch;
        })();

        var rAFIt = function (fn, simple) {
          return simple
            ? function () {
                rAF(fn);
              }
            : function () {
                var that = this;
                var args = arguments;
                rAF(function () {
                  fn.apply(that, args);
                });
              };
        };

        var throttle = function (fn) {
          var running;
          var lastTime = 0;
          var gDelay = lazySizesCfg.throttleDelay;
          var rICTimeout = lazySizesCfg.ricTimeout;
          var run = function () {
            running = false;
            lastTime = Date.now();
            fn();
          };
          var idleCallback =
            requestIdleCallback && rICTimeout > 49
              ? function () {
                  requestIdleCallback(run, { timeout: rICTimeout });

                  if (rICTimeout !== lazySizesCfg.ricTimeout) {
                    rICTimeout = lazySizesCfg.ricTimeout;
                  }
                }
              : rAFIt(function () {
                  setTimeout(run);
                }, true);
          return function (isPriority) {
            var delay;

            if ((isPriority = isPriority === true)) {
              rICTimeout = 33;
            }

            if (running) {
              return;
            }

            running = true;

            delay = gDelay - (Date.now() - lastTime);

            if (delay < 0) {
              delay = 0;
            }

            if (isPriority || delay < 9) {
              idleCallback();
            } else {
              setTimeout(idleCallback, delay);
            }
          };
        };

        //based on http://modernjavascript.blogspot.de/2013/08/building-better-debounce.html
        var debounce = function (func) {
          var timeout, timestamp;
          var wait = 99;
          var run = function () {
            timeout = null;
            func();
          };
          var later = function () {
            var last = Date.now() - timestamp;

            if (last < wait) {
              setTimeout(later, wait - last);
            } else {
              (requestIdleCallback || run)(run);
            }
          };

          return function () {
            timestamp = Date.now();

            if (!timeout) {
              timeout = setTimeout(later, wait);
            }
          };
        };

        var loader = (function () {
          var preloadElems, isCompleted, resetPreloadingTimer, loadMode, started;

          var eLvW, elvH, eLtop, eLleft, eLright, eLbottom, isBodyHidden;

          var regImg = /^img$/i;
          var regIframe = /^iframe$/i;

          var supportScroll = "onscroll" in window && !/(gle|ing)bot/.test(navigator.userAgent);

          var shrinkExpand = 0;
          var currentExpand = 0;

          var isLoading = 0;
          var lowRuns = -1;

          var resetPreloading = function (e) {
            isLoading--;
            if (!e || isLoading < 0 || !e.target) {
              isLoading = 0;
            }
          };

          var isVisible = function (elem) {
            if (isBodyHidden == null) {
              isBodyHidden = getCSS(document.body, "visibility") == "hidden";
            }

            return (
              isBodyHidden ||
              !(getCSS(elem.parentNode, "visibility") == "hidden" && getCSS(elem, "visibility") == "hidden")
            );
          };

          var isNestedVisible = function (elem, elemExpand) {
            var outerRect;
            var parent = elem;
            var visible = isVisible(elem);

            eLtop -= elemExpand;
            eLbottom += elemExpand;
            eLleft -= elemExpand;
            eLright += elemExpand;

            while (visible && (parent = parent.offsetParent) && parent != document.body && parent != docElem) {
              visible = (getCSS(parent, "opacity") || 1) > 0;

              if (visible && getCSS(parent, "overflow") != "visible") {
                outerRect = parent.getBoundingClientRect();
                visible =
                  eLright > outerRect.left &&
                  eLleft < outerRect.right &&
                  eLbottom > outerRect.top - 1 &&
                  eLtop < outerRect.bottom + 1;
              }
            }

            return visible;
          };

          var checkElements = function () {
            var eLlen,
              i,
              rect,
              autoLoadElem,
              loadedSomething,
              elemExpand,
              elemNegativeExpand,
              elemExpandVal,
              beforeExpandVal,
              defaultExpand,
              preloadExpand,
              hFac;
            var lazyloadElems = lazysizes.elements;

            if ((loadMode = lazySizesCfg.loadMode) && isLoading < 8 && (eLlen = lazyloadElems.length)) {
              i = 0;

              lowRuns++;

              for (; i < eLlen; i++) {
                if (!lazyloadElems[i] || lazyloadElems[i]._lazyRace) {
                  continue;
                }

                if (!supportScroll || (lazysizes.prematureUnveil && lazysizes.prematureUnveil(lazyloadElems[i]))) {
                  unveilElement(lazyloadElems[i]);
                  continue;
                }

                if (
                  !(elemExpandVal = lazyloadElems[i][_getAttribute]("data-expand")) ||
                  !(elemExpand = elemExpandVal * 1)
                ) {
                  elemExpand = currentExpand;
                }

                if (!defaultExpand) {
                  defaultExpand =
                    !lazySizesCfg.expand || lazySizesCfg.expand < 1
                      ? docElem.clientHeight > 500 && docElem.clientWidth > 500
                        ? 500
                        : 370
                      : lazySizesCfg.expand;

                  lazysizes._defEx = defaultExpand;

                  preloadExpand = defaultExpand * lazySizesCfg.expFactor;
                  hFac = lazySizesCfg.hFac;
                  isBodyHidden = null;

                  if (
                    currentExpand < preloadExpand &&
                    isLoading < 1 &&
                    lowRuns > 2 &&
                    loadMode > 2 &&
                    !document.hidden
                  ) {
                    currentExpand = preloadExpand;
                    lowRuns = 0;
                  } else if (loadMode > 1 && lowRuns > 1 && isLoading < 6) {
                    currentExpand = defaultExpand;
                  } else {
                    currentExpand = shrinkExpand;
                  }
                }

                if (beforeExpandVal !== elemExpand) {
                  eLvW = innerWidth + elemExpand * hFac;
                  elvH = innerHeight + elemExpand;
                  elemNegativeExpand = elemExpand * -1;
                  beforeExpandVal = elemExpand;
                }

                rect = lazyloadElems[i].getBoundingClientRect();

                if (
                  (eLbottom = rect.bottom) >= elemNegativeExpand &&
                  (eLtop = rect.top) <= elvH &&
                  (eLright = rect.right) >= elemNegativeExpand * hFac &&
                  (eLleft = rect.left) <= eLvW &&
                  (eLbottom || eLright || eLleft || eLtop) &&
                  (lazySizesCfg.loadHidden || isVisible(lazyloadElems[i])) &&
                  ((isCompleted && isLoading < 3 && !elemExpandVal && (loadMode < 3 || lowRuns < 4)) ||
                    isNestedVisible(lazyloadElems[i], elemExpand))
                ) {
                  unveilElement(lazyloadElems[i]);
                  loadedSomething = true;
                  if (isLoading > 9) {
                    break;
                  }
                } else if (
                  !loadedSomething &&
                  isCompleted &&
                  !autoLoadElem &&
                  isLoading < 4 &&
                  lowRuns < 4 &&
                  loadMode > 2 &&
                  (preloadElems[0] || lazySizesCfg.preloadAfterLoad) &&
                  (preloadElems[0] ||
                    (!elemExpandVal &&
                      (eLbottom ||
                        eLright ||
                        eLleft ||
                        eLtop ||
                        lazyloadElems[i][_getAttribute](lazySizesCfg.sizesAttr) != "auto")))
                ) {
                  autoLoadElem = preloadElems[0] || lazyloadElems[i];
                }
              }

              if (autoLoadElem && !loadedSomething) {
                unveilElement(autoLoadElem);
              }
            }
          };

          var throttledCheckElements = throttle(checkElements);

          var switchLoadingClass = function (e) {
            var elem = e.target;

            if (elem._lazyCache) {
              delete elem._lazyCache;
              return;
            }

            resetPreloading(e);
            addClass(elem, lazySizesCfg.loadedClass);
            removeClass(elem, lazySizesCfg.loadingClass);
            addRemoveLoadEvents(elem, rafSwitchLoadingClass);
            triggerEvent(elem, "lazyloaded");
          };
          var rafedSwitchLoadingClass = rAFIt(switchLoadingClass);
          var rafSwitchLoadingClass = function (e) {
            rafedSwitchLoadingClass({ target: e.target });
          };

          var changeIframeSrc = function (elem, src) {
            try {
              elem.contentWindow.location.replace(src);
            } catch (e) {
              elem.src = src;
            }
          };

          var handleSources = function (source) {
            var customMedia;

            var sourceSrcset = source[_getAttribute](lazySizesCfg.srcsetAttr);

            if (
              (customMedia =
                lazySizesCfg.customMedia[source[_getAttribute]("data-media") || source[_getAttribute]("media")])
            ) {
              source.setAttribute("media", customMedia);
            }

            if (sourceSrcset) {
              source.setAttribute("srcset", sourceSrcset);
            }
          };

          var lazyUnveil = rAFIt(function (elem, detail, isAuto, sizes, isImg) {
            var src, srcset, parent, isPicture, event, firesLoad;

            if (!(event = triggerEvent(elem, "lazybeforeunveil", detail)).defaultPrevented) {
              if (sizes) {
                if (isAuto) {
                  addClass(elem, lazySizesCfg.autosizesClass);
                } else {
                  elem.setAttribute("sizes", sizes);
                }
              }

              srcset = elem[_getAttribute](lazySizesCfg.srcsetAttr);
              src = elem[_getAttribute](lazySizesCfg.srcAttr);

              if (isImg) {
                parent = elem.parentNode;
                isPicture = parent && regPicture.test(parent.nodeName || "");
              }

              firesLoad = detail.firesLoad || ("src" in elem && (srcset || src || isPicture));

              event = { target: elem };

              addClass(elem, lazySizesCfg.loadingClass);

              if (firesLoad) {
                clearTimeout(resetPreloadingTimer);
                resetPreloadingTimer = setTimeout(resetPreloading, 2500);
                addRemoveLoadEvents(elem, rafSwitchLoadingClass, true);
              }

              if (isPicture) {
                forEach.call(parent.getElementsByTagName("source"), handleSources);
              }

              if (srcset) {
                elem.setAttribute("srcset", srcset);
              } else if (src && !isPicture) {
                if (regIframe.test(elem.nodeName)) {
                  changeIframeSrc(elem, src);
                } else {
                  elem.src = src;
                }
              }

              if (isImg && (srcset || isPicture)) {
                updatePolyfill(elem, { src: src });
              }
            }

            if (elem._lazyRace) {
              delete elem._lazyRace;
            }
            removeClass(elem, lazySizesCfg.lazyClass);

            rAF(function () {
              // Part of this can be removed as soon as this fix is older: https://bugs.chromium.org/p/chromium/issues/detail?id=7731 (2015)
              var isLoaded = elem.complete && elem.naturalWidth > 1;

              if (!firesLoad || isLoaded) {
                if (isLoaded) {
                  addClass(elem, "ls-is-cached");
                }
                switchLoadingClass(event);
                elem._lazyCache = true;
                setTimeout(function () {
                  if ("_lazyCache" in elem) {
                    delete elem._lazyCache;
                  }
                }, 9);
              }
              if (elem.loading == "lazy") {
                isLoading--;
              }
            }, true);
          });

          var unveilElement = function (elem) {
            if (elem._lazyRace) {
              return;
            }
            var detail;

            var isImg = regImg.test(elem.nodeName);

            //allow using sizes="auto", but don't use. it's invalid. Use data-sizes="auto" or a valid value for sizes instead (i.e.: sizes="80vw")
            var sizes = isImg && (elem[_getAttribute](lazySizesCfg.sizesAttr) || elem[_getAttribute]("sizes"));
            var isAuto = sizes == "auto";

            if (
              (isAuto || !isCompleted) &&
              isImg &&
              (elem[_getAttribute]("src") || elem.srcset) &&
              !elem.complete &&
              !hasClass(elem, lazySizesCfg.errorClass) &&
              hasClass(elem, lazySizesCfg.lazyClass)
            ) {
              return;
            }

            detail = triggerEvent(elem, "lazyunveilread").detail;

            if (isAuto) {
              autoSizer.updateElem(elem, true, elem.offsetWidth);
            }

            elem._lazyRace = true;
            isLoading++;

            lazyUnveil(elem, detail, isAuto, sizes, isImg);
          };

          var afterScroll = debounce(function () {
            lazySizesCfg.loadMode = 3;
            throttledCheckElements();
          });

          var altLoadmodeScrollListner = function () {
            if (lazySizesCfg.loadMode == 3) {
              lazySizesCfg.loadMode = 2;
            }
            afterScroll();
          };

          var onload = function () {
            if (isCompleted) {
              return;
            }
            if (Date.now() - started < 999) {
              setTimeout(onload, 999);
              return;
            }

            isCompleted = true;

            lazySizesCfg.loadMode = 3;

            throttledCheckElements();

            addEventListener("scroll", altLoadmodeScrollListner, true);
          };

          return {
            _: function () {
              started = Date.now();

              lazysizes.elements = document.getElementsByClassName(lazySizesCfg.lazyClass);
              preloadElems = document.getElementsByClassName(lazySizesCfg.lazyClass + " " + lazySizesCfg.preloadClass);

              addEventListener("scroll", throttledCheckElements, true);

              addEventListener("resize", throttledCheckElements, true);

              addEventListener("pageshow", function (e) {
                if (e.persisted) {
                  var loadingElements = document.querySelectorAll("." + lazySizesCfg.loadingClass);

                  if (loadingElements.length && loadingElements.forEach) {
                    requestAnimationFrame(function () {
                      loadingElements.forEach(function (img) {
                        if (img.complete) {
                          unveilElement(img);
                        }
                      });
                    });
                  }
                }
              });

              if (window.MutationObserver) {
                new MutationObserver(throttledCheckElements).observe(docElem, {
                  childList: true,
                  subtree: true,
                  attributes: true,
                });
              } else {
                docElem[_addEventListener]("DOMNodeInserted", throttledCheckElements, true);
                docElem[_addEventListener]("DOMAttrModified", throttledCheckElements, true);
                setInterval(throttledCheckElements, 999);
              }

              addEventListener("hashchange", throttledCheckElements, true);

              //, 'fullscreenchange'
              ["focus", "mouseover", "click", "load", "transitionend", "animationend"].forEach(function (name) {
                document[_addEventListener](name, throttledCheckElements, true);
              });

              if (/d$|^c/.test(document.readyState)) {
                onload();
              } else {
                addEventListener("load", onload);
                document[_addEventListener]("DOMContentLoaded", throttledCheckElements);
                setTimeout(onload, 20000);
              }

              if (lazysizes.elements.length) {
                checkElements();
                rAF._lsFlush();
              } else {
                throttledCheckElements();
              }
            },
            checkElems: throttledCheckElements,
            unveil: unveilElement,
            _aLSL: altLoadmodeScrollListner,
          };
        })();

        var autoSizer = (function () {
          var autosizesElems;

          var sizeElement = rAFIt(function (elem, parent, event, width) {
            var sources, i, len;
            elem._lazysizesWidth = width;
            width += "px";

            elem.setAttribute("sizes", width);

            if (regPicture.test(parent.nodeName || "")) {
              sources = parent.getElementsByTagName("source");
              for (i = 0, len = sources.length; i < len; i++) {
                sources[i].setAttribute("sizes", width);
              }
            }

            if (!event.detail.dataAttr) {
              updatePolyfill(elem, event.detail);
            }
          });
          var getSizeElement = function (elem, dataAttr, width) {
            var event;
            var parent = elem.parentNode;

            if (parent) {
              width = getWidth(elem, parent, width);
              event = triggerEvent(elem, "lazybeforesizes", { width: width, dataAttr: !!dataAttr });

              if (!event.defaultPrevented) {
                width = event.detail.width;

                if (width && width !== elem._lazysizesWidth) {
                  sizeElement(elem, parent, event, width);
                }
              }
            }
          };

          var updateElementsSizes = function () {
            var i;
            var len = autosizesElems.length;
            if (len) {
              i = 0;

              for (; i < len; i++) {
                getSizeElement(autosizesElems[i]);
              }
            }
          };

          var debouncedUpdateElementsSizes = debounce(updateElementsSizes);

          return {
            _: function () {
              autosizesElems = document.getElementsByClassName(lazySizesCfg.autosizesClass);
              addEventListener("resize", debouncedUpdateElementsSizes);
            },
            checkElems: debouncedUpdateElementsSizes,
            updateElem: getSizeElement,
          };
        })();

        var init = function () {
          if (!init.i && document.getElementsByClassName) {
            init.i = true;
            autoSizer._();
            loader._();
          }
        };

        setTimeout(function () {
          if (lazySizesCfg.init) {
            init();
          }
        });

        lazysizes = {
          cfg: lazySizesCfg,
          autoSizer: autoSizer,
          loader: loader,
          init: init,
          uP: updatePolyfill,
          aC: addClass,
          rC: removeClass,
          hC: hasClass,
          fire: triggerEvent,
          gW: getWidth,
          rAF: rAF,
        };

        return lazysizes;
      });

      /***/
    },
    /* 1 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.formatMoney = formatMoney;
      /**
       * Currency Helpers
       * -----------------------------------------------------------------------------
       * A collection of useful functions that help with currency formatting
       *
       * Current contents
       * - formatMoney - Takes an amount in cents and returns it as a formatted dollar value.
       *
       */

      var moneyFormat = "${{amount}}";

      /**
       * Format money values based on your shop currency settings
       * @param  {Number|string} cents - value in cents or dollar amount e.g. 300 cents
       * or 3.00 dollars
       * @param  {String} format - shop money_format setting
       * @return {String} value - formatted value
       */
      function formatMoney(cents, format) {
        if (typeof cents === "string") {
          cents = cents.replace(".", "");
        }
        var value = "";
        var placeholderRegex = /\{\{\s*(\w+)\s*\}\}/;
        var formatString = format || moneyFormat;

        function formatWithDelimiters(number) {
          var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
          var thousands = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ",";
          var decimal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ".";

          if (isNaN(number) || number == null) {
            return 0;
          }

          number = (number / 100.0).toFixed(precision);

          var parts = number.split(".");
          var dollarsAmount = parts[0].replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1" + thousands);
          var centsAmount = parts[1] ? decimal + parts[1] : "";

          return dollarsAmount + centsAmount;
        }

        switch (formatString.match(placeholderRegex)[1]) {
          case "amount":
            value = formatWithDelimiters(cents, 2);
            break;
          case "amount_no_decimals":
            value = formatWithDelimiters(cents, 0);
            break;
          case "amount_with_comma_separator":
            value = formatWithDelimiters(cents, 2, ".", ",");
            break;
          case "amount_no_decimals_with_comma_separator":
            value = formatWithDelimiters(cents, 0, ".", ",");
            break;
        }

        return formatString.replace(placeholderRegex, value);
      }

      /***/
    },
    /* 2 */
    /***/ function (module, exports) {
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true,
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      module.exports = _defineProperty;

      /***/
    },
    /* 3 */
    /***/ function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__(7);

      /***/
    },
    /* 4 */
    /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.preload = preload;
      exports.loadImage = loadImage;
      exports.imageSize = imageSize;
      exports.getSizedImageUrl = getSizedImageUrl;
      exports.removeProtocol = removeProtocol;
      /**
       * Image Helper Functions
       * -----------------------------------------------------------------------------
       * https://github.com/Shopify/slate.git.
       *
       */

      /**
       * Preloads an image in memory and uses the browsers cache to store it until needed.
       *
       * @param {Array} images - A list of image urls
       * @param {String} size - A shopify image size attribute
       */

      function preload(images, size) {
        if (typeof images === "string") {
          images = [images];
        }

        for (var i = 0; i < images.length; i++) {
          var image = images[i];
          loadImage(getSizedImageUrl(image, size));
        }
      }

      /**
       * Loads and caches an image in the browsers cache.
       * @param {string} path - An image url
       */
      function loadImage(path) {
        new Image().src = path;
      }

      /**
       * Find the Shopify image attribute size
       *
       * @param {string} src
       * @returns {null}
       */
      function imageSize(src) {
        var match = src.match(
          /.+_((?:pico|icon|thumb|small|compact|medium|large|grande)|\d{1,4}x\d{0,4}|x\d{1,4})[_\.@]/
        );

        if (match) {
          return match[1];
        } else {
          return null;
        }
      }

      /**
       * Adds a Shopify size attribute to a URL
       *
       * @param src
       * @param size
       * @returns {*}
       */
      function getSizedImageUrl(src, size) {
        if (size === null) {
          return src;
        }

        if (size === "master") {
          return removeProtocol(src);
        }

        var match = src.match(/\.(jpg|jpeg|gif|png|bmp|bitmap|tiff|tif)(\?v=\d+)?$/i);

        if (match) {
          var prefix = src.split(match[0]);
          var suffix = match[0];

          return removeProtocol(prefix[0] + "_" + size + suffix);
        } else {
          return null;
        }
      }

      function removeProtocol(path) {
        return path.replace(/http(s)?:/, "");
      }

      /***/
    },
    /* 5 */
    /***/ function (module, exports) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }

      function _asyncToGenerator(fn) {
        return function () {
          var self = this,
            args = arguments;
          return new Promise(function (resolve, reject) {
            var gen = fn.apply(self, args);

            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }

            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }

            _next(undefined);
          });
        };
      }

      module.exports = _asyncToGenerator;

      /***/
    },
    /* 6 */
    /***/ function (module, exports, __webpack_require__) {
      /**
       * easytimer.js
       * Generated: 2020-06-20
       * Version: 4.3.0
       */

      (function (global, factory) {
        true ? factory(exports) : undefined;
      })(this, function (exports) {
        "use strict";

        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function (obj) {
              return typeof obj;
            };
          } else {
            _typeof = function (obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };
          }

          return _typeof(obj);
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true,
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);

          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
              symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            keys.push.apply(keys, symbols);
          }

          return keys;
        }

        function _objectSpread2(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};

            if (i % 2) {
              ownKeys(Object(source), true).forEach(function (key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys(Object(source)).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }

          return target;
        }

        function leftPadding(string, padLength, character) {
          var i;
          var characters = "";
          string = typeof string === "number" ? String(string) : string;

          if (string.length > padLength) {
            return string;
          }

          for (i = 0; i < padLength; i = i + 1) {
            characters += String(character);
          }

          return (characters + string).slice(-characters.length);
        }

        function TimeCounter() {
          this.reset();
        }
        /**
         * [toString convert the counted values on a string]
         * @param  {array} units           [array with the units to display]
         * @param  {string} separator       [separator of the units]
         * @param  {number} leftZeroPadding [number of zero padding]
         * @return {string}                 [result string]
         */

        TimeCounter.prototype.toString = function () {
          var units =
            arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ["hours", "minutes", "seconds"];
          var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ":";
          var leftZeroPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
          units = units || ["hours", "minutes", "seconds"];
          separator = separator || ":";
          leftZeroPadding = leftZeroPadding || 2;
          var arrayTime = [];
          var i;

          for (i = 0; i < units.length; i = i + 1) {
            if (this[units[i]] !== undefined) {
              if (units[i] === "secondTenths") {
                arrayTime.push(this[units[i]]);
              } else {
                arrayTime.push(leftPadding(this[units[i]], leftZeroPadding, "0"));
              }
            }
          }

          return arrayTime.join(separator);
        };
        /**
         * [reset reset counter]
         */

        TimeCounter.prototype.reset = function () {
          this.secondTenths = 0;
          this.seconds = 0;
          this.minutes = 0;
          this.hours = 0;
          this.days = 0;
        };

        function EventEmitter() {
          this.events = {};
        }

        EventEmitter.prototype.on = function (event, listener) {
          var _this = this;

          if (!Array.isArray(this.events[event])) {
            this.events[event] = [];
          }

          this.events[event].push(listener);
          return function () {
            return _this.removeListener(event, listener);
          };
        };

        EventEmitter.prototype.removeListener = function (event, listener) {
          if (Array.isArray(this.events[event])) {
            var eventIndex = this.events[event].indexOf(listener);

            if (eventIndex > -1) {
              this.events[event].splice(eventIndex, 1);
            }
          }
        };

        EventEmitter.prototype.emit = function (event) {
          var _this2 = this;

          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          if (Array.isArray(this.events[event])) {
            this.events[event].forEach(function (listener) {
              return listener.apply(_this2, args);
            });
          }
        };

        /*
         * General functions, variables and constants
         */

        var SECOND_TENTHS_PER_SECOND = 10;
        var SECONDS_PER_MINUTE = 60;
        var MINUTES_PER_HOUR = 60;
        var HOURS_PER_DAY = 24;
        var SECOND_TENTHS_POSITION = 0;
        var SECONDS_POSITION = 1;
        var MINUTES_POSITION = 2;
        var HOURS_POSITION = 3;
        var DAYS_POSITION = 4;
        var SECOND_TENTHS = "secondTenths";
        var SECONDS = "seconds";
        var MINUTES = "minutes";
        var HOURS = "hours";
        var DAYS = "days";
        var VALID_INPUT_VALUES = [SECOND_TENTHS, SECONDS, MINUTES, HOURS, DAYS];
        var unitsInMilliseconds = {
          secondTenths: 100,
          seconds: 1000,
          minutes: 60000,
          hours: 3600000,
          days: 86400000,
        };
        var groupedUnits = {
          secondTenths: SECOND_TENTHS_PER_SECOND,
          seconds: SECONDS_PER_MINUTE,
          minutes: MINUTES_PER_HOUR,
          hours: HOURS_PER_DAY,
        };

        function mod(number, module) {
          return ((number % module) + module) % module;
        }
        /**
         * [Timer Timer/Chronometer/Countdown compatible with AMD and NodeJS.
         * Can update time values with different time intervals: tenth of seconds,
         * seconds, minutes and hours.]
         */

        function Timer() {
          var defaultParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          /*
           * PRIVATE variables and Functions
           */
          var counters = new TimeCounter();
          var totalCounters = new TimeCounter();
          var intervalId;
          var eventEmitter = new EventEmitter();
          var running = false;
          var paused = false;
          var precision;
          var timerTypeFactor;
          var customCallback;
          var timerConfig = {};
          var currentParams;
          var targetValues;
          var startValues;
          var countdown;
          var startingDate;
          var targetDate;
          var eventData = {
            detail: {
              timer: this,
            },
          };
          setParams(defaultParams);

          function updateCounters(precision, roundedValue) {
            totalCounters[precision] = roundedValue;

            if (precision === DAYS) {
              counters[precision] = roundedValue;
            } else if (roundedValue >= 0) {
              counters[precision] = mod(roundedValue, groupedUnits[precision]);
            } else {
              counters[precision] = groupedUnits[precision] - mod(roundedValue, groupedUnits[precision]);
            }
          }

          function updateDays(value) {
            return updateUnitByPrecision(value, DAYS);
          }

          function updateHours(value) {
            return updateUnitByPrecision(value, HOURS);
          }

          function updateMinutes(value) {
            return updateUnitByPrecision(value, MINUTES);
          }

          function updateSeconds(value) {
            return updateUnitByPrecision(value, SECONDS);
          }

          function updateSecondTenths(value) {
            return updateUnitByPrecision(value, SECOND_TENTHS);
          }

          function updateUnitByPrecision(value, precision) {
            var previousValue = totalCounters[precision];
            updateCounters(precision, calculateIntegerUnitQuotient(value, unitsInMilliseconds[precision]));
            return totalCounters[precision] !== previousValue;
          }

          function stopTimerAndResetCounters() {
            stopTimer();
            resetCounters();
          }

          function stopTimer() {
            clearInterval(intervalId);
            intervalId = undefined;
            running = false;
            paused = false;
          }

          function setParamsAndStartTimer(params) {
            if (!isPaused()) {
              setParams(params);
            } else {
              startingDate = calculateStartingDate();
              targetValues = setTarget(currentParams.target);
            }

            startTimer();
          }

          function startTimer() {
            var interval = unitsInMilliseconds[precision];

            if (isTargetAchieved(roundTimestamp(Date.now()))) {
              return;
            }

            intervalId = setInterval(updateTimerAndDispatchEvents, interval);
            running = true;
            paused = false;
          }

          function calculateStartingDate() {
            return (
              roundTimestamp(Date.now()) -
              totalCounters.secondTenths * unitsInMilliseconds[SECOND_TENTHS] * timerTypeFactor
            );
          }

          function updateTimerAndDispatchEvents() {
            var currentTime = roundTimestamp(Date.now());
            var valuesUpdated = updateTimer();
            dispatchEvents(valuesUpdated);
            customCallback(eventData.detail.timer);

            if (isTargetAchieved(currentTime)) {
              stop();
              dispatchEvent("targetAchieved", eventData);
            }
          }

          function updateTimer() {
            var currentTime =
              arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : roundTimestamp(Date.now());
            var elapsedTime = timerTypeFactor > 0 ? currentTime - startingDate : startingDate - currentTime;
            var valuesUpdated = {};
            valuesUpdated[SECOND_TENTHS] = updateSecondTenths(elapsedTime);
            valuesUpdated[SECONDS] = updateSeconds(elapsedTime);
            valuesUpdated[MINUTES] = updateMinutes(elapsedTime);
            valuesUpdated[HOURS] = updateHours(elapsedTime);
            valuesUpdated[DAYS] = updateDays(elapsedTime);
            return valuesUpdated;
          }

          function roundTimestamp(timestamp) {
            return Math.floor(timestamp / unitsInMilliseconds[precision]) * unitsInMilliseconds[precision];
          }

          function dispatchEvents(valuesUpdated) {
            if (valuesUpdated[SECOND_TENTHS]) {
              dispatchEvent("secondTenthsUpdated", eventData);
            }

            if (valuesUpdated[SECONDS]) {
              dispatchEvent("secondsUpdated", eventData);
            }

            if (valuesUpdated[MINUTES]) {
              dispatchEvent("minutesUpdated", eventData);
            }

            if (valuesUpdated[HOURS]) {
              dispatchEvent("hoursUpdated", eventData);
            }

            if (valuesUpdated[DAYS]) {
              dispatchEvent("daysUpdated", eventData);
            }
          }

          function isTargetAchieved(currentDate) {
            return targetValues instanceof Array && currentDate >= targetDate;
          }

          function resetCounters() {
            counters.reset();
            totalCounters.reset();
          }

          function setParams(params) {
            params = params || {};
            precision = checkPrecision(params.precision);
            customCallback = typeof params.callback === "function" ? params.callback : function () {};
            countdown = params.countdown === true;
            timerTypeFactor = countdown === true ? -1 : 1;

            if (_typeof(params.startValues) === "object") {
              setStartValues(params.startValues);
            } else {
              startValues = null;
            }

            startingDate = calculateStartingDate();
            updateTimer();

            if (_typeof(params.target) === "object") {
              targetValues = setTarget(params.target);
            } else if (countdown) {
              params.target = {
                seconds: 0,
              };
              targetValues = setTarget(params.target);
            } else {
              targetValues = null;
            }

            timerConfig = {
              precision: precision,
              callback: customCallback,
              countdown: _typeof(params) === "object" && params.countdown === true,
              target: targetValues,
              startValues: startValues,
            };
            currentParams = params;
          }

          function checkPrecision(precision) {
            precision = typeof precision === "string" ? precision : SECONDS;

            if (!isValidInputValue(precision)) {
              throw new Error("Error in precision parameter: ".concat(precision, " is not a valid value"));
            }

            return precision;
          }

          function isValidInputValue(value) {
            return VALID_INPUT_VALUES.indexOf(value) >= 0;
          }

          function configInputValues(inputValues) {
            var values;

            if (_typeof(inputValues) === "object") {
              if (inputValues instanceof Array) {
                if (inputValues.length !== 5) {
                  throw new Error("Array size not valid");
                }

                values = inputValues;
              } else {
                for (var value in inputValues) {
                  if (VALID_INPUT_VALUES.indexOf(value) < 0) {
                    throw new Error(
                      "Error in startValues or target parameter: ".concat(value, " is not a valid input value")
                    );
                  }
                }

                values = [
                  inputValues.secondTenths || 0,
                  inputValues.seconds || 0,
                  inputValues.minutes || 0,
                  inputValues.hours || 0,
                  inputValues.days || 0,
                ];
              }
            }

            var secondTenths = values[SECOND_TENTHS_POSITION];
            var seconds =
              values[SECONDS_POSITION] + calculateIntegerUnitQuotient(secondTenths, SECOND_TENTHS_PER_SECOND);
            var minutes = values[MINUTES_POSITION] + calculateIntegerUnitQuotient(seconds, SECONDS_PER_MINUTE);
            var hours = values[HOURS_POSITION] + calculateIntegerUnitQuotient(minutes, MINUTES_PER_HOUR);
            var days = values[DAYS_POSITION] + calculateIntegerUnitQuotient(hours, HOURS_PER_DAY);
            values[SECOND_TENTHS_POSITION] = secondTenths % SECOND_TENTHS_PER_SECOND;
            values[SECONDS_POSITION] = seconds % SECONDS_PER_MINUTE;
            values[MINUTES_POSITION] = minutes % MINUTES_PER_HOUR;
            values[HOURS_POSITION] = hours % HOURS_PER_DAY;
            values[DAYS_POSITION] = days;
            return values;
          }

          function calculateIntegerUnitQuotient(unit, divisor) {
            var quotient = unit / divisor;
            return quotient < 0 ? Math.ceil(quotient) : Math.floor(quotient);
          }

          function setTarget(inputTarget) {
            if (!inputTarget) {
              return;
            }

            targetValues = configInputValues(inputTarget);
            var targetCounter = calculateTotalCounterFromValues(targetValues);
            targetDate =
              startingDate + targetCounter.secondTenths * unitsInMilliseconds[SECOND_TENTHS] * timerTypeFactor;
            return targetValues;
          }

          function setStartValues(inputStartValues) {
            startValues = configInputValues(inputStartValues);
            counters.secondTenths = startValues[SECOND_TENTHS_POSITION];
            counters.seconds = startValues[SECONDS_POSITION];
            counters.minutes = startValues[MINUTES_POSITION];
            counters.hours = startValues[HOURS_POSITION];
            counters.days = startValues[DAYS_POSITION];
            totalCounters = calculateTotalCounterFromValues(startValues, totalCounters);
          }

          function calculateTotalCounterFromValues(values, outputCounter) {
            var total = outputCounter || {};
            total.days = values[DAYS_POSITION];
            total.hours = total.days * HOURS_PER_DAY + values[HOURS_POSITION];
            total.minutes = total.hours * MINUTES_PER_HOUR + values[MINUTES_POSITION];
            total.seconds = total.minutes * SECONDS_PER_MINUTE + values[SECONDS_POSITION];
            total.secondTenths = total.seconds * SECOND_TENTHS_PER_SECOND + values[[SECOND_TENTHS_POSITION]];
            return total;
          }
          /*
           * PUBLIC functions
           */

          /**
           * [stop stops the timer and resets the counters. Dispatch stopped event]
           */

          function stop() {
            stopTimerAndResetCounters();
            dispatchEvent("stopped", eventData);
          }
          /**
           * [stop stops and starts the timer. Dispatch stopped event]
           */

          function reset() {
            stopTimerAndResetCounters();
            setParamsAndStartTimer(currentParams);
            dispatchEvent("reset", eventData);
          }
          /**
           * [start starts the timer configured by the params object. Dispatch started event]
           * @param  {object} params [Configuration parameters]
           */

          function start() {
            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            params = _objectSpread2(_objectSpread2({}, defaultParams), params);

            if (isRunning()) {
              return;
            }

            setParamsAndStartTimer(params);
            dispatchEvent("started", eventData);
          }
          /**
           * [pause stops the timer without resetting the counters. The timer it can be restarted with start function.
           * Dispatch paused event]
           * @return {type} [description]
           */

          function pause() {
            stopTimer();
            paused = true;
            dispatchEvent("paused", eventData);
          }
          /**
           * [addEventListener Adds event listener to the timer]
           * @param {string} eventType      [event to listen]
           * @param {function} listener   [the event listener function]
           */

          function addEventListener(eventType, listener) {
            eventEmitter.on(eventType, listener);
          }
          /**
           * [removeEventListener Removes event listener to the timer]
           * @param  {string} eventType    [event to remove listener]
           * @param  {function} listener [listener to remove]
           */

          function removeEventListener(eventType, listener) {
            eventEmitter.removeListener(eventType, listener);
          }
          /**
           * [dispatchEvent dispatches an event]
           * @param  {string} eventType [event to dispatch]
           * @param data
           */

          function dispatchEvent(eventType, data) {
            eventEmitter.emit(eventType, data);
          }
          /**
           * [isRunning return true if the timer is running]
           * @return {Boolean}
           */

          function isRunning() {
            return running;
          }
          /**
           * [isPaused returns true if the timer is paused]
           * @return {Boolean}
           */

          function isPaused() {
            return paused;
          }
          /**
           * [getTimeValues returns the counter with the current timer values]
           * @return {TimeCounter}
           */

          function getTimeValues() {
            return counters;
          }
          /**
           * [getTotalTimeValues returns the counter with the current timer total values]
           * @return {TimeCounter}
           */

          function getTotalTimeValues() {
            return totalCounters;
          }
          /**
           * [getConfig returns the configuration parameters]
           * @return {type}
           */

          function getConfig() {
            return timerConfig;
          }
          /**
           * Public API
           * Definition of Timer instance public functions
           */

          if (typeof this !== "undefined") {
            this.start = start;
            this.pause = pause;
            this.stop = stop;
            this.reset = reset;
            this.isRunning = isRunning;
            this.isPaused = isPaused;
            this.getTimeValues = getTimeValues;
            this.getTotalTimeValues = getTotalTimeValues;
            this.getConfig = getConfig;
            this.addEventListener = addEventListener;
            this.on = addEventListener;
            this.removeEventListener = removeEventListener;
            this.off = removeEventListener;
          }
        }

        exports.Timer = Timer;
        exports.default = Timer;

        Object.defineProperty(exports, "__esModule", { value: true });
      });

      /***/
    },
    /* 7 */
    /***/ function (module, exports, __webpack_require__) {
      /**
       * Copyright (c) 2014-present, Facebook, Inc.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */

      var runtime = (function (exports) {
        "use strict";

        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var undefined; // More compressible than void 0.
        var $Symbol = typeof Symbol === "function" ? Symbol : {};
        var iteratorSymbol = $Symbol.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

        function define(obj, key, value) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true,
          });
          return obj[key];
        }
        try {
          // IE 8 has a broken Object.defineProperty that only works on DOM objects.
          define({}, "");
        } catch (err) {
          define = function (obj, key, value) {
            return (obj[key] = value);
          };
        }

        function wrap(innerFn, outerFn, self, tryLocsList) {
          // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
          var generator = Object.create(protoGenerator.prototype);
          var context = new Context(tryLocsList || []);

          // The ._invoke method unifies the implementations of the .next,
          // .throw, and .return methods.
          generator._invoke = makeInvokeMethod(innerFn, self, context);

          return generator;
        }
        exports.wrap = wrap;

        // Try/catch helper to minimize deoptimizations. Returns a completion
        // record like context.tryEntries[i].completion. This interface could
        // have been (and was previously) designed to take a closure to be
        // invoked without arguments, but in all the cases we care about we
        // already have an existing method we want to call, so there's no need
        // to create a new function object. We can even get away with assuming
        // the method takes exactly one argument, since that happens to be true
        // in every case, so we don't have to touch the arguments object. The
        // only additional allocation required is the completion record, which
        // has a stable shape and so hopefully should be cheap to allocate.
        function tryCatch(fn, obj, arg) {
          try {
            return { type: "normal", arg: fn.call(obj, arg) };
          } catch (err) {
            return { type: "throw", arg: err };
          }
        }

        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed";

        // Returning this object from the innerFn has the same effect as
        // breaking out of the dispatch switch statement.
        var ContinueSentinel = {};

        // Dummy constructor functions that we use as the .constructor and
        // .constructor.prototype properties for functions that return Generator
        // objects. For full spec compliance, you may wish to configure your
        // minifier not to mangle the names of these two functions.
        function Generator() {}
        function GeneratorFunction() {}
        function GeneratorFunctionPrototype() {}

        // This is a polyfill for %IteratorPrototype% for environments that
        // don't natively support it.
        var IteratorPrototype = {};
        IteratorPrototype[iteratorSymbol] = function () {
          return this;
        };

        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        if (
          NativeIteratorPrototype &&
          NativeIteratorPrototype !== Op &&
          hasOwn.call(NativeIteratorPrototype, iteratorSymbol)
        ) {
          // This environment has a native %IteratorPrototype%; use it instead
          // of the polyfill.
          IteratorPrototype = NativeIteratorPrototype;
        }

        var Gp = (GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype));
        GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
        GeneratorFunctionPrototype.constructor = GeneratorFunction;
        GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");

        // Helper for defining the .next, .throw, and .return methods of the
        // Iterator interface in terms of a single ._invoke method.
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function (method) {
            define(prototype, method, function (arg) {
              return this._invoke(method, arg);
            });
          });
        }

        exports.isGeneratorFunction = function (genFun) {
          var ctor = typeof genFun === "function" && genFun.constructor;
          return ctor
            ? ctor === GeneratorFunction ||
                // For the native GeneratorFunction constructor, the best we can
                // do is to check its .name property.
                (ctor.displayName || ctor.name) === "GeneratorFunction"
            : false;
        };

        exports.mark = function (genFun) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
          } else {
            genFun.__proto__ = GeneratorFunctionPrototype;
            define(genFun, toStringTagSymbol, "GeneratorFunction");
          }
          genFun.prototype = Object.create(Gp);
          return genFun;
        };

        // Within the body of any async function, `await x` is transformed to
        // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
        // `hasOwn.call(value, "__await")` to determine if the yielded value is
        // meant to be awaited.
        exports.awrap = function (arg) {
          return { __await: arg };
        };

        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if (record.type === "throw") {
              reject(record.arg);
            } else {
              var result = record.arg;
              var value = result.value;
              if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                return PromiseImpl.resolve(value.__await).then(
                  function (value) {
                    invoke("next", value, resolve, reject);
                  },
                  function (err) {
                    invoke("throw", err, resolve, reject);
                  }
                );
              }

              return PromiseImpl.resolve(value).then(
                function (unwrapped) {
                  // When a yielded Promise is resolved, its final value becomes
                  // the .value of the Promise<{value,done}> result for the
                  // current iteration.
                  result.value = unwrapped;
                  resolve(result);
                },
                function (error) {
                  // If a rejected Promise was yielded, throw the rejection back
                  // into the async generator function so it can be handled there.
                  return invoke("throw", error, resolve, reject);
                }
              );
            }
          }

          var previousPromise;

          function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function (resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }

            return (previousPromise =
              // If enqueue has been called before, then we want to wait until
              // all previous Promises have been resolved before calling invoke,
              // so that results are always delivered in the correct order. If
              // enqueue has not been called before, then it is important to
              // call invoke immediately, without waiting on a callback to fire,
              // so that the async generator function has the opportunity to do
              // any necessary setup in a predictable way. This predictability
              // is why the Promise constructor synchronously invokes its
              // executor callback, and why async functions synchronously
              // execute code before the first await. Since we implement simple
              // async functions in terms of async generators, it is especially
              // important to get this right, even though it requires care.
              previousPromise
                ? previousPromise.then(
                    callInvokeWithMethodAndArg,
                    // Avoid propagating failures to Promises returned by later
                    // invocations of the iterator.
                    callInvokeWithMethodAndArg
                  )
                : callInvokeWithMethodAndArg());
          }

          // Define the unified helper method that is used to implement .next,
          // .throw, and .return (see defineIteratorMethods).
          this._invoke = enqueue;
        }

        defineIteratorMethods(AsyncIterator.prototype);
        AsyncIterator.prototype[asyncIteratorSymbol] = function () {
          return this;
        };
        exports.AsyncIterator = AsyncIterator;

        // Note that simple async functions are implemented on top of
        // AsyncIterator objects; they just return a Promise for the value of
        // the final result produced by the iterator.
        exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
          if (PromiseImpl === void 0) PromiseImpl = Promise;

          var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);

          return exports.isGeneratorFunction(outerFn)
            ? iter // If outerFn is a generator, return the full iterator.
            : iter.next().then(function (result) {
                return result.done ? result.value : iter.next();
              });
        };

        function makeInvokeMethod(innerFn, self, context) {
          var state = GenStateSuspendedStart;

          return function invoke(method, arg) {
            if (state === GenStateExecuting) {
              throw new Error("Generator is already running");
            }

            if (state === GenStateCompleted) {
              if (method === "throw") {
                throw arg;
              }

              // Be forgiving, per 25.3.3.3.3 of the spec:
              // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
              return doneResult();
            }

            context.method = method;
            context.arg = arg;

            while (true) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }

              if (context.method === "next") {
                // Setting context._sent for legacy support of Babel's
                // function.sent implementation.
                context.sent = context._sent = context.arg;
              } else if (context.method === "throw") {
                if (state === GenStateSuspendedStart) {
                  state = GenStateCompleted;
                  throw context.arg;
                }

                context.dispatchException(context.arg);
              } else if (context.method === "return") {
                context.abrupt("return", context.arg);
              }

              state = GenStateExecuting;

              var record = tryCatch(innerFn, self, context);
              if (record.type === "normal") {
                // If an exception is thrown from innerFn, we leave state ===
                // GenStateExecuting and loop back for another invocation.
                state = context.done ? GenStateCompleted : GenStateSuspendedYield;

                if (record.arg === ContinueSentinel) {
                  continue;
                }

                return {
                  value: record.arg,
                  done: context.done,
                };
              } else if (record.type === "throw") {
                state = GenStateCompleted;
                // Dispatch the exception by looping back around to the
                // context.dispatchException(context.arg) call above.
                context.method = "throw";
                context.arg = record.arg;
              }
            }
          };
        }

        // Call delegate.iterator[context.method](context.arg) and handle the
        // result, either by returning a { value, done } result from the
        // delegate iterator, or by modifying context.method and context.arg,
        // setting context.delegate to null, and returning the ContinueSentinel.
        function maybeInvokeDelegate(delegate, context) {
          var method = delegate.iterator[context.method];
          if (method === undefined) {
            // A .throw or .return when the delegate iterator has no .throw
            // method always terminates the yield* loop.
            context.delegate = null;

            if (context.method === "throw") {
              // Note: ["return"] must be used for ES3 parsing compatibility.
              if (delegate.iterator["return"]) {
                // If the delegate iterator has a return method, give it a
                // chance to clean up.
                context.method = "return";
                context.arg = undefined;
                maybeInvokeDelegate(delegate, context);

                if (context.method === "throw") {
                  // If maybeInvokeDelegate(context) changed context.method from
                  // "return" to "throw", let that override the TypeError below.
                  return ContinueSentinel;
                }
              }

              context.method = "throw";
              context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }

            return ContinueSentinel;
          }

          var record = tryCatch(method, delegate.iterator, context.arg);

          if (record.type === "throw") {
            context.method = "throw";
            context.arg = record.arg;
            context.delegate = null;
            return ContinueSentinel;
          }

          var info = record.arg;

          if (!info) {
            context.method = "throw";
            context.arg = new TypeError("iterator result is not an object");
            context.delegate = null;
            return ContinueSentinel;
          }

          if (info.done) {
            // Assign the result of the finished delegate to the temporary
            // variable specified by delegate.resultName (see delegateYield).
            context[delegate.resultName] = info.value;

            // Resume execution at the desired location (see delegateYield).
            context.next = delegate.nextLoc;

            // If context.method was "throw" but the delegate handled the
            // exception, let the outer generator proceed normally. If
            // context.method was "next", forget context.arg since it has been
            // "consumed" by the delegate iterator. If context.method was
            // "return", allow the original .return call to continue in the
            // outer generator.
            if (context.method !== "return") {
              context.method = "next";
              context.arg = undefined;
            }
          } else {
            // Re-yield the result returned by the delegate method.
            return info;
          }

          // The delegate iterator is finished, so forget it and continue with
          // the outer generator.
          context.delegate = null;
          return ContinueSentinel;
        }

        // Define Generator.prototype.{next,throw,return} in terms of the
        // unified ._invoke helper method.
        defineIteratorMethods(Gp);

        define(Gp, toStringTagSymbol, "Generator");

        // A Generator should always return itself as the iterator object when the
        // @@iterator function is called on it. Some browsers' implementations of the
        // iterator prototype chain incorrectly implement this, causing the Generator
        // object to not be returned from this call. This ensures that doesn't happen.
        // See https://github.com/facebook/regenerator/issues/274 for more details.
        Gp[iteratorSymbol] = function () {
          return this;
        };

        Gp.toString = function () {
          return "[object Generator]";
        };

        function pushTryEntry(locs) {
          var entry = { tryLoc: locs[0] };

          if (1 in locs) {
            entry.catchLoc = locs[1];
          }

          if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
          }

          this.tryEntries.push(entry);
        }

        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal";
          delete record.arg;
          entry.completion = record;
        }

        function Context(tryLocsList) {
          // The root entry object (effectively a try statement without a catch
          // or a finally block) gives us a place to store values thrown from
          // locations where there is no enclosing try statement.
          this.tryEntries = [{ tryLoc: "root" }];
          tryLocsList.forEach(pushTryEntry, this);
          this.reset(true);
        }

        exports.keys = function (object) {
          var keys = [];
          for (var key in object) {
            keys.push(key);
          }
          keys.reverse();

          // Rather than returning an object with a next method, we keep
          // things simple and return the next function itself.
          return function next() {
            while (keys.length) {
              var key = keys.pop();
              if (key in object) {
                next.value = key;
                next.done = false;
                return next;
              }
            }

            // To avoid creating an additional object, we just hang the .value
            // and .done properties off the next function object itself. This
            // also ensures that the minifier will not anonymize the function.
            next.done = true;
            return next;
          };
        };

        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) {
              return iteratorMethod.call(iterable);
            }

            if (typeof iterable.next === "function") {
              return iterable;
            }

            if (!isNaN(iterable.length)) {
              var i = -1,
                next = function next() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next.value = iterable[i];
                      next.done = false;
                      return next;
                    }
                  }

                  next.value = undefined;
                  next.done = true;

                  return next;
                };

              return (next.next = next);
            }
          }

          // Return an iterator with no values.
          return { next: doneResult };
        }
        exports.values = values;

        function doneResult() {
          return { value: undefined, done: true };
        }

        Context.prototype = {
          constructor: Context,

          reset: function (skipTempReset) {
            this.prev = 0;
            this.next = 0;
            // Resetting context._sent for legacy support of Babel's
            // function.sent implementation.
            this.sent = this._sent = undefined;
            this.done = false;
            this.delegate = null;

            this.method = "next";
            this.arg = undefined;

            this.tryEntries.forEach(resetTryEntry);

            if (!skipTempReset) {
              for (var name in this) {
                // Not sure about the optimal order of these conditions:
                if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                  this[name] = undefined;
                }
              }
            }
          },

          stop: function () {
            this.done = true;

            var rootEntry = this.tryEntries[0];
            var rootRecord = rootEntry.completion;
            if (rootRecord.type === "throw") {
              throw rootRecord.arg;
            }

            return this.rval;
          },

          dispatchException: function (exception) {
            if (this.done) {
              throw exception;
            }

            var context = this;
            function handle(loc, caught) {
              record.type = "throw";
              record.arg = exception;
              context.next = loc;

              if (caught) {
                // If the dispatched exception was caught by a catch block,
                // then let that catch block handle the exception normally.
                context.method = "next";
                context.arg = undefined;
              }

              return !!caught;
            }

            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              var record = entry.completion;

              if (entry.tryLoc === "root") {
                // Exception thrown outside of any try block that could handle
                // it, so set the completion value of the entire function to
                // throw the exception.
                return handle("end");
              }

              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc");
                var hasFinally = hasOwn.call(entry, "finallyLoc");

                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  } else if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  }
                } else if (hasFinally) {
                  if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else {
                  throw new Error("try statement without catch or finally");
                }
              }
            }
          },

          abrupt: function (type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }

            if (
              finallyEntry &&
              (type === "break" || type === "continue") &&
              finallyEntry.tryLoc <= arg &&
              arg <= finallyEntry.finallyLoc
            ) {
              // Ignore the finally entry if control is not jumping to a
              // location outside the try/catch block.
              finallyEntry = null;
            }

            var record = finallyEntry ? finallyEntry.completion : {};
            record.type = type;
            record.arg = arg;

            if (finallyEntry) {
              this.method = "next";
              this.next = finallyEntry.finallyLoc;
              return ContinueSentinel;
            }

            return this.complete(record);
          },

          complete: function (record, afterLoc) {
            if (record.type === "throw") {
              throw record.arg;
            }

            if (record.type === "break" || record.type === "continue") {
              this.next = record.arg;
            } else if (record.type === "return") {
              this.rval = this.arg = record.arg;
              this.method = "return";
              this.next = "end";
            } else if (record.type === "normal" && afterLoc) {
              this.next = afterLoc;
            }

            return ContinueSentinel;
          },

          finish: function (finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.finallyLoc === finallyLoc) {
                this.complete(entry.completion, entry.afterLoc);
                resetTryEntry(entry);
                return ContinueSentinel;
              }
            }
          },

          catch: function (tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if (record.type === "throw") {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }

            // The context.catch method must only be called with a location
            // argument that corresponds to a known catch block.
            throw new Error("illegal catch attempt");
          },

          delegateYield: function (iterable, resultName, nextLoc) {
            this.delegate = {
              iterator: values(iterable),
              resultName: resultName,
              nextLoc: nextLoc,
            };

            if (this.method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              this.arg = undefined;
            }

            return ContinueSentinel;
          },
        };

        // Regardless of whether this script is executing as a CommonJS module
        // or not, return the runtime object so that we can declare the variable
        // regeneratorRuntime in the outer scope, which allows this module to be
        // injected easily by `bin/regenerator --include-runtime script.js`.
        return exports;
      })(
        // If this script is executing as a CommonJS module, use module.exports
        // as the regeneratorRuntime namespace. Otherwise create a new empty
        // object. Either way, the resulting object will be used to initialize
        // the regeneratorRuntime variable at the top of this file.
        true ? module.exports : undefined
      );

      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        // This module should not be running in strict mode, so the above
        // assignment should always work unless something is misconfigured. Just
        // in case runtime.js accidentally runs in strict mode, we can escape
        // strict mode using a global Function call. This could conceivably fail
        // if a Content Security Policy forbids using Function, but in that case
        // the proper solution is to fix the accidental strict mode problem. If
        // you've misconfigured your bundler to force strict mode and applied a
        // CSP to forbid Function, and you're not willing to fix either of those
        // problems, please detail your unique predicament in a GitHub issue.
        Function("r", "regeneratorRuntime = r")(runtime);
      }

      /***/
    },
    /* 8 */
    /***/ function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__; /*
This plugin extends lazySizes to lazyLoad:
background images, videos/posters and scripts

Background-Image:
For background images, use data-bg attribute:
<div class="lazyload" data-bg="bg-img.jpg"></div>

 Video:
 For video/audio use data-poster and preload="none":
 <video class="lazyload" preload="none" data-poster="poster.jpg" src="src.mp4">
 <!-- sources -->
 </video>

 For video that plays automatically if in view:
 <video
	class="lazyload"
	preload="none"
	muted=""
	data-autoplay=""
	data-poster="poster.jpg"
	src="src.mp4">
</video>

 Scripts:
 For scripts use data-script:
 <div class="lazyload" data-script="module-name.js"></div>


 Script modules using require:
 For modules using require use data-require:
 <div class="lazyload" data-require="module-name"></div>
*/

      (function (window, factory) {
        var globalInstall = function () {
          factory(window.lazySizes);
          window.removeEventListener("lazyunveilread", globalInstall, true);
        };

        factory = factory.bind(null, window, window.document);

        if (true && module.exports) {
          factory(__webpack_require__(0));
        } else if (true) {
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(window, function (window, document, lazySizes) {
        /*jshint eqnull:true */
        "use strict";
        var bgLoad, regBgUrlEscape;
        var uniqueUrls = {};

        if (document.addEventListener) {
          regBgUrlEscape = /\(|\)|\s|'/;

          bgLoad = function (url, cb) {
            var img = document.createElement("img");
            img.onload = function () {
              img.onload = null;
              img.onerror = null;
              img = null;
              cb();
            };
            img.onerror = img.onload;

            img.src = url;

            if (img && img.complete && img.onload) {
              img.onload();
            }
          };

          addEventListener(
            "lazybeforeunveil",
            function (e) {
              if (e.detail.instance != lazySizes) {
                return;
              }

              var tmp, load, bg, poster;
              if (!e.defaultPrevented) {
                var target = e.target;

                if (target.preload == "none") {
                  target.preload = target.getAttribute("data-preload") || "auto";
                }

                if (target.getAttribute("data-autoplay") != null) {
                  if (target.getAttribute("data-expand") && !target.autoplay) {
                    try {
                      target.play();
                    } catch (er) {}
                  } else {
                    requestAnimationFrame(function () {
                      target.setAttribute("data-expand", "-10");
                      lazySizes.aC(target, lazySizes.cfg.lazyClass);
                    });
                  }
                }

                tmp = target.getAttribute("data-link");
                if (tmp) {
                  addStyleScript(tmp, true);
                }

                // handle data-script
                tmp = target.getAttribute("data-script");
                if (tmp) {
                  addStyleScript(tmp);
                }

                // handle data-require
                tmp = target.getAttribute("data-require");
                if (tmp) {
                  if (lazySizes.cfg.requireJs) {
                    lazySizes.cfg.requireJs([tmp]);
                  } else {
                    addStyleScript(tmp);
                  }
                }

                // handle data-bg
                bg = target.getAttribute("data-bg");
                if (bg) {
                  e.detail.firesLoad = true;
                  load = function () {
                    target.style.backgroundImage = "url(" + (regBgUrlEscape.test(bg) ? JSON.stringify(bg) : bg) + ")";
                    e.detail.firesLoad = false;
                    lazySizes.fire(target, "_lazyloaded", {}, true, true);
                  };

                  bgLoad(bg, load);
                }

                // handle data-poster
                poster = target.getAttribute("data-poster");
                if (poster) {
                  e.detail.firesLoad = true;
                  load = function () {
                    target.poster = poster;
                    e.detail.firesLoad = false;
                    lazySizes.fire(target, "_lazyloaded", {}, true, true);
                  };

                  bgLoad(poster, load);
                }
              }
            },
            false
          );
        }

        function addStyleScript(src, style) {
          if (uniqueUrls[src]) {
            return;
          }
          var elem = document.createElement(style ? "link" : "script");
          var insertElem = document.getElementsByTagName("script")[0];

          if (style) {
            elem.rel = "stylesheet";
            elem.href = src;
          } else {
            elem.src = src;
          }
          uniqueUrls[src] = true;
          uniqueUrls[elem.src || elem.href] = true;
          insertElem.parentNode.insertBefore(elem, insertElem);
        }
      });

      /***/
    },
    /* 9 */
    /***/ function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
      (function (window, factory) {
        if (!window) {
          return;
        }
        var globalInstall = function () {
          factory(window.lazySizes);
          window.removeEventListener("lazyunveilread", globalInstall, true);
        };

        factory = factory.bind(null, window, window.document);

        if (true && module.exports) {
          factory(__webpack_require__(0));
        } else if (true) {
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(typeof window != "undefined" ? window : 0, function (window, document, lazySizes) {
        "use strict";

        if (!window.addEventListener) {
          return;
        }

        var regDescriptors = /\s+(\d+)(w|h)\s+(\d+)(w|h)/;
        var regCssFit = /parent-fit["']*\s*:\s*["']*(contain|cover|width)/;
        var regCssObject = /parent-container["']*\s*:\s*["']*(.+?)(?=(\s|$|,|'|"|;))/;
        var regPicture = /^picture$/i;
        var cfg = lazySizes.cfg;

        var getCSS = function (elem) {
          return getComputedStyle(elem, null) || {};
        };

        var parentFit = {
          getParent: function (element, parentSel) {
            var parent = element;
            var parentNode = element.parentNode;

            if ((!parentSel || parentSel == "prev") && parentNode && regPicture.test(parentNode.nodeName || "")) {
              parentNode = parentNode.parentNode;
            }

            if (parentSel != "self") {
              if (parentSel == "prev") {
                parent = element.previousElementSibling;
              } else if (parentSel && (parentNode.closest || window.jQuery)) {
                parent =
                  (parentNode.closest ? parentNode.closest(parentSel) : jQuery(parentNode).closest(parentSel)[0]) ||
                  parentNode;
              } else {
                parent = parentNode;
              }
            }

            return parent;
          },

          getFit: function (element) {
            var tmpMatch, parentObj;
            var css = getCSS(element);
            var content = css.content || css.fontFamily;
            var obj = {
              fit: element._lazysizesParentFit || element.getAttribute("data-parent-fit"),
            };

            if (!obj.fit && content && (tmpMatch = content.match(regCssFit))) {
              obj.fit = tmpMatch[1];
            }

            if (obj.fit) {
              parentObj = element._lazysizesParentContainer || element.getAttribute("data-parent-container");

              if (!parentObj && content && (tmpMatch = content.match(regCssObject))) {
                parentObj = tmpMatch[1];
              }

              obj.parent = parentFit.getParent(element, parentObj);
            } else {
              obj.fit = css.objectFit;
            }

            return obj;
          },

          getImageRatio: function (element) {
            var i, srcset, media, ratio, match, width, height;
            var parent = element.parentNode;
            var elements =
              parent && regPicture.test(parent.nodeName || "") ? parent.querySelectorAll("source, img") : [element];
            for (i = 0; i < elements.length; i++) {
              element = elements[i];
              srcset =
                element.getAttribute(cfg.srcsetAttr) ||
                element.getAttribute("srcset") ||
                element.getAttribute("data-pfsrcset") ||
                element.getAttribute("data-risrcset") ||
                "";
              media = element._lsMedia || element.getAttribute("media");
              media = cfg.customMedia[element.getAttribute("data-media") || media] || media;

              if (srcset && (!media || ((window.matchMedia && matchMedia(media)) || {}).matches)) {
                ratio = parseFloat(element.getAttribute("data-aspectratio"));

                if (!ratio) {
                  match = srcset.match(regDescriptors);

                  if (match) {
                    if (match[2] == "w") {
                      width = match[1];
                      height = match[3];
                    } else {
                      width = match[3];
                      height = match[1];
                    }
                  } else {
                    width = element.getAttribute("width");
                    height = element.getAttribute("height");
                  }

                  ratio = width / height;
                }

                break;
              }
            }

            return ratio;
          },

          calculateSize: function (element, width) {
            var displayRatio, height, imageRatio, retWidth;
            var fitObj = this.getFit(element);
            var fit = fitObj.fit;
            var fitElem = fitObj.parent;

            if (
              fit != "width" &&
              ((fit != "contain" && fit != "cover") || !(imageRatio = this.getImageRatio(element)))
            ) {
              return width;
            }

            if (fitElem) {
              width = fitElem.clientWidth;
            } else {
              fitElem = element;
            }

            retWidth = width;

            if (fit == "width") {
              retWidth = width;
            } else {
              height = fitElem.clientHeight;

              if (
                (displayRatio = width / height) &&
                ((fit == "cover" && displayRatio < imageRatio) || (fit == "contain" && displayRatio > imageRatio))
              ) {
                retWidth = width * (imageRatio / displayRatio);
              }
            }

            return retWidth;
          },
        };

        lazySizes.parentFit = parentFit;

        document.addEventListener("lazybeforesizes", function (e) {
          if (e.defaultPrevented || e.detail.instance != lazySizes) {
            return;
          }

          var element = e.target;
          e.detail.width = parentFit.calculateSize(element, e.detail.width);
        });
      });

      /***/
    },
    /* 10 */
    /***/ function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
      (function (window, factory) {
        if (!window) {
          return;
        }
        var globalInstall = function (initialEvent) {
          factory(window.lazySizes, initialEvent);
          window.removeEventListener("lazyunveilread", globalInstall, true);
        };

        factory = factory.bind(null, window, window.document);

        if (true && module.exports) {
          factory(__webpack_require__(0));
        } else if (true) {
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(typeof window != "undefined" ? window : 0, function (window, document, lazySizes, initialEvent) {
        "use strict";
        var cloneElementClass;
        var style = document.createElement("a").style;
        var fitSupport = "objectFit" in style;
        var positionSupport = fitSupport && "objectPosition" in style;
        var regCssFit = /object-fit["']*\s*:\s*["']*(contain|cover)/;
        var regCssPosition = /object-position["']*\s*:\s*["']*(.+?)(?=($|,|'|"|;))/;
        var blankSrc = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        var regBgUrlEscape = /\(|\)|'/;
        var positionDefaults = {
          center: "center",
          "50% 50%": "center",
        };

        function getObject(element) {
          var css = getComputedStyle(element, null) || {};
          var content = css.fontFamily || "";
          var objectFit = content.match(regCssFit) || "";
          var objectPosition = (objectFit && content.match(regCssPosition)) || "";

          if (objectPosition) {
            objectPosition = objectPosition[1];
          }

          return {
            fit: (objectFit && objectFit[1]) || "",
            position: positionDefaults[objectPosition] || objectPosition || "center",
          };
        }

        function generateStyleClass() {
          if (cloneElementClass) {
            return;
          }

          var styleElement = document.createElement("style");

          cloneElementClass = lazySizes.cfg.objectFitClass || "lazysizes-display-clone";

          document.querySelector("head").appendChild(styleElement);
        }

        function removePrevClone(element) {
          var prev = element.previousElementSibling;

          if (prev && lazySizes.hC(prev, cloneElementClass)) {
            prev.parentNode.removeChild(prev);
            element.style.position = prev.getAttribute("data-position") || "";
            element.style.visibility = prev.getAttribute("data-visibility") || "";
          }
        }

        function initFix(element, config) {
          var switchClassesAdded, addedSrc, styleElement, styleElementStyle;
          var lazysizesCfg = lazySizes.cfg;

          var onChange = function () {
            var src = element.currentSrc || element.src;

            if (src && addedSrc !== src) {
              addedSrc = src;
              styleElementStyle.backgroundImage = "url(" + (regBgUrlEscape.test(src) ? JSON.stringify(src) : src) + ")";

              if (!switchClassesAdded) {
                switchClassesAdded = true;
                lazySizes.rC(styleElement, lazysizesCfg.loadingClass);
                lazySizes.aC(styleElement, lazysizesCfg.loadedClass);
              }
            }
          };
          var rafedOnChange = function () {
            lazySizes.rAF(onChange);
          };

          element._lazysizesParentFit = config.fit;

          element.addEventListener("lazyloaded", rafedOnChange, true);
          element.addEventListener("load", rafedOnChange, true);

          lazySizes.rAF(function () {
            var hideElement = element;
            var container = element.parentNode;

            if (container.nodeName.toUpperCase() == "PICTURE") {
              hideElement = container;
              container = container.parentNode;
            }

            removePrevClone(hideElement);

            if (!cloneElementClass) {
              generateStyleClass();
            }

            styleElement = element.cloneNode(false);
            styleElementStyle = styleElement.style;

            styleElement.addEventListener("load", function () {
              var curSrc = styleElement.currentSrc || styleElement.src;

              if (curSrc && curSrc != blankSrc) {
                styleElement.src = blankSrc;
                styleElement.srcset = "";
              }
            });

            lazySizes.rC(styleElement, lazysizesCfg.loadedClass);
            lazySizes.rC(styleElement, lazysizesCfg.lazyClass);
            lazySizes.rC(styleElement, lazysizesCfg.autosizesClass);
            lazySizes.aC(styleElement, lazysizesCfg.loadingClass);
            lazySizes.aC(styleElement, cloneElementClass);

            [
              "data-parent-fit",
              "data-parent-container",
              "data-object-fit-polyfilled",
              lazysizesCfg.srcsetAttr,
              lazysizesCfg.srcAttr,
            ].forEach(function (attr) {
              styleElement.removeAttribute(attr);
            });

            styleElement.src = blankSrc;
            styleElement.srcset = "";

            styleElementStyle.backgroundRepeat = "no-repeat";
            styleElementStyle.backgroundPosition = config.position;
            styleElementStyle.backgroundSize = config.fit;

            styleElement.setAttribute("data-position", hideElement.style.position);
            styleElement.setAttribute("data-visibility", hideElement.style.visibility);

            hideElement.style.visibility = "hidden";
            hideElement.style.position = "absolute";

            element.setAttribute("data-parent-fit", config.fit);
            element.setAttribute("data-parent-container", "prev");
            element.setAttribute("data-object-fit-polyfilled", "");
            element._objectFitPolyfilledDisplay = styleElement;

            container.insertBefore(styleElement, hideElement);

            if (element._lazysizesParentFit) {
              delete element._lazysizesParentFit;
            }

            if (element.complete) {
              onChange();
            }
          });
        }

        if (!fitSupport || !positionSupport) {
          var onRead = function (e) {
            if (e.detail.instance != lazySizes) {
              return;
            }

            var element = e.target;
            var obj = getObject(element);

            if (obj.fit && (!fitSupport || obj.position != "center")) {
              initFix(element, obj);
              return true;
            }

            return false;
          };

          window.addEventListener("lazybeforesizes", function (e) {
            if (e.detail.instance != lazySizes) {
              return;
            }
            var element = e.target;

            if (element.getAttribute("data-object-fit-polyfilled") != null && !element._objectFitPolyfilledDisplay) {
              if (!onRead(e)) {
                lazySizes.rAF(function () {
                  element.removeAttribute("data-object-fit-polyfilled");
                });
              }
            }
          });
          window.addEventListener("lazyunveilread", onRead, true);

          if (initialEvent && initialEvent.detail) {
            onRead(initialEvent);
          }
        }
      });

      /***/
    },
    /* 11 */
    /***/ function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
      (function (window, factory) {
        var globalInstall = function () {
          factory(window.lazySizes);
          window.removeEventListener("lazyunveilread", globalInstall, true);
        };

        factory = factory.bind(null, window, window.document);

        if (true && module.exports) {
          factory(__webpack_require__(0));
        } else if (true) {
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(window, function (window, document, lazySizes) {
        "use strict";
        if (!window.addEventListener) {
          return;
        }

        var lazySizesCfg = lazySizes.cfg;
        var regWhite = /\s+/g;
        var regSplitSet = /\s*\|\s+|\s+\|\s*/g;
        var regSource = /^(.+?)(?:\s+\[\s*(.+?)\s*\])(?:\s+\[\s*(.+?)\s*\])?$/;
        var regType = /^\s*\(*\s*type\s*:\s*(.+?)\s*\)*\s*$/;
        var regBgUrlEscape = /\(|\)|'/;
        var allowedBackgroundSize = { contain: 1, cover: 1 };
        var proxyWidth = function (elem) {
          var width = lazySizes.gW(elem, elem.parentNode);

          if (!elem._lazysizesWidth || width > elem._lazysizesWidth) {
            elem._lazysizesWidth = width;
          }
          return elem._lazysizesWidth;
        };
        var getBgSize = function (elem) {
          var bgSize;

          bgSize = (getComputedStyle(elem) || { getPropertyValue: function () {} }).getPropertyValue("background-size");

          if (!allowedBackgroundSize[bgSize] && allowedBackgroundSize[elem.style.backgroundSize]) {
            bgSize = elem.style.backgroundSize;
          }

          return bgSize;
        };
        var setTypeOrMedia = function (source, match) {
          if (match) {
            var typeMatch = match.match(regType);
            if (typeMatch && typeMatch[1]) {
              source.setAttribute("type", typeMatch[1]);
            } else {
              source.setAttribute("media", lazySizesCfg.customMedia[match] || match);
            }
          }
        };
        var createPicture = function (sets, elem, img) {
          var picture = document.createElement("picture");
          var sizes = elem.getAttribute(lazySizesCfg.sizesAttr);
          var ratio = elem.getAttribute("data-ratio");
          var optimumx = elem.getAttribute("data-optimumx");

          if (elem._lazybgset && elem._lazybgset.parentNode == elem) {
            elem.removeChild(elem._lazybgset);
          }

          Object.defineProperty(img, "_lazybgset", {
            value: elem,
            writable: true,
          });
          Object.defineProperty(elem, "_lazybgset", {
            value: picture,
            writable: true,
          });

          sets = sets.replace(regWhite, " ").split(regSplitSet);

          picture.style.display = "none";
          img.className = lazySizesCfg.lazyClass;

          if (sets.length == 1 && !sizes) {
            sizes = "auto";
          }

          sets.forEach(function (set) {
            var match;
            var source = document.createElement("source");

            if (sizes && sizes != "auto") {
              source.setAttribute("sizes", sizes);
            }

            if ((match = set.match(regSource))) {
              source.setAttribute(lazySizesCfg.srcsetAttr, match[1]);

              setTypeOrMedia(source, match[2]);
              setTypeOrMedia(source, match[3]);
            } else {
              source.setAttribute(lazySizesCfg.srcsetAttr, set);
            }

            picture.appendChild(source);
          });

          if (sizes) {
            img.setAttribute(lazySizesCfg.sizesAttr, sizes);
            elem.removeAttribute(lazySizesCfg.sizesAttr);
            elem.removeAttribute("sizes");
          }
          if (optimumx) {
            img.setAttribute("data-optimumx", optimumx);
          }
          if (ratio) {
            img.setAttribute("data-ratio", ratio);
          }

          picture.appendChild(img);

          elem.appendChild(picture);
        };

        var proxyLoad = function (e) {
          if (!e.target._lazybgset) {
            return;
          }

          var image = e.target;
          var elem = image._lazybgset;
          var bg = image.currentSrc || image.src;

          if (bg) {
            var event = lazySizes.fire(elem, "bgsetproxy", {
              src: bg,
              useSrc: regBgUrlEscape.test(bg) ? JSON.stringify(bg) : bg,
            });

            if (!event.defaultPrevented) {
              elem.style.backgroundImage = "url(" + event.detail.useSrc + ")";
            }
          }

          if (image._lazybgsetLoading) {
            lazySizes.fire(elem, "_lazyloaded", {}, false, true);
            delete image._lazybgsetLoading;
          }
        };

        addEventListener("lazybeforeunveil", function (e) {
          var set, image, elem;

          if (e.defaultPrevented || !(set = e.target.getAttribute("data-bgset"))) {
            return;
          }

          elem = e.target;
          image = document.createElement("img");

          image.alt = "";

          image._lazybgsetLoading = true;
          e.detail.firesLoad = true;

          createPicture(set, elem, image);

          setTimeout(function () {
            lazySizes.loader.unveil(image);

            lazySizes.rAF(function () {
              lazySizes.fire(image, "_lazyloaded", {}, true, true);
              if (image.complete) {
                proxyLoad({ target: image });
              }
            });
          });
        });

        document.addEventListener("load", proxyLoad, true);

        window.addEventListener(
          "lazybeforesizes",
          function (e) {
            if (e.detail.instance != lazySizes) {
              return;
            }
            if (e.target._lazybgset && e.detail.dataAttr) {
              var elem = e.target._lazybgset;
              var bgSize = getBgSize(elem);

              if (allowedBackgroundSize[bgSize]) {
                e.target._lazysizesParentFit = bgSize;

                lazySizes.rAF(function () {
                  e.target.setAttribute("data-parent-fit", bgSize);
                  if (e.target._lazysizesParentFit) {
                    delete e.target._lazysizesParentFit;
                  }
                });
              }
            }
          },
          true
        );

        document.documentElement.addEventListener("lazybeforesizes", function (e) {
          if (e.defaultPrevented || !e.target._lazybgset || e.detail.instance != lazySizes) {
            return;
          }
          e.detail.width = proxyWidth(e.target._lazybgset);
        });
      });

      /***/
    },
    /* 12 */
    /***/ function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
      (function (window, factory) {
        if (!window) {
          return;
        }
        var globalInstall = function () {
          factory(window.lazySizes);
          window.removeEventListener("lazyunveilread", globalInstall, true);
        };

        factory = factory.bind(null, window, window.document);

        if (true && module.exports) {
          factory(__webpack_require__(0));
        } else if (true) {
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(typeof window != "undefined" ? window : 0, function (window, document, lazySizes) {
        /*jshint eqnull:true */
        "use strict";
        var polyfill;
        var lazySizesCfg = lazySizes.cfg;
        var img = document.createElement("img");
        var supportSrcset = "sizes" in img && "srcset" in img;
        var regHDesc = /\s+\d+h/g;
        var fixEdgeHDescriptor = (function () {
          var regDescriptors = /\s+(\d+)(w|h)\s+(\d+)(w|h)/;
          var forEach = Array.prototype.forEach;

          return function () {
            var img = document.createElement("img");
            var removeHDescriptors = function (source) {
              var ratio, match;
              var srcset = source.getAttribute(lazySizesCfg.srcsetAttr);
              if (srcset) {
                if ((match = srcset.match(regDescriptors))) {
                  if (match[2] == "w") {
                    ratio = match[1] / match[3];
                  } else {
                    ratio = match[3] / match[1];
                  }

                  if (ratio) {
                    source.setAttribute("data-aspectratio", ratio);
                  }
                  source.setAttribute(lazySizesCfg.srcsetAttr, srcset.replace(regHDesc, ""));
                }
              }
            };
            var handler = function (e) {
              if (e.detail.instance != lazySizes) {
                return;
              }
              var picture = e.target.parentNode;

              if (picture && picture.nodeName == "PICTURE") {
                forEach.call(picture.getElementsByTagName("source"), removeHDescriptors);
              }
              removeHDescriptors(e.target);
            };

            var test = function () {
              if (!!img.currentSrc) {
                document.removeEventListener("lazybeforeunveil", handler);
              }
            };

            document.addEventListener("lazybeforeunveil", handler);

            img.onload = test;
            img.onerror = test;

            img.srcset = "data:,a 1w 1h";

            if (img.complete) {
              test();
            }
          };
        })();

        if (!lazySizesCfg.supportsType) {
          lazySizesCfg.supportsType = function (type /*, elem*/) {
            return !type;
          };
        }

        if (window.HTMLPictureElement && supportSrcset) {
          if (!lazySizes.hasHDescriptorFix && document.msElementsFromPoint) {
            lazySizes.hasHDescriptorFix = true;
            fixEdgeHDescriptor();
          }
          return;
        }

        if (window.picturefill || lazySizesCfg.pf) {
          return;
        }

        lazySizesCfg.pf = function (options) {
          var i, len;
          if (window.picturefill) {
            return;
          }
          for (i = 0, len = options.elements.length; i < len; i++) {
            polyfill(options.elements[i]);
          }
        };

        // partial polyfill
        polyfill = (function () {
          var ascendingSort = function (a, b) {
            return a.w - b.w;
          };
          var regPxLength = /^\s*\d+\.*\d*px\s*$/;
          var reduceCandidate = function (srces) {
            var lowerCandidate, bonusFactor;
            var len = srces.length;
            var candidate = srces[len - 1];
            var i = 0;

            for (i; i < len; i++) {
              candidate = srces[i];
              candidate.d = candidate.w / srces.w;

              if (candidate.d >= srces.d) {
                if (
                  !candidate.cached &&
                  (lowerCandidate = srces[i - 1]) &&
                  lowerCandidate.d > srces.d - 0.13 * Math.pow(srces.d, 2.2)
                ) {
                  bonusFactor = Math.pow(lowerCandidate.d - 0.6, 1.6);

                  if (lowerCandidate.cached) {
                    lowerCandidate.d += 0.15 * bonusFactor;
                  }

                  if (lowerCandidate.d + (candidate.d - srces.d) * bonusFactor > srces.d) {
                    candidate = lowerCandidate;
                  }
                }
                break;
              }
            }
            return candidate;
          };

          var parseWsrcset = (function () {
            var candidates;
            var regWCandidates = /(([^,\s].[^\s]+)\s+(\d+)w)/g;
            var regMultiple = /\s/;
            var addCandidate = function (match, candidate, url, wDescriptor) {
              candidates.push({
                c: candidate,
                u: url,
                w: wDescriptor * 1,
              });
            };

            return function (input) {
              candidates = [];
              input = input.trim();
              input.replace(regHDesc, "").replace(regWCandidates, addCandidate);

              if (!candidates.length && input && !regMultiple.test(input)) {
                candidates.push({
                  c: input,
                  u: input,
                  w: 99,
                });
              }

              return candidates;
            };
          })();

          var runMatchMedia = function () {
            if (runMatchMedia.init) {
              return;
            }

            runMatchMedia.init = true;
            addEventListener(
              "resize",
              (function () {
                var timer;
                var matchMediaElems = document.getElementsByClassName("lazymatchmedia");
                var run = function () {
                  var i, len;
                  for (i = 0, len = matchMediaElems.length; i < len; i++) {
                    polyfill(matchMediaElems[i]);
                  }
                };

                return function () {
                  clearTimeout(timer);
                  timer = setTimeout(run, 66);
                };
              })()
            );
          };

          var createSrcset = function (elem, isImage) {
            var parsedSet;
            var srcSet = elem.getAttribute("srcset") || elem.getAttribute(lazySizesCfg.srcsetAttr);

            if (!srcSet && isImage) {
              srcSet = !elem._lazypolyfill
                ? elem.getAttribute(lazySizesCfg.srcAttr) || elem.getAttribute("src")
                : elem._lazypolyfill._set;
            }

            if (!elem._lazypolyfill || elem._lazypolyfill._set != srcSet) {
              parsedSet = parseWsrcset(srcSet || "");
              if (isImage && elem.parentNode) {
                parsedSet.isPicture = elem.parentNode.nodeName.toUpperCase() == "PICTURE";

                if (parsedSet.isPicture) {
                  if (window.matchMedia) {
                    lazySizes.aC(elem, "lazymatchmedia");
                    runMatchMedia();
                  }
                }
              }

              parsedSet._set = srcSet;
              Object.defineProperty(elem, "_lazypolyfill", {
                value: parsedSet,
                writable: true,
              });
            }
          };

          var getX = function (elem) {
            var dpr = window.devicePixelRatio || 1;
            var optimum = lazySizes.getX && lazySizes.getX(elem);
            return Math.min(optimum || dpr, 2.5, dpr);
          };

          var matchesMedia = function (media) {
            if (window.matchMedia) {
              matchesMedia = function (media) {
                return !media || (matchMedia(media) || {}).matches;
              };
            } else {
              return !media;
            }

            return matchesMedia(media);
          };

          var getCandidate = function (elem) {
            var sources, i, len, media, source, srces, src, width;

            source = elem;
            createSrcset(source, true);
            srces = source._lazypolyfill;

            if (srces.isPicture) {
              for (
                i = 0, sources = elem.parentNode.getElementsByTagName("source"), len = sources.length;
                i < len;
                i++
              ) {
                if (
                  lazySizesCfg.supportsType(sources[i].getAttribute("type"), elem) &&
                  matchesMedia(sources[i].getAttribute("media"))
                ) {
                  source = sources[i];
                  createSrcset(source);
                  srces = source._lazypolyfill;
                  break;
                }
              }
            }

            if (srces.length > 1) {
              width = source.getAttribute("sizes") || "";
              width = (regPxLength.test(width) && parseInt(width, 10)) || lazySizes.gW(elem, elem.parentNode);
              srces.d = getX(elem);
              if (!srces.src || !srces.w || srces.w < width) {
                srces.w = width;
                src = reduceCandidate(srces.sort(ascendingSort));
                srces.src = src;
              } else {
                src = srces.src;
              }
            } else {
              src = srces[0];
            }

            return src;
          };

          var p = function (elem) {
            if (supportSrcset && elem.parentNode && elem.parentNode.nodeName.toUpperCase() != "PICTURE") {
              return;
            }
            var candidate = getCandidate(elem);

            if (candidate && candidate.u && elem._lazypolyfill.cur != candidate.u) {
              elem._lazypolyfill.cur = candidate.u;
              candidate.cached = true;
              elem.setAttribute(lazySizesCfg.srcAttr, candidate.u);
              elem.setAttribute("src", candidate.u);
            }
          };

          p.parse = parseWsrcset;

          return p;
        })();

        if (lazySizesCfg.loadedClass && lazySizesCfg.loadingClass) {
          (function () {
            var sels = [];
            ['img[sizes$="px"][srcset].', "picture > img:not([srcset])."].forEach(function (sel) {
              sels.push(sel + lazySizesCfg.loadedClass);
              sels.push(sel + lazySizesCfg.loadingClass);
            });
            lazySizesCfg.pf({
              elements: document.querySelectorAll(sels.join(", ")),
            });
          })();
        }
      });

      /***/
    },
    /* 13 */
    /***/ function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
      (function (window, factory) {
        var globalInstall = function () {
          factory(window.lazySizes);
          window.removeEventListener("lazyunveilread", globalInstall, true);
        };

        factory = factory.bind(null, window, window.document);

        if (true && module.exports) {
          factory(__webpack_require__(0));
        } else if (true) {
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(window, function (window, document, lazySizes) {
        /*jshint eqnull:true */
        "use strict";

        var config, riasCfg;
        var lazySizesCfg = lazySizes.cfg;
        var replaceTypes = { string: 1, number: 1 };
        var regNumber = /^\-*\+*\d+\.*\d*$/;
        var regPicture = /^picture$/i;
        var regWidth = /\s*\{\s*width\s*\}\s*/i;
        var regHeight = /\s*\{\s*height\s*\}\s*/i;
        var regPlaceholder = /\s*\{\s*([a-z0-9]+)\s*\}\s*/gi;
        var regObj = /^\[.*\]|\{.*\}$/;
        var regAllowedSizes = /^(?:auto|\d+(px)?)$/;
        var anchor = document.createElement("a");
        var img = document.createElement("img");
        var buggySizes = "srcset" in img && !("sizes" in img);
        var supportPicture = !!window.HTMLPictureElement && !buggySizes;

        (function () {
          var prop;
          var noop = function () {};
          var riasDefaults = {
            prefix: "",
            postfix: "",
            srcAttr: "data-src",
            absUrl: false,
            modifyOptions: noop,
            widthmap: {},
            ratio: false,
            traditionalRatio: false,
            aspectratio: false,
          };

          config = lazySizes && lazySizes.cfg;

          if (!config.supportsType) {
            config.supportsType = function (type /*, elem*/) {
              return !type;
            };
          }

          if (!config.rias) {
            config.rias = {};
          }
          riasCfg = config.rias;

          if (!("widths" in riasCfg)) {
            riasCfg.widths = [];
            (function (widths) {
              var width;
              var i = 0;
              while (!width || width < 3000) {
                i += 5;
                if (i > 30) {
                  i += 1;
                }
                width = 36 * i;
                widths.push(width);
              }
            })(riasCfg.widths);
          }

          for (prop in riasDefaults) {
            if (!(prop in riasCfg)) {
              riasCfg[prop] = riasDefaults[prop];
            }
          }
        })();

        function getElementOptions(elem, src) {
          var attr, parent, setOption, options;
          var elemStyles = window.getComputedStyle(elem);

          parent = elem.parentNode;
          options = {
            isPicture: !!(parent && regPicture.test(parent.nodeName || "")),
          };

          setOption = function (attr, run) {
            var attrVal = elem.getAttribute("data-" + attr);

            if (!attrVal) {
              // no data- attr, get value from the CSS
              var styles = elemStyles.getPropertyValue("--ls-" + attr);
              // at least Safari 9 returns null rather than
              // an empty string for getPropertyValue causing
              // .trim() to fail
              if (styles) {
                attrVal = styles.trim();
              }
            }

            if (attrVal) {
              if (attrVal == "true") {
                attrVal = true;
              } else if (attrVal == "false") {
                attrVal = false;
              } else if (regNumber.test(attrVal)) {
                attrVal = parseFloat(attrVal);
              } else if (typeof riasCfg[attr] == "function") {
                attrVal = riasCfg[attr](elem, attrVal);
              } else if (regObj.test(attrVal)) {
                try {
                  attrVal = JSON.parse(attrVal);
                } catch (e) {}
              }
              options[attr] = attrVal;
            } else if (attr in riasCfg && typeof riasCfg[attr] != "function") {
              options[attr] = riasCfg[attr];
            } else if (run && typeof riasCfg[attr] == "function") {
              options[attr] = riasCfg[attr](elem, attrVal);
            }
          };

          for (attr in riasCfg) {
            setOption(attr);
          }
          src.replace(regPlaceholder, function (full, match) {
            if (!(match in options)) {
              setOption(match, true);
            }
          });

          return options;
        }

        function replaceUrlProps(url, options) {
          var candidates = [];
          var replaceFn = function (full, match) {
            return replaceTypes[typeof options[match]] ? options[match] : full;
          };
          candidates.srcset = [];

          if (options.absUrl) {
            anchor.setAttribute("href", url);
            url = anchor.href;
          }

          url = ((options.prefix || "") + url + (options.postfix || "")).replace(regPlaceholder, replaceFn);

          options.widths.forEach(function (width) {
            var widthAlias = options.widthmap[width] || width;
            var ratio = options.aspectratio || options.ratio;
            var traditionalRatio = !options.aspectratio && riasCfg.traditionalRatio;
            var candidate = {
              u: url
                .replace(regWidth, widthAlias)
                .replace(
                  regHeight,
                  ratio ? (traditionalRatio ? Math.round(width * ratio) : Math.round(width / ratio)) : ""
                ),
              w: width,
            };

            candidates.push(candidate);
            candidates.srcset.push((candidate.c = candidate.u + " " + width + "w"));
          });
          return candidates;
        }

        function setSrc(src, opts, elem) {
          var elemW = 0;
          var elemH = 0;
          var sizeElement = elem;

          if (!src) {
            return;
          }

          if (opts.ratio === "container") {
            // calculate image or parent ratio
            elemW = sizeElement.scrollWidth;
            elemH = sizeElement.scrollHeight;

            while ((!elemW || !elemH) && sizeElement !== document) {
              sizeElement = sizeElement.parentNode;
              elemW = sizeElement.scrollWidth;
              elemH = sizeElement.scrollHeight;
            }
            if (elemW && elemH) {
              opts.ratio = opts.traditionalRatio ? elemH / elemW : elemW / elemH;
            }
          }

          src = replaceUrlProps(src, opts);

          src.isPicture = opts.isPicture;

          if (buggySizes && elem.nodeName.toUpperCase() == "IMG") {
            elem.removeAttribute(config.srcsetAttr);
          } else {
            elem.setAttribute(config.srcsetAttr, src.srcset.join(", "));
          }

          Object.defineProperty(elem, "_lazyrias", {
            value: src,
            writable: true,
          });
        }

        function createAttrObject(elem, src) {
          var opts = getElementOptions(elem, src);

          riasCfg.modifyOptions.call(elem, { target: elem, details: opts, detail: opts });

          lazySizes.fire(elem, "lazyriasmodifyoptions", opts);
          return opts;
        }

        function getSrc(elem) {
          return (
            elem.getAttribute(elem.getAttribute("data-srcattr") || riasCfg.srcAttr) ||
            elem.getAttribute(config.srcsetAttr) ||
            elem.getAttribute(config.srcAttr) ||
            elem.getAttribute("data-pfsrcset") ||
            ""
          );
        }

        addEventListener(
          "lazybeforesizes",
          function (e) {
            if (e.detail.instance != lazySizes) {
              return;
            }

            var elem,
              src,
              elemOpts,
              parent,
              sources,
              i,
              len,
              sourceSrc,
              sizes,
              detail,
              hasPlaceholder,
              modified,
              emptyList;
            elem = e.target;

            if (
              !e.detail.dataAttr ||
              e.defaultPrevented ||
              riasCfg.disabled ||
              !(
                (sizes = elem.getAttribute(config.sizesAttr) || elem.getAttribute("sizes")) &&
                regAllowedSizes.test(sizes)
              )
            ) {
              return;
            }

            src = getSrc(elem);

            elemOpts = createAttrObject(elem, src);

            hasPlaceholder = regWidth.test(elemOpts.prefix) || regWidth.test(elemOpts.postfix);

            if (elemOpts.isPicture && (parent = elem.parentNode)) {
              sources = parent.getElementsByTagName("source");
              for (i = 0, len = sources.length; i < len; i++) {
                if (hasPlaceholder || regWidth.test((sourceSrc = getSrc(sources[i])))) {
                  setSrc(sourceSrc, elemOpts, sources[i]);
                  modified = true;
                }
              }
            }

            if (hasPlaceholder || regWidth.test(src)) {
              setSrc(src, elemOpts, elem);
              modified = true;
            } else if (modified) {
              emptyList = [];
              emptyList.srcset = [];
              emptyList.isPicture = true;
              Object.defineProperty(elem, "_lazyrias", {
                value: emptyList,
                writable: true,
              });
            }

            if (modified) {
              if (supportPicture) {
                elem.removeAttribute(config.srcAttr);
              } else if (sizes != "auto") {
                detail = {
                  width: parseInt(sizes, 10),
                };
                polyfill({
                  target: elem,
                  detail: detail,
                });
              }
            }
          },
          true
        );
        // partial polyfill
        var polyfill = (function () {
          var ascendingSort = function (a, b) {
            return a.w - b.w;
          };

          var reduceCandidate = function (srces) {
            var lowerCandidate, bonusFactor;
            var len = srces.length;
            var candidate = srces[len - 1];
            var i = 0;

            for (i; i < len; i++) {
              candidate = srces[i];
              candidate.d = candidate.w / srces.w;
              if (candidate.d >= srces.d) {
                if (
                  !candidate.cached &&
                  (lowerCandidate = srces[i - 1]) &&
                  lowerCandidate.d > srces.d - 0.13 * Math.pow(srces.d, 2.2)
                ) {
                  bonusFactor = Math.pow(lowerCandidate.d - 0.6, 1.6);

                  if (lowerCandidate.cached) {
                    lowerCandidate.d += 0.15 * bonusFactor;
                  }

                  if (lowerCandidate.d + (candidate.d - srces.d) * bonusFactor > srces.d) {
                    candidate = lowerCandidate;
                  }
                }
                break;
              }
            }
            return candidate;
          };

          var getWSet = function (elem, testPicture) {
            var src;
            if (
              !elem._lazyrias &&
              lazySizes.pWS &&
              (src = lazySizes.pWS(elem.getAttribute(config.srcsetAttr || ""))).length
            ) {
              Object.defineProperty(elem, "_lazyrias", {
                value: src,
                writable: true,
              });
              if (testPicture && elem.parentNode) {
                src.isPicture = elem.parentNode.nodeName.toUpperCase() == "PICTURE";
              }
            }
            return elem._lazyrias;
          };

          var getX = function (elem) {
            var dpr = window.devicePixelRatio || 1;
            var optimum = lazySizes.getX && lazySizes.getX(elem);
            return Math.min(optimum || dpr, 2.4, dpr);
          };

          var getCandidate = function (elem, width) {
            var sources, i, len, media, srces, src;

            srces = elem._lazyrias;

            if (srces.isPicture && window.matchMedia) {
              for (
                i = 0, sources = elem.parentNode.getElementsByTagName("source"), len = sources.length;
                i < len;
                i++
              ) {
                if (
                  getWSet(sources[i]) &&
                  !sources[i].getAttribute("type") &&
                  (!(media = sources[i].getAttribute("media")) || (matchMedia(media) || {}).matches)
                ) {
                  srces = sources[i]._lazyrias;
                  break;
                }
              }
            }

            if (!srces.w || srces.w < width) {
              srces.w = width;
              srces.d = getX(elem);
              src = reduceCandidate(srces.sort(ascendingSort));
            }

            return src;
          };

          var polyfill = function (e) {
            if (e.detail.instance != lazySizes) {
              return;
            }

            var candidate;
            var elem = e.target;

            if (!buggySizes && (window.respimage || window.picturefill || lazySizesCfg.pf)) {
              document.removeEventListener("lazybeforesizes", polyfill);
              return;
            }

            if (!("_lazyrias" in elem) && (!e.detail.dataAttr || !getWSet(elem, true))) {
              return;
            }

            candidate = getCandidate(elem, e.detail.width);

            if (candidate && candidate.u && elem._lazyrias.cur != candidate.u) {
              elem._lazyrias.cur = candidate.u;
              candidate.cached = true;
              lazySizes.rAF(function () {
                elem.setAttribute(config.srcAttr, candidate.u);
                elem.setAttribute("src", candidate.u);
              });
            }
          };

          if (!supportPicture) {
            addEventListener("lazybeforesizes", polyfill);
          } else {
            polyfill = function () {};
          }

          return polyfill;
        })();
      });

      /***/
    },
    /* 14 */
    /***/ function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
      (function (window, factory) {
        if (!window) {
          return;
        }
        var globalInstall = function () {
          factory(window.lazySizes);
          window.removeEventListener("lazyunveilread", globalInstall, true);
        };

        factory = factory.bind(null, window, window.document);

        if (true && module.exports) {
          factory(__webpack_require__(0));
        } else if (true) {
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(typeof window != "undefined" ? window : 0, function (window, document, lazySizes) {
        /*jshint eqnull:true */
        "use strict";
        if (!document.getElementsByClassName) {
          return;
        }
        var protocol = location.protocol == "https:" ? "https:" : "http:";
        var idIndex = Date.now();
        var regId = /\{\{id}}/;
        var regYtImg = /\{\{hqdefault}}/;
        var regAmp = /^&/;
        var regValidParam = /^[a-z0-9-_&=]+$/i;
        var youtubeImg = protocol + "//img.youtube.com/vi/{{id}}/{{hqdefault}}.jpg";
        var youtubeIframe = protocol + "//www.youtube.com/embed/{{id}}?autoplay=1";
        var vimeoApi = protocol + "//vimeo.com/api/oembed.json?url=https%3A//vimeo.com/{{id}}";
        var vimeoIframe = protocol + "//player.vimeo.com/video/{{id}}?autoplay=1";

        function getJSON(url, callback) {
          var id = "vimeoCallback" + idIndex;
          var script = document.createElement("script");
          url += "&callback=" + id;

          idIndex++;

          window[id] = function (data) {
            script.parentNode.removeChild(script);
            delete window[id];
            callback(data);
          };

          script.src = url;

          document.head.appendChild(script);
        }

        function embedVimeoImg(id, elem) {
          getJSON(vimeoApi.replace(regId, id), function (data) {
            if (data && data.thumbnail_url) {
              elem.style.backgroundImage = "url(" + data.thumbnail_url + ")";
            }
          });
          elem.addEventListener("click", embedVimeoIframe);
        }

        function embedVimeoIframe(e) {
          var elem = e.currentTarget;
          var id = elem.getAttribute("data-vimeo");
          var vimeoParams = elem.getAttribute("data-vimeoparams") || "";

          elem.removeEventListener("click", embedVimeoIframe);

          if (!id || !regValidParam.test(id) || (vimeoParams && !regValidParam.test(vimeoParams))) {
            return;
          }

          if (vimeoParams && !regAmp.test(vimeoParams)) {
            vimeoParams = "&" + vimeoParams;
          }

          e.preventDefault();

          elem.innerHTML =
            '<iframe src="' +
            vimeoIframe.replace(regId, id) +
            vimeoParams +
            '" ' +
            'frameborder="0" allowfullscreen="" width="640" height="390"></iframe>';
        }

        function embedYoutubeImg(id, elem) {
          var ytImg = elem.getAttribute("data-thumb-size") || lazySizes.cfg.ytThumb || "hqdefault";

          elem.style.backgroundImage = "url(" + youtubeImg.replace(regId, id).replace(regYtImg, ytImg) + ")";
          elem.addEventListener("click", embedYoutubeIframe);
        }

        function embedYoutubeIframe(e) {
          var elem = e.currentTarget;
          var id = elem.getAttribute("data-youtube");
          var youtubeParams = elem.getAttribute("data-ytparams") || "";

          elem.removeEventListener("click", embedYoutubeIframe);

          if (!id || !regValidParam.test(id) || (youtubeParams && !regValidParam.test(youtubeParams))) {
            return;
          }

          if (youtubeParams && !regAmp.test(youtubeParams)) {
            youtubeParams = "&" + youtubeParams;
          }

          e.preventDefault();

          elem.innerHTML =
            '<iframe src="' +
            youtubeIframe.replace(regId, id) +
            youtubeParams +
            '" ' +
            'frameborder="0" allowfullscreen="" width="640" height="390"></iframe>';
        }

        document.addEventListener("lazybeforeunveil", function (e) {
          if (e.detail.instance != lazySizes) {
            return;
          }

          var elem = e.target;
          var youtube = elem.getAttribute("data-youtube");
          var vimeo = elem.getAttribute("data-vimeo");

          if (youtube && elem) {
            embedYoutubeImg(youtube, elem);
          }
          if (vimeo && elem) {
            embedVimeoImg(vimeo, elem);
          }
        });
      });

      /***/
    },
    /* 15 */
    /***/ function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
      (function (window, factory) {
        if (!window) {
          return;
        }
        var globalInstall = function () {
          factory(window.lazySizes);
          window.removeEventListener("lazyunveilread", globalInstall, true);
        };

        factory = factory.bind(null, window, window.document);

        if (true && module.exports) {
          factory(__webpack_require__(0));
        } else if (true) {
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(typeof window != "undefined" ? window : 0, function (window, document, lazySizes) {
        /*jshint eqnull:true */
        "use strict";
        if (!window.addEventListener) {
          return;
        }

        var config;

        var regPicture = /^picture$/i;
        var docElem = document.documentElement;

        var parseWsrcset = (function () {
          var candidates;
          var reg = /(([^,\s].[^\s]+)\s+(\d+)(w|h)(\s+(\d+)(w|h))?)/g;
          var addCandidate = function (
            match,
            candidate,
            url,
            descNumber1,
            descType1,
            fullDesc,
            descNumber2,
            descType2
          ) {
            candidates.push({
              c: candidate,
              u: url,
              w: (descType2 == "w" ? descNumber2 : descNumber1) * 1,
            });
          };

          return function (input) {
            candidates = [];
            input.replace(reg, addCandidate);
            return candidates;
          };
        })();

        var parseImg = (function () {
          var ascendingSort = function (a, b) {
            return a.w - b.w;
          };

          var parseSets = function (elem, dataName) {
            var lazyData = { srcset: elem.getAttribute(lazySizes.cfg.srcsetAttr) || "" };
            var cands = parseWsrcset(lazyData.srcset);
            Object.defineProperty(elem, dataName, {
              value: lazyData,
              writable: true,
            });

            lazyData.cands = cands;

            lazyData.index = 0;
            lazyData.dirty = false;
            if (cands[0] && cands[0].w) {
              cands.sort(ascendingSort);
              lazyData.cSrcset = [cands[lazyData.index].c];
            } else {
              lazyData.cSrcset = lazyData.srcset ? [lazyData.srcset] : [];
              lazyData.cands = [];
            }

            return lazyData;
          };

          return function parseImg(elem, dataName) {
            var sources, i, len, parent;

            if (!elem[dataName]) {
              parent = elem.parentNode || {};
              elem[dataName] = parseSets(elem, dataName);
              elem[dataName].isImg = true;
              if (regPicture.test(parent.nodeName || "")) {
                elem[dataName].picture = true;
                sources = parent.getElementsByTagName("source");
                for (i = 0, len = sources.length; i < len; i++) {
                  parseSets(sources[i], dataName).isImg = false;
                }
              }
            }

            return elem[dataName];
          };
        })();

        var constraintFns = {
          _lazyOptimumx: (function () {
            var takeHighRes = function (lowerCandidate, higherCandidateResolution, optimumx) {
              var low, bonusFactor, substract;
              if (!lowerCandidate || !lowerCandidate.d) {
                return true;
              }

              substract = optimumx > 0.7 ? 0.6 : 0.4;

              if (lowerCandidate.d >= optimumx) {
                return false;
              }

              bonusFactor = Math.pow(lowerCandidate.d - substract, 1.6) || 0.1;

              if (bonusFactor < 0.1) {
                bonusFactor = 0.1;
              } else if (bonusFactor > 3) {
                bonusFactor = 3;
              }

              low = lowerCandidate.d + (higherCandidateResolution - optimumx) * bonusFactor;

              return low < optimumx;
            };

            return function (data, width, optimumx) {
              var i, can;

              for (i = 0; i < data.cands.length; i++) {
                can = data.cands[i];
                can.d = (can.w || 1) / width;

                if (data.index >= i) {
                  continue;
                }

                if (can.d <= optimumx || takeHighRes(data.cands[i - 1], can.d, optimumx)) {
                  data.cSrcset.push(can.c);
                  data.index = i;
                } else {
                  break;
                }
              }
            };
          })(),
        };

        var constrainSets = (function () {
          var constrainSet = function (elem, displayWidth, optimumx, attr, dataName) {
            var curIndex;
            var lazyData = elem[dataName];

            if (!lazyData) {
              return;
            }
            curIndex = lazyData.index;

            constraintFns[dataName](lazyData, displayWidth, optimumx);

            if (!lazyData.dirty || curIndex != lazyData.index) {
              lazyData.cSrcset.join(", ");
              elem.setAttribute(attr, lazyData.cSrcset.join(", "));
              lazyData.dirty = true;
            }
          };

          return function (image, displayWidth, optimumx, attr, dataName) {
            var sources, parent, len, i;
            var lazyData = image[dataName];

            lazyData.width = displayWidth;

            if (lazyData.picture && (parent = image.parentNode)) {
              sources = parent.getElementsByTagName("source");
              for (i = 0, len = sources.length; i < len; i++) {
                constrainSet(sources[i], displayWidth, optimumx, attr, dataName);
              }
            }

            constrainSet(image, displayWidth, optimumx, attr, dataName);
          };
        })();

        var getOptimumX = function (element) {
          var optimumx = element.getAttribute("data-optimumx") || element.getAttribute("data-maxdpr");

          if (!optimumx && config.constrainPixelDensity) {
            optimumx = "auto";
          }

          if (optimumx) {
            if (optimumx == "auto") {
              optimumx = config.getOptimumX(element);
            } else {
              optimumx = parseFloat(optimumx, 10);
            }
          }
          return optimumx;
        };

        var extentLazySizes = function () {
          if (lazySizes && !lazySizes.getOptimumX) {
            lazySizes.getX = getOptimumX;
            lazySizes.pWS = parseWsrcset;
            docElem.removeEventListener("lazybeforeunveil", extentLazySizes);
          }
        };

        docElem.addEventListener("lazybeforeunveil", extentLazySizes);
        setTimeout(extentLazySizes);

        config = lazySizes && lazySizes.cfg;

        if (typeof config.getOptimumX != "function") {
          config.getOptimumX = function (/*element*/) {
            var dpr = window.devicePixelRatio || 1;
            if (dpr > 2.6) {
              dpr *= 0.6; // returns 1.8 for 3
            } else if (dpr > 1.9) {
              dpr *= 0.8; // returns 1.6 for 2
            } else {
              dpr -= 0.01; // returns 0.99 for 1
            }
            return Math.min(Math.round(dpr * 100) / 100, 2);
          };
        }

        if (!window.devicePixelRatio) {
          return;
        }

        addEventListener("lazybeforesizes", function (e) {
          if (e.detail.instance != lazySizes) {
            return;
          }

          var optimumx, lazyData, width, attr;

          var elem = e.target;
          var detail = e.detail;
          var dataAttr = detail.dataAttr;

          if (e.defaultPrevented || !(optimumx = getOptimumX(elem)) || optimumx >= devicePixelRatio) {
            return;
          }

          if (
            dataAttr &&
            elem._lazyOptimumx &&
            !detail.reloaded &&
            (!config.unloadedClass || !lazySizes.hC(elem, config.unloadedClass))
          ) {
            elem._lazyOptimumx = null;
          }

          lazyData = parseImg(elem, "_lazyOptimumx");

          width = detail.width;

          if (width && (lazyData.width || 0) < width) {
            attr = dataAttr ? lazySizes.cfg.srcsetAttr : "srcset";

            lazySizes.rAF(function () {
              constrainSets(elem, width, optimumx, attr, "_lazyOptimumx");
            });
          }
        });
      });

      /***/
    },
    /* 16 */
    /***/ function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      // ESM COMPAT FLAG
      __webpack_require__.r(__webpack_exports__);

      // CONCATENATED MODULE: ./node_modules/@shopify/theme-sections/section.js
      var SECTION_ID_ATTR = "data-section-id";

      function Section(container, properties) {
        this.container = validateContainerElement(container);
        this.id = container.getAttribute(SECTION_ID_ATTR);
        this.extensions = [];

        // eslint-disable-next-line es5/no-es6-static-methods
        Object.assign(this, validatePropertiesObject(properties));

        this.onLoad();
      }

      Section.prototype = {
        onLoad: Function.prototype,
        onUnload: Function.prototype,
        onSelect: Function.prototype,
        onDeselect: Function.prototype,
        onBlockSelect: Function.prototype,
        onBlockDeselect: Function.prototype,

        extend: function extend(extension) {
          this.extensions.push(extension); // Save original extension

          // eslint-disable-next-line es5/no-es6-static-methods
          var extensionClone = Object.assign({}, extension);
          delete extensionClone.init; // Remove init function before assigning extension properties

          // eslint-disable-next-line es5/no-es6-static-methods
          Object.assign(this, extensionClone);

          if (typeof extension.init === "function") {
            extension.init.apply(this);
          }
        },
      };

      function validateContainerElement(container) {
        if (!(container instanceof Element)) {
          throw new TypeError(
            "Theme Sections: Attempted to load section. The section container provided is not a DOM element."
          );
        }
        if (container.getAttribute(SECTION_ID_ATTR) === null) {
          throw new Error(
            "Theme Sections: The section container provided does not have an id assigned to the " +
              SECTION_ID_ATTR +
              " attribute."
          );
        }

        return container;
      }

      function validatePropertiesObject(value) {
        if ((typeof value !== "undefined" && typeof value !== "object") || value === null) {
          throw new TypeError("Theme Sections: The properties object provided is not a valid");
        }

        return value;
      }

      // Object.assign() polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
      if (typeof Object.assign != "function") {
        // Must be writable: true, enumerable: false, configurable: true
        Object.defineProperty(Object, "assign", {
          value: function assign(target) {
            // .length of function is 2
            "use strict";
            if (target == null) {
              // TypeError if undefined or null
              throw new TypeError("Cannot convert undefined or null to object");
            }

            var to = Object(target);

            for (var index = 1; index < arguments.length; index++) {
              var nextSource = arguments[index];

              if (nextSource != null) {
                // Skip over if undefined or null
                for (var nextKey in nextSource) {
                  // Avoid bugs when hasOwnProperty is shadowed
                  if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                    to[nextKey] = nextSource[nextKey];
                  }
                }
              }
            }
            return to;
          },
          writable: true,
          configurable: true,
        });
      }

      // CONCATENATED MODULE: ./node_modules/@shopify/theme-sections/theme-sections.js
      /*
       * @shopify/theme-sections
       * -----------------------------------------------------------------------------
       *
       * A framework to provide structure to your Shopify sections and a load and unload
       * lifecycle. The lifecycle is automatically connected to theme editor events so
       * that your sections load and unload as the editor changes the content and
       * settings of your sections.
       */

      var SECTION_TYPE_ATTR = "data-section-type";
      var theme_sections_SECTION_ID_ATTR = "data-section-id";

      window.Shopify = window.Shopify || {};
      window.Shopify.theme = window.Shopify.theme || {};
      window.Shopify.theme.sections = window.Shopify.theme.sections || {};

      var registered = (window.Shopify.theme.sections.registered = window.Shopify.theme.sections.registered || {});
      var instances = (window.Shopify.theme.sections.instances = window.Shopify.theme.sections.instances || []);

      function register(type, properties) {
        if (typeof type !== "string") {
          throw new TypeError(
            "Theme Sections: The first argument for .register must be a string that specifies the type of the section being registered"
          );
        }

        if (typeof registered[type] !== "undefined") {
          throw new Error(
            'Theme Sections: A section of type "' +
              type +
              '" has already been registered. You cannot register the same section type twice'
          );
        }

        function TypedSection(container) {
          Section.call(this, container, properties);
        }

        TypedSection.constructor = Section;
        TypedSection.prototype = Object.create(Section.prototype);
        TypedSection.prototype.type = type;

        return (registered[type] = TypedSection);
      }

      function unregister(types) {
        types = normalizeType(types);

        types.forEach(function (type) {
          delete registered[type];
        });
      }

      function load(types, containers) {
        types = normalizeType(types);

        if (typeof containers === "undefined") {
          containers = document.querySelectorAll("[" + SECTION_TYPE_ATTR + "]");
        }

        containers = normalizeContainers(containers);

        types.forEach(function (type) {
          var TypedSection = registered[type];

          if (typeof TypedSection === "undefined") {
            return;
          }

          containers = containers.filter(function (container) {
            // Filter from list of containers because container already has an instance loaded
            if (isInstance(container)) {
              return false;
            }

            // Filter from list of containers because container doesn't have data-section-type attribute
            if (container.getAttribute(SECTION_TYPE_ATTR) === null) {
              return false;
            }

            // Keep in list of containers because current type doesn't match
            if (container.getAttribute(SECTION_TYPE_ATTR) !== type) {
              return true;
            }

            instances.push(new TypedSection(container));

            // Filter from list of containers because container now has an instance loaded
            return false;
          });
        });
      }

      function unload(selector) {
        var instancesToUnload = getInstances(selector);

        instancesToUnload.forEach(function (instance) {
          var index = instances
            .map(function (e) {
              return e.id;
            })
            .indexOf(instance.id);
          instances.splice(index, 1);
          instance.onUnload();
        });
      }

      function extend(selector, extension) {
        var instancesToExtend = getInstances(selector);

        instancesToExtend.forEach(function (instance) {
          instance.extend(extension);
        });
      }

      function getInstances(selector) {
        var filteredInstances = [];

        // Fetch first element if its an array
        if (NodeList.prototype.isPrototypeOf(selector) || Array.isArray(selector)) {
          var firstElement = selector[0];
        }

        // If selector element is DOM element
        if (selector instanceof Element || firstElement instanceof Element) {
          var containers = normalizeContainers(selector);

          containers.forEach(function (container) {
            filteredInstances = filteredInstances.concat(
              instances.filter(function (instance) {
                return instance.container === container;
              })
            );
          });

          // If select is type string
        } else if (typeof selector === "string" || typeof firstElement === "string") {
          var types = normalizeType(selector);

          types.forEach(function (type) {
            filteredInstances = filteredInstances.concat(
              instances.filter(function (instance) {
                return instance.type === type;
              })
            );
          });
        }

        return filteredInstances;
      }

      function getInstanceById(id) {
        var instance;

        for (var i = 0; i < instances.length; i++) {
          if (instances[i].id === id) {
            instance = instances[i];
            break;
          }
        }
        return instance;
      }

      function isInstance(selector) {
        return getInstances(selector).length > 0;
      }

      function normalizeType(types) {
        // If '*' then fetch all registered section types
        if (types === "*") {
          types = Object.keys(registered);

          // If a single section type string is passed, put it in an array
        } else if (typeof types === "string") {
          types = [types];

          // If single section constructor is passed, transform to array with section
          // type string
        } else if (types.constructor === Section) {
          types = [types.prototype.type];

          // If array of typed section constructors is passed, transform the array to
          // type strings
        } else if (Array.isArray(types) && types[0].constructor === Section) {
          types = types.map(function (TypedSection) {
            return TypedSection.prototype.type;
          });
        }

        types = types.map(function (type) {
          return type.toLowerCase();
        });

        return types;
      }

      function normalizeContainers(containers) {
        // Nodelist with entries
        if (NodeList.prototype.isPrototypeOf(containers) && containers.length > 0) {
          containers = Array.prototype.slice.call(containers);

          // Empty Nodelist
        } else if (NodeList.prototype.isPrototypeOf(containers) && containers.length === 0) {
          containers = [];

          // Handle null (document.querySelector() returns null with no match)
        } else if (containers === null) {
          containers = [];

          // Single DOM element
        } else if (!Array.isArray(containers) && containers instanceof Element) {
          containers = [containers];
        }

        return containers;
      }

      if (window.Shopify.designMode) {
        document.addEventListener("shopify:section:load", function (event) {
          var id = event.detail.sectionId;
          var container = event.target.querySelector("[" + theme_sections_SECTION_ID_ATTR + '="' + id + '"]');

          if (container !== null) {
            load(container.getAttribute(SECTION_TYPE_ATTR), container);
          }
        });

        document.addEventListener("shopify:section:unload", function (event) {
          var id = event.detail.sectionId;
          var container = event.target.querySelector("[" + theme_sections_SECTION_ID_ATTR + '="' + id + '"]');
          var instance = getInstances(container)[0];

          if (typeof instance === "object") {
            unload(container);
          }
        });

        document.addEventListener("shopify:section:select", function (event) {
          var instance = getInstanceById(event.detail.sectionId);

          if (typeof instance === "object") {
            instance.onSelect(event);
          }
        });

        document.addEventListener("shopify:section:deselect", function (event) {
          var instance = getInstanceById(event.detail.sectionId);

          if (typeof instance === "object") {
            instance.onDeselect(event);
          }
        });

        document.addEventListener("shopify:block:select", function (event) {
          var instance = getInstanceById(event.detail.sectionId);

          if (typeof instance === "object") {
            instance.onBlockSelect(event);
          }
        });

        document.addEventListener("shopify:block:deselect", function (event) {
          var instance = getInstanceById(event.detail.sectionId);

          if (typeof instance === "object") {
            instance.onBlockDeselect(event);
          }
        });
      }

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
      var regenerator = __webpack_require__(3);
      var regenerator_default = /*#__PURE__*/ __webpack_require__.n(regenerator);

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
      var asyncToGenerator = __webpack_require__(5);
      var asyncToGenerator_default = /*#__PURE__*/ __webpack_require__.n(asyncToGenerator);

      // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
      var defineProperty = __webpack_require__(2);
      var defineProperty_default = /*#__PURE__*/ __webpack_require__.n(defineProperty);

      // EXTERNAL MODULE: ./node_modules/lazysizes/plugins/unveilhooks/ls.unveilhooks.js
      var ls_unveilhooks = __webpack_require__(8);

      // EXTERNAL MODULE: ./node_modules/lazysizes/plugins/parent-fit/ls.parent-fit.js
      var ls_parent_fit = __webpack_require__(9);

      // EXTERNAL MODULE: ./node_modules/lazysizes/plugins/object-fit/ls.object-fit.js
      var ls_object_fit = __webpack_require__(10);

      // EXTERNAL MODULE: ./node_modules/lazysizes/plugins/bgset/ls.bgset.js
      var ls_bgset = __webpack_require__(11);

      // EXTERNAL MODULE: ./node_modules/lazysizes/lazysizes.js
      var lazysizes = __webpack_require__(0);

      // EXTERNAL MODULE: ./node_modules/lazysizes/plugins/respimg/ls.respimg.js
      var ls_respimg = __webpack_require__(12);

      // EXTERNAL MODULE: ./node_modules/lazysizes/plugins/rias/ls.rias.js
      var ls_rias = __webpack_require__(13);

      // EXTERNAL MODULE: ./node_modules/lazysizes/plugins/video-embed/ls.video-embed.js
      var ls_video_embed = __webpack_require__(14);

      // EXTERNAL MODULE: ./node_modules/lazysizes/plugins/optimumx/ls.optimumx.js
      var ls_optimumx = __webpack_require__(15);

      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/raf.js
      var raf_win = window;

      var raf =
        raf_win.requestAnimationFrame ||
        raf_win.webkitRequestAnimationFrame ||
        raf_win.mozRequestAnimationFrame ||
        raf_win.msRequestAnimationFrame ||
        function (cb) {
          return setTimeout(cb, 16);
        };

      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/caf.js
      var caf_win = window;

      var caf =
        caf_win.cancelAnimationFrame ||
        caf_win.mozCancelAnimationFrame ||
        function (id) {
          clearTimeout(id);
        };

      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/extend.js
      function extend_extend() {
        var obj,
          name,
          copy,
          target = arguments[0] || {},
          i = 1,
          length = arguments.length;

        for (; i < length; i++) {
          if ((obj = arguments[i]) !== null) {
            for (name in obj) {
              copy = obj[name];

              if (target === copy) {
                continue;
              } else if (copy !== undefined) {
                target[name] = copy;
              }
            }
          }
        }
        return target;
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/checkStorageValue.js
      function checkStorageValue(value) {
        return ["true", "false"].indexOf(value) >= 0 ? JSON.parse(value) : value;
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/setLocalStorage.js
      function setLocalStorage(storage, key, value, access) {
        if (access) {
          try {
            storage.setItem(key, value);
          } catch (e) {}
        }
        return value;
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/getSlideId.js
      function getSlideId() {
        var id = window.tnsId;
        window.tnsId = !id ? 1 : id + 1;

        return "tns" + window.tnsId;
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/getBody.js
      function getBody() {
        var doc = document,
          body = doc.body;

        if (!body) {
          body = doc.createElement("body");
          body.fake = true;
        }

        return body;
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/docElement.js
      var docElement = document.documentElement;
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/setFakeBody.js

      function setFakeBody(body) {
        var docOverflow = "";
        if (body.fake) {
          docOverflow = docElement.style.overflow;
          //avoid crashing IE8, if background image is used
          body.style.background = "";
          //Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible
          body.style.overflow = docElement.style.overflow = "hidden";
          docElement.appendChild(body);
        }

        return docOverflow;
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/resetFakeBody.js

      function resetFakeBody(body, docOverflow) {
        if (body.fake) {
          body.remove();
          docElement.style.overflow = docOverflow;
          // Trigger layout so kinetic scrolling isn't disabled in iOS6+
          // eslint-disable-next-line
          docElement.offsetHeight;
        }
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/calc.js
      // get css-calc
      // @return - false | calc | -webkit-calc | -moz-calc
      // @usage - var calc = getCalc();

      function calc() {
        var doc = document,
          body = getBody(),
          docOverflow = setFakeBody(body),
          div = doc.createElement("div"),
          result = false;

        body.appendChild(div);
        try {
          var str = "(10px * 10)",
            vals = ["calc" + str, "-moz-calc" + str, "-webkit-calc" + str],
            val;
          for (var i = 0; i < 3; i++) {
            val = vals[i];
            div.style.width = val;
            if (div.offsetWidth === 100) {
              result = val.replace(str, "");
              break;
            }
          }
        } catch (e) {}

        body.fake ? resetFakeBody(body, docOverflow) : div.remove();

        return result;
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/percentageLayout.js
      // get subpixel support value
      // @return - boolean

      function percentageLayout() {
        // check subpixel layout supporting
        var doc = document,
          body = getBody(),
          docOverflow = setFakeBody(body),
          wrapper = doc.createElement("div"),
          outer = doc.createElement("div"),
          str = "",
          count = 70,
          perPage = 3,
          supported = false;

        wrapper.className = "tns-t-subp2";
        outer.className = "tns-t-ct";

        for (var i = 0; i < count; i++) {
          str += "<div></div>";
        }

        outer.innerHTML = str;
        wrapper.appendChild(outer);
        body.appendChild(wrapper);

        supported =
          Math.abs(
            wrapper.getBoundingClientRect().left - outer.children[count - perPage].getBoundingClientRect().left
          ) < 2;

        body.fake ? resetFakeBody(body, docOverflow) : wrapper.remove();

        return supported;
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/mediaquerySupport.js

      function mediaquerySupport() {
        if (window.matchMedia || window.msMatchMedia) {
          return true;
        }

        var doc = document,
          body = getBody(),
          docOverflow = setFakeBody(body),
          div = doc.createElement("div"),
          style = doc.createElement("style"),
          rule = "@media all and (min-width:1px){.tns-mq-test{position:absolute}}",
          position;

        style.type = "text/css";
        div.className = "tns-mq-test";

        body.appendChild(style);
        body.appendChild(div);

        if (style.styleSheet) {
          style.styleSheet.cssText = rule;
        } else {
          style.appendChild(doc.createTextNode(rule));
        }

        position = window.getComputedStyle ? window.getComputedStyle(div).position : div.currentStyle["position"];

        body.fake ? resetFakeBody(body, docOverflow) : div.remove();

        return position === "absolute";
      }

      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/createStyleSheet.js
      // create and append style sheet
      function createStyleSheet(media, nonce) {
        // Create the <style> tag
        var style = document.createElement("style");
        // style.setAttribute("type", "text/css");

        // Add a media (and/or media query) here if you'd like!
        // style.setAttribute("media", "screen")
        // style.setAttribute("media", "only screen and (max-width : 1024px)")
        if (media) {
          style.setAttribute("media", media);
        }

        // Add nonce attribute for Content Security Policy
        if (nonce) {
          style.setAttribute("nonce", nonce);
        }

        // WebKit hack :(
        // style.appendChild(document.createTextNode(""));

        // Add the <style> element to the page
        document.querySelector("head").appendChild(style);

        return style.sheet ? style.sheet : style.styleSheet;
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/addCSSRule.js
      // cross browsers addRule method

      function addCSSRule(sheet, selector, rules, index) {
        // return raf(function() {
        "insertRule" in sheet
          ? sheet.insertRule(selector + "{" + rules + "}", index)
          : sheet.addRule(selector, rules, index);
        // });
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/removeCSSRule.js
      // cross browsers addRule method

      function removeCSSRule(sheet, index) {
        // return raf(function() {
        "deleteRule" in sheet ? sheet.deleteRule(index) : sheet.removeRule(index);
        // });
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/getCssRulesLength.js
      function getCssRulesLength(sheet) {
        var rule = "insertRule" in sheet ? sheet.cssRules : sheet.rules;
        return rule.length;
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/toDegree.js
      function toDegree(y, x) {
        return Math.atan2(y, x) * (180 / Math.PI);
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/getTouchDirection.js
      function getTouchDirection(angle, range) {
        var direction = false,
          gap = Math.abs(90 - Math.abs(angle));

        if (gap >= 90 - range) {
          direction = "horizontal";
        } else if (gap <= range) {
          direction = "vertical";
        }

        return direction;
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/forEach.js
      // https://toddmotto.com/ditch-the-array-foreach-call-nodelist-hack/
      function forEach(arr, callback, scope) {
        for (var i = 0, l = arr.length; i < l; i++) {
          callback.call(scope, arr[i], i);
        }
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/classListSupport.js
      var classListSupport = "classList" in document.createElement("_");
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/hasClass.js

      var hasClass = classListSupport
        ? function (el, str) {
            return el.classList.contains(str);
          }
        : function (el, str) {
            return el.className.indexOf(str) >= 0;
          };

      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/addClass.js

      var addClass = classListSupport
        ? function (el, str) {
            if (!hasClass(el, str)) {
              el.classList.add(str);
            }
          }
        : function (el, str) {
            if (!hasClass(el, str)) {
              el.className += " " + str;
            }
          };

      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/removeClass.js

      var removeClass = classListSupport
        ? function (el, str) {
            if (hasClass(el, str)) {
              el.classList.remove(str);
            }
          }
        : function (el, str) {
            if (hasClass(el, str)) {
              el.className = el.className.replace(str, "");
            }
          };

      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/hasAttr.js
      function hasAttr(el, attr) {
        return el.hasAttribute(attr);
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/getAttr.js
      function getAttr(el, attr) {
        return el.getAttribute(attr);
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/isNodeList.js
      function isNodeList(el) {
        // Only NodeList has the "item()" function
        return typeof el.item !== "undefined";
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/setAttrs.js

      function setAttrs(els, attrs) {
        els = isNodeList(els) || els instanceof Array ? els : [els];
        if (Object.prototype.toString.call(attrs) !== "[object Object]") {
          return;
        }

        for (var i = els.length; i--; ) {
          for (var key in attrs) {
            els[i].setAttribute(key, attrs[key]);
          }
        }
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/removeAttrs.js

      function removeAttrs(els, attrs) {
        els = isNodeList(els) || els instanceof Array ? els : [els];
        attrs = attrs instanceof Array ? attrs : [attrs];

        var attrLength = attrs.length;
        for (var i = els.length; i--; ) {
          for (var j = attrLength; j--; ) {
            els[i].removeAttribute(attrs[j]);
          }
        }
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/arrayFromNodeList.js
      function arrayFromNodeList(nl) {
        var arr = [];
        for (var i = 0, l = nl.length; i < l; i++) {
          arr.push(nl[i]);
        }
        return arr;
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/hideElement.js
      function hideElement(el, forceHide) {
        if (el.style.display !== "none") {
          el.style.display = "none";
        }
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/showElement.js
      function showElement(el, forceHide) {
        if (el.style.display === "none") {
          el.style.display = "";
        }
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/isVisible.js
      function isVisible(el) {
        return window.getComputedStyle(el).display !== "none";
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/whichProperty.js
      function whichProperty(props) {
        if (typeof props === "string") {
          var arr = [props],
            Props = props.charAt(0).toUpperCase() + props.substr(1),
            prefixes = ["Webkit", "Moz", "ms", "O"];

          prefixes.forEach(function (prefix) {
            if (prefix !== "ms" || props === "transform") {
              arr.push(prefix + Props);
            }
          });

          props = arr;
        }

        var el = document.createElement("fakeelement"),
          len = props.length;
        for (var i = 0; i < props.length; i++) {
          var prop = props[i];
          if (el.style[prop] !== undefined) {
            return prop;
          }
        }

        return false; // explicit for ie9-
      }

      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/has3DTransforms.js

      function has3DTransforms(tf) {
        if (!tf) {
          return false;
        }
        if (!window.getComputedStyle) {
          return false;
        }

        var doc = document,
          body = getBody(),
          docOverflow = setFakeBody(body),
          el = doc.createElement("p"),
          has3d,
          cssTF = tf.length > 9 ? "-" + tf.slice(0, -9).toLowerCase() + "-" : "";

        cssTF += "transform";

        // Add it to the body to get the computed style
        body.insertBefore(el, null);

        el.style[tf] = "translate3d(1px,1px,1px)";
        has3d = window.getComputedStyle(el).getPropertyValue(cssTF);

        body.fake ? resetFakeBody(body, docOverflow) : el.remove();

        return has3d !== undefined && has3d.length > 0 && has3d !== "none";
      }

      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/getEndProperty.js
      // get transitionend, animationend based on transitionDuration
      // @propin: string
      // @propOut: string, first-letter uppercase
      // Usage: getEndProperty('WebkitTransitionDuration', 'Transition') => webkitTransitionEnd
      function getEndProperty(propIn, propOut) {
        var endProp = false;
        if (/^Webkit/.test(propIn)) {
          endProp = "webkit" + propOut + "End";
        } else if (/^O/.test(propIn)) {
          endProp = "o" + propOut + "End";
        } else if (propIn) {
          endProp = propOut.toLowerCase() + "end";
        }
        return endProp;
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/passiveOption.js
      // Test via a getter in the options object to see if the passive property is accessed
      var supportsPassive = false;
      try {
        var passiveOption_opts = Object.defineProperty({}, "passive", {
          get: function () {
            supportsPassive = true;
          },
        });
        window.addEventListener("test", null, passiveOption_opts);
      } catch (e) {}
      var passiveOption = supportsPassive ? { passive: true } : false;
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/addEvents.js

      function addEvents(el, obj, preventScrolling) {
        for (var prop in obj) {
          var option = ["touchstart", "touchmove"].indexOf(prop) >= 0 && !preventScrolling ? passiveOption : false;
          el.addEventListener(prop, obj[prop], option);
        }
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/removeEvents.js

      function removeEvents(el, obj) {
        for (var prop in obj) {
          var option = ["touchstart", "touchmove"].indexOf(prop) >= 0 ? passiveOption : false;
          el.removeEventListener(prop, obj[prop], option);
        }
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/events.js
      function Events() {
        return {
          topics: {},
          on: function (eventName, fn) {
            this.topics[eventName] = this.topics[eventName] || [];
            this.topics[eventName].push(fn);
          },
          off: function (eventName, fn) {
            if (this.topics[eventName]) {
              for (var i = 0; i < this.topics[eventName].length; i++) {
                if (this.topics[eventName][i] === fn) {
                  this.topics[eventName].splice(i, 1);
                  break;
                }
              }
            }
          },
          emit: function (eventName, data) {
            data.type = eventName;
            if (this.topics[eventName]) {
              this.topics[eventName].forEach(function (fn) {
                fn(data, eventName);
              });
            }
          },
        };
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/helpers/jsTransform.js
      function jsTransform(element, attr, prefix, postfix, to, duration, callback) {
        var tick = Math.min(duration, 10),
          unit = to.indexOf("%") >= 0 ? "%" : "px",
          to = to.replace(unit, ""),
          from = Number(element.style[attr].replace(prefix, "").replace(postfix, "").replace(unit, "")),
          positionTick = ((to - from) / duration) * tick,
          running;

        setTimeout(moveElement, tick);
        function moveElement() {
          duration -= tick;
          from += positionTick;
          element.style[attr] = prefix + from + unit + postfix;
          if (duration > 0) {
            setTimeout(moveElement, tick);
          } else {
            callback();
          }
        }
      }
      // CONCATENATED MODULE: ./node_modules/tiny-slider/src/tiny-slider.js
      // Object.keys
      if (!Object.keys) {
        Object.keys = function (object) {
          var keys = [];
          for (var name in object) {
            if (Object.prototype.hasOwnProperty.call(object, name)) {
              keys.push(name);
            }
          }
          return keys;
        };
      }

      // ChildNode.remove
      if (!("remove" in Element.prototype)) {
        Element.prototype.remove = function () {
          if (this.parentNode) {
            this.parentNode.removeChild(this);
          }
        };
      }

      var tns = function (options) {
        options = extend_extend(
          {
            container: ".slider",
            mode: "carousel",
            axis: "horizontal",
            items: 1,
            gutter: 0,
            edgePadding: 0,
            fixedWidth: false,
            autoWidth: false,
            viewportMax: false,
            slideBy: 1,
            center: false,
            controls: true,
            controlsPosition: "top",
            controlsText: ["prev", "next"],
            controlsContainer: false,
            prevButton: false,
            nextButton: false,
            nav: true,
            navPosition: "top",
            navContainer: false,
            navAsThumbnails: false,
            arrowKeys: false,
            speed: 300,
            autoplay: false,
            autoplayPosition: "top",
            autoplayTimeout: 5000,
            autoplayDirection: "forward",
            autoplayText: ["start", "stop"],
            autoplayHoverPause: false,
            autoplayButton: false,
            autoplayButtonOutput: true,
            autoplayResetOnVisibility: true,
            animateIn: "tns-fadeIn",
            animateOut: "tns-fadeOut",
            animateNormal: "tns-normal",
            animateDelay: false,
            loop: true,
            rewind: false,
            autoHeight: false,
            responsive: false,
            lazyload: false,
            lazyloadSelector: ".tns-lazy-img",
            touch: true,
            mouseDrag: false,
            swipeAngle: 15,
            nested: false,
            preventActionWhenRunning: false,
            preventScrollOnTouch: false,
            freezable: true,
            onInit: false,
            useLocalStorage: true,
            nonce: false,
          },
          options || {}
        );

        var doc = document,
          win = window,
          KEYS = {
            ENTER: 13,
            SPACE: 32,
            LEFT: 37,
            RIGHT: 39,
          },
          tnsStorage = {},
          localStorageAccess = options.useLocalStorage;

        if (localStorageAccess) {
          // check browser version and local storage access
          var browserInfo = navigator.userAgent;
          var uid = new Date();

          try {
            tnsStorage = win.localStorage;
            if (tnsStorage) {
              tnsStorage.setItem(uid, uid);
              localStorageAccess = tnsStorage.getItem(uid) == uid;
              tnsStorage.removeItem(uid);
            } else {
              localStorageAccess = false;
            }
            if (!localStorageAccess) {
              tnsStorage = {};
            }
          } catch (e) {
            localStorageAccess = false;
          }

          if (localStorageAccess) {
            // remove storage when browser version changes
            if (tnsStorage["tnsApp"] && tnsStorage["tnsApp"] !== browserInfo) {
              ["tC", "tPL", "tMQ", "tTf", "t3D", "tTDu", "tTDe", "tADu", "tADe", "tTE", "tAE"].forEach(function (item) {
                tnsStorage.removeItem(item);
              });
            }
            // update browserInfo
            localStorage["tnsApp"] = browserInfo;
          }
        }

        var CALC = tnsStorage["tC"]
            ? checkStorageValue(tnsStorage["tC"])
            : setLocalStorage(tnsStorage, "tC", calc(), localStorageAccess),
          PERCENTAGELAYOUT = tnsStorage["tPL"]
            ? checkStorageValue(tnsStorage["tPL"])
            : setLocalStorage(tnsStorage, "tPL", percentageLayout(), localStorageAccess),
          CSSMQ = tnsStorage["tMQ"]
            ? checkStorageValue(tnsStorage["tMQ"])
            : setLocalStorage(tnsStorage, "tMQ", mediaquerySupport(), localStorageAccess),
          TRANSFORM = tnsStorage["tTf"]
            ? checkStorageValue(tnsStorage["tTf"])
            : setLocalStorage(tnsStorage, "tTf", whichProperty("transform"), localStorageAccess),
          HAS3DTRANSFORMS = tnsStorage["t3D"]
            ? checkStorageValue(tnsStorage["t3D"])
            : setLocalStorage(tnsStorage, "t3D", has3DTransforms(TRANSFORM), localStorageAccess),
          TRANSITIONDURATION = tnsStorage["tTDu"]
            ? checkStorageValue(tnsStorage["tTDu"])
            : setLocalStorage(tnsStorage, "tTDu", whichProperty("transitionDuration"), localStorageAccess),
          TRANSITIONDELAY = tnsStorage["tTDe"]
            ? checkStorageValue(tnsStorage["tTDe"])
            : setLocalStorage(tnsStorage, "tTDe", whichProperty("transitionDelay"), localStorageAccess),
          ANIMATIONDURATION = tnsStorage["tADu"]
            ? checkStorageValue(tnsStorage["tADu"])
            : setLocalStorage(tnsStorage, "tADu", whichProperty("animationDuration"), localStorageAccess),
          ANIMATIONDELAY = tnsStorage["tADe"]
            ? checkStorageValue(tnsStorage["tADe"])
            : setLocalStorage(tnsStorage, "tADe", whichProperty("animationDelay"), localStorageAccess),
          TRANSITIONEND = tnsStorage["tTE"]
            ? checkStorageValue(tnsStorage["tTE"])
            : setLocalStorage(tnsStorage, "tTE", getEndProperty(TRANSITIONDURATION, "Transition"), localStorageAccess),
          ANIMATIONEND = tnsStorage["tAE"]
            ? checkStorageValue(tnsStorage["tAE"])
            : setLocalStorage(tnsStorage, "tAE", getEndProperty(ANIMATIONDURATION, "Animation"), localStorageAccess);

        // get element nodes from selectors
        var supportConsoleWarn = win.console && typeof win.console.warn === "function",
          tnsList = ["container", "controlsContainer", "prevButton", "nextButton", "navContainer", "autoplayButton"],
          optionsElements = {};

        tnsList.forEach(function (item) {
          if (typeof options[item] === "string") {
            var str = options[item],
              el = doc.querySelector(str);
            optionsElements[item] = str;

            if (el && el.nodeName) {
              options[item] = el;
            } else {
              if (supportConsoleWarn) {
                console.warn("Can't find", options[item]);
              }
              return;
            }
          }
        });

        // make sure at least 1 slide
        if (options.container.children.length < 1) {
          if (supportConsoleWarn) {
            console.warn("No slides found in", options.container);
          }
          return;
        }

        // update options
        var responsive = options.responsive,
          nested = options.nested,
          carousel = options.mode === "carousel" ? true : false;

        if (responsive) {
          // apply responsive[0] to options and remove it
          if (0 in responsive) {
            options = extend_extend(options, responsive[0]);
            delete responsive[0];
          }

          var responsiveTem = {};
          for (var key in responsive) {
            var val = responsive[key];
            // update responsive
            // from: 300: 2
            // to:
            //   300: {
            //     items: 2
            //   }
            val = typeof val === "number" ? { items: val } : val;
            responsiveTem[key] = val;
          }
          responsive = responsiveTem;
          responsiveTem = null;
        }

        // update options
        function updateOptions(obj) {
          for (var key in obj) {
            if (!carousel) {
              if (key === "slideBy") {
                obj[key] = "page";
              }
              if (key === "edgePadding") {
                obj[key] = false;
              }
              if (key === "autoHeight") {
                obj[key] = false;
              }
            }

            // update responsive options
            if (key === "responsive") {
              updateOptions(obj[key]);
            }
          }
        }
        if (!carousel) {
          updateOptions(options);
        }

        // === define and set variables ===
        if (!carousel) {
          options.axis = "horizontal";
          options.slideBy = "page";
          options.edgePadding = false;

          var animateIn = options.animateIn,
            animateOut = options.animateOut,
            animateDelay = options.animateDelay,
            animateNormal = options.animateNormal;
        }

        var horizontal = options.axis === "horizontal" ? true : false,
          outerWrapper = doc.createElement("div"),
          innerWrapper = doc.createElement("div"),
          middleWrapper,
          container = options.container,
          containerParent = container.parentNode,
          containerHTML = container.outerHTML,
          slideItems = container.children,
          slideCount = slideItems.length,
          breakpointZone,
          windowWidth = getWindowWidth(),
          isOn = false;
        if (responsive) {
          setBreakpointZone();
        }
        if (carousel) {
          container.className += " tns-vpfix";
        }

        // fixedWidth: viewport > rightBoundary > indexMax
        var autoWidth = options.autoWidth,
          fixedWidth = getOption("fixedWidth"),
          edgePadding = getOption("edgePadding"),
          gutter = getOption("gutter"),
          viewport = getViewportWidth(),
          center = getOption("center"),
          items = !autoWidth ? Math.floor(getOption("items")) : 1,
          slideBy = getOption("slideBy"),
          viewportMax = options.viewportMax || options.fixedWidthViewportWidth,
          arrowKeys = getOption("arrowKeys"),
          speed = getOption("speed"),
          rewind = options.rewind,
          loop = rewind ? false : options.loop,
          autoHeight = getOption("autoHeight"),
          controls = getOption("controls"),
          controlsText = getOption("controlsText"),
          nav = getOption("nav"),
          touch = getOption("touch"),
          mouseDrag = getOption("mouseDrag"),
          autoplay = getOption("autoplay"),
          autoplayTimeout = getOption("autoplayTimeout"),
          autoplayText = getOption("autoplayText"),
          autoplayHoverPause = getOption("autoplayHoverPause"),
          autoplayResetOnVisibility = getOption("autoplayResetOnVisibility"),
          sheet = createStyleSheet(null, getOption("nonce")),
          lazyload = options.lazyload,
          lazyloadSelector = options.lazyloadSelector,
          slidePositions, // collection of slide positions
          slideItemsOut = [],
          cloneCount = loop ? getCloneCountForLoop() : 0,
          slideCountNew = !carousel ? slideCount + cloneCount : slideCount + cloneCount * 2,
          hasRightDeadZone = (fixedWidth || autoWidth) && !loop ? true : false,
          rightBoundary = fixedWidth ? getRightBoundary() : null,
          updateIndexBeforeTransform = !carousel || !loop ? true : false,
          // transform
          transformAttr = horizontal ? "left" : "top",
          transformPrefix = "",
          transformPostfix = "",
          // index
          getIndexMax = (function () {
            if (fixedWidth) {
              return function () {
                return center && !loop ? slideCount - 1 : Math.ceil(-rightBoundary / (fixedWidth + gutter));
              };
            } else if (autoWidth) {
              return function () {
                for (var i = 0; i < slideCountNew; i++) {
                  if (slidePositions[i] >= -rightBoundary) {
                    return i;
                  }
                }
              };
            } else {
              return function () {
                if (center && carousel && !loop) {
                  return slideCount - 1;
                } else {
                  return loop || carousel ? Math.max(0, slideCountNew - Math.ceil(items)) : slideCountNew - 1;
                }
              };
            }
          })(),
          index = getStartIndex(getOption("startIndex")),
          indexCached = index,
          displayIndex = getCurrentSlide(),
          indexMin = 0,
          indexMax = !autoWidth ? getIndexMax() : null,
          // resize
          resizeTimer,
          preventActionWhenRunning = options.preventActionWhenRunning,
          swipeAngle = options.swipeAngle,
          moveDirectionExpected = swipeAngle ? "?" : true,
          running = false,
          onInit = options.onInit,
          events = new Events(),
          // id, class
          newContainerClasses = " tns-slider tns-" + options.mode,
          slideId = container.id || getSlideId(),
          disable = getOption("disable"),
          disabled = false,
          freezable = options.freezable,
          freeze = freezable && !autoWidth ? getFreeze() : false,
          frozen = false,
          controlsEvents = {
            click: onControlsClick,
            keydown: onControlsKeydown,
          },
          navEvents = {
            click: onNavClick,
            keydown: onNavKeydown,
          },
          hoverEvents = {
            mouseover: mouseoverPause,
            mouseout: mouseoutRestart,
          },
          visibilityEvent = { visibilitychange: onVisibilityChange },
          docmentKeydownEvent = { keydown: onDocumentKeydown },
          touchEvents = {
            touchstart: onPanStart,
            touchmove: onPanMove,
            touchend: onPanEnd,
            touchcancel: onPanEnd,
          },
          dragEvents = {
            mousedown: onPanStart,
            mousemove: onPanMove,
            mouseup: onPanEnd,
            mouseleave: onPanEnd,
          },
          hasControls = hasOption("controls"),
          hasNav = hasOption("nav"),
          navAsThumbnails = autoWidth ? true : options.navAsThumbnails,
          hasAutoplay = hasOption("autoplay"),
          hasTouch = hasOption("touch"),
          hasMouseDrag = hasOption("mouseDrag"),
          slideActiveClass = "tns-slide-active",
          slideClonedClass = "tns-slide-cloned",
          imgCompleteClass = "tns-complete",
          imgEvents = {
            load: onImgLoaded,
            error: onImgFailed,
          },
          imgsComplete,
          liveregionCurrent,
          preventScroll = options.preventScrollOnTouch === "force" ? true : false;

        // controls
        if (hasControls) {
          var controlsContainer = options.controlsContainer,
            controlsContainerHTML = options.controlsContainer ? options.controlsContainer.outerHTML : "",
            prevButton = options.prevButton,
            nextButton = options.nextButton,
            prevButtonHTML = options.prevButton ? options.prevButton.outerHTML : "",
            nextButtonHTML = options.nextButton ? options.nextButton.outerHTML : "",
            prevIsButton,
            nextIsButton;
        }

        // nav
        if (hasNav) {
          var navContainer = options.navContainer,
            navContainerHTML = options.navContainer ? options.navContainer.outerHTML : "",
            navItems,
            pages = autoWidth ? slideCount : getPages(),
            pagesCached = 0,
            navClicked = -1,
            navCurrentIndex = getCurrentNavIndex(),
            navCurrentIndexCached = navCurrentIndex,
            navActiveClass = "tns-nav-active",
            navStr = "Carousel Page ",
            navStrCurrent = " (Current Slide)";
        }

        // autoplay
        if (hasAutoplay) {
          var autoplayDirection = options.autoplayDirection === "forward" ? 1 : -1,
            autoplayButton = options.autoplayButton,
            autoplayButtonHTML = options.autoplayButton ? options.autoplayButton.outerHTML : "",
            autoplayHtmlStrings = ["<span class='tns-visually-hidden'>", " animation</span>"],
            autoplayTimer,
            animating,
            autoplayHoverPaused,
            autoplayUserPaused,
            autoplayVisibilityPaused;
        }

        if (hasTouch || hasMouseDrag) {
          var initPosition = {},
            lastPosition = {},
            translateInit,
            disX,
            disY,
            panStart = false,
            rafIndex,
            getDist = horizontal
              ? function (a, b) {
                  return a.x - b.x;
                }
              : function (a, b) {
                  return a.y - b.y;
                };
        }

        // disable slider when slidecount <= items
        if (!autoWidth) {
          resetVariblesWhenDisable(disable || freeze);
        }

        if (TRANSFORM) {
          transformAttr = TRANSFORM;
          transformPrefix = "translate";

          if (HAS3DTRANSFORMS) {
            transformPrefix += horizontal ? "3d(" : "3d(0px, ";
            transformPostfix = horizontal ? ", 0px, 0px)" : ", 0px)";
          } else {
            transformPrefix += horizontal ? "X(" : "Y(";
            transformPostfix = ")";
          }
        }

        if (carousel) {
          container.className = container.className.replace("tns-vpfix", "");
        }
        initStructure();
        initSheet();
        initSliderTransform();

        // === COMMON FUNCTIONS === //
        function resetVariblesWhenDisable(condition) {
          if (condition) {
            controls = nav = touch = mouseDrag = arrowKeys = autoplay = autoplayHoverPause = autoplayResetOnVisibility = false;
          }
        }

        function getCurrentSlide() {
          var tem = carousel ? index - cloneCount : index;
          while (tem < 0) {
            tem += slideCount;
          }
          return (tem % slideCount) + 1;
        }

        function getStartIndex(ind) {
          ind = ind ? Math.max(0, Math.min(loop ? slideCount - 1 : slideCount - items, ind)) : 0;
          return carousel ? ind + cloneCount : ind;
        }

        function getAbsIndex(i) {
          if (i == null) {
            i = index;
          }

          if (carousel) {
            i -= cloneCount;
          }
          while (i < 0) {
            i += slideCount;
          }

          return Math.floor(i % slideCount);
        }

        function getCurrentNavIndex() {
          var absIndex = getAbsIndex(),
            result;

          result = navAsThumbnails
            ? absIndex
            : fixedWidth || autoWidth
            ? Math.ceil(((absIndex + 1) * pages) / slideCount - 1)
            : Math.floor(absIndex / items);

          // set active nav to the last one when reaches the right edge
          if (!loop && carousel && index === indexMax) {
            result = pages - 1;
          }

          return result;
        }

        function getItemsMax() {
          // fixedWidth or autoWidth while viewportMax is not available
          if (autoWidth || (fixedWidth && !viewportMax)) {
            return slideCount - 1;
            // most cases
          } else {
            var str = fixedWidth ? "fixedWidth" : "items",
              arr = [];

            if (fixedWidth || options[str] < slideCount) {
              arr.push(options[str]);
            }

            if (responsive) {
              for (var bp in responsive) {
                var tem = responsive[bp][str];
                if (tem && (fixedWidth || tem < slideCount)) {
                  arr.push(tem);
                }
              }
            }

            if (!arr.length) {
              arr.push(0);
            }

            return Math.ceil(fixedWidth ? viewportMax / Math.min.apply(null, arr) : Math.max.apply(null, arr));
          }
        }

        function getCloneCountForLoop() {
          var itemsMax = getItemsMax(),
            result = carousel ? Math.ceil((itemsMax * 5 - slideCount) / 2) : itemsMax * 4 - slideCount;
          result = Math.max(itemsMax, result);

          return hasOption("edgePadding") ? result + 1 : result;
        }

        function getWindowWidth() {
          return win.innerWidth || doc.documentElement.clientWidth || doc.body.clientWidth;
        }

        function getInsertPosition(pos) {
          return pos === "top" ? "afterbegin" : "beforeend";
        }

        function getClientWidth(el) {
          if (el == null) {
            return;
          }
          var div = doc.createElement("div"),
            rect,
            width;
          el.appendChild(div);
          rect = div.getBoundingClientRect();
          width = rect.right - rect.left;
          div.remove();
          return width || getClientWidth(el.parentNode);
        }

        function getViewportWidth() {
          var gap = edgePadding ? edgePadding * 2 - gutter : 0;
          return getClientWidth(containerParent) - gap;
        }

        function hasOption(item) {
          if (options[item]) {
            return true;
          } else {
            if (responsive) {
              for (var bp in responsive) {
                if (responsive[bp][item]) {
                  return true;
                }
              }
            }
            return false;
          }
        }

        // get option:
        // fixed width: viewport, fixedWidth, gutter => items
        // others: window width => all variables
        // all: items => slideBy
        function getOption(item, ww) {
          if (ww == null) {
            ww = windowWidth;
          }

          if (item === "items" && fixedWidth) {
            return Math.floor((viewport + gutter) / (fixedWidth + gutter)) || 1;
          } else {
            var result = options[item];

            if (responsive) {
              for (var bp in responsive) {
                // bp: convert string to number
                if (ww >= parseInt(bp)) {
                  if (item in responsive[bp]) {
                    result = responsive[bp][item];
                  }
                }
              }
            }

            if (item === "slideBy" && result === "page") {
              result = getOption("items");
            }
            if (!carousel && (item === "slideBy" || item === "items")) {
              result = Math.floor(result);
            }

            return result;
          }
        }

        function getSlideMarginLeft(i) {
          return CALC ? CALC + "(" + i * 100 + "% / " + slideCountNew + ")" : (i * 100) / slideCountNew + "%";
        }

        function getInnerWrapperStyles(edgePaddingTem, gutterTem, fixedWidthTem, speedTem, autoHeightBP) {
          var str = "";

          if (edgePaddingTem !== undefined) {
            var gap = edgePaddingTem;
            if (gutterTem) {
              gap -= gutterTem;
            }
            str = horizontal
              ? "margin: 0 " + gap + "px 0 " + edgePaddingTem + "px;"
              : "margin: " + edgePaddingTem + "px 0 " + gap + "px 0;";
          } else if (gutterTem && !fixedWidthTem) {
            var gutterTemUnit = "-" + gutterTem + "px",
              dir = horizontal ? gutterTemUnit + " 0 0" : "0 " + gutterTemUnit + " 0";
            str = "margin: 0 " + dir + ";";
          }

          if (!carousel && autoHeightBP && TRANSITIONDURATION && speedTem) {
            str += getTransitionDurationStyle(speedTem);
          }
          return str;
        }

        function getContainerWidth(fixedWidthTem, gutterTem, itemsTem) {
          if (fixedWidthTem) {
            return (fixedWidthTem + gutterTem) * slideCountNew + "px";
          } else {
            return CALC
              ? CALC + "(" + slideCountNew * 100 + "% / " + itemsTem + ")"
              : (slideCountNew * 100) / itemsTem + "%";
          }
        }

        function getSlideWidthStyle(fixedWidthTem, gutterTem, itemsTem) {
          var width;

          if (fixedWidthTem) {
            width = fixedWidthTem + gutterTem + "px";
          } else {
            if (!carousel) {
              itemsTem = Math.floor(itemsTem);
            }
            var dividend = carousel ? slideCountNew : itemsTem;
            width = CALC ? CALC + "(100% / " + dividend + ")" : 100 / dividend + "%";
          }

          width = "width:" + width;

          // inner slider: overwrite outer slider styles
          return nested !== "inner" ? width + ";" : width + " !important;";
        }

        function getSlideGutterStyle(gutterTem) {
          var str = "";

          // gutter maybe interger || 0
          // so can't use 'if (gutter)'
          if (gutterTem !== false) {
            var prop = horizontal ? "padding-" : "margin-",
              dir = horizontal ? "right" : "bottom";
            str = prop + dir + ": " + gutterTem + "px;";
          }

          return str;
        }

        function getCSSPrefix(name, num) {
          var prefix = name.substring(0, name.length - num).toLowerCase();
          if (prefix) {
            prefix = "-" + prefix + "-";
          }

          return prefix;
        }

        function getTransitionDurationStyle(speed) {
          return getCSSPrefix(TRANSITIONDURATION, 18) + "transition-duration:" + speed / 1000 + "s;";
        }

        function getAnimationDurationStyle(speed) {
          return getCSSPrefix(ANIMATIONDURATION, 17) + "animation-duration:" + speed / 1000 + "s;";
        }

        function initStructure() {
          var classOuter = "tns-outer",
            classInner = "tns-inner",
            hasGutter = hasOption("gutter");

          outerWrapper.className = classOuter;
          innerWrapper.className = classInner;
          outerWrapper.id = slideId + "-ow";
          innerWrapper.id = slideId + "-iw";

          // set container properties
          if (container.id === "") {
            container.id = slideId;
          }
          newContainerClasses += PERCENTAGELAYOUT || autoWidth ? " tns-subpixel" : " tns-no-subpixel";
          newContainerClasses += CALC ? " tns-calc" : " tns-no-calc";
          if (autoWidth) {
            newContainerClasses += " tns-autowidth";
          }
          newContainerClasses += " tns-" + options.axis;
          container.className += newContainerClasses;

          // add constrain layer for carousel
          if (carousel) {
            middleWrapper = doc.createElement("div");
            middleWrapper.id = slideId + "-mw";
            middleWrapper.className = "tns-ovh";

            outerWrapper.appendChild(middleWrapper);
            middleWrapper.appendChild(innerWrapper);
          } else {
            outerWrapper.appendChild(innerWrapper);
          }

          if (autoHeight) {
            var wp = middleWrapper ? middleWrapper : innerWrapper;
            wp.className += " tns-ah";
          }

          containerParent.insertBefore(outerWrapper, container);
          innerWrapper.appendChild(container);

          // add id, class, aria attributes
          // before clone slides
          forEach(slideItems, function (item, i) {
            addClass(item, "tns-item");
            if (!item.id) {
              item.id = slideId + "-item" + i;
            }
            if (!carousel && animateNormal) {
              addClass(item, animateNormal);
            }
            setAttrs(item, {
              "aria-hidden": "true",
              tabindex: "-1",
            });
          });

          // ## clone slides
          // carousel: n + slides + n
          // gallery:      slides + n
          if (cloneCount) {
            var fragmentBefore = doc.createDocumentFragment(),
              fragmentAfter = doc.createDocumentFragment();

            for (var j = cloneCount; j--; ) {
              var num = j % slideCount,
                cloneFirst = slideItems[num].cloneNode(true);
              addClass(cloneFirst, slideClonedClass);
              removeAttrs(cloneFirst, "id");
              fragmentAfter.insertBefore(cloneFirst, fragmentAfter.firstChild);

              if (carousel) {
                var cloneLast = slideItems[slideCount - 1 - num].cloneNode(true);
                addClass(cloneLast, slideClonedClass);
                removeAttrs(cloneLast, "id");
                fragmentBefore.appendChild(cloneLast);
              }
            }

            container.insertBefore(fragmentBefore, container.firstChild);
            container.appendChild(fragmentAfter);
            slideItems = container.children;
          }
        }

        function initSliderTransform() {
          // ## images loaded/failed
          if (hasOption("autoHeight") || autoWidth || !horizontal) {
            var imgs = container.querySelectorAll("img");

            // add img load event listener
            forEach(imgs, function (img) {
              var src = img.src;

              if (!lazyload) {
                // not data img
                if (src && src.indexOf("data:image") < 0) {
                  img.src = "";
                  addEvents(img, imgEvents);
                  addClass(img, "loading");

                  img.src = src;
                  // data img
                } else {
                  imgLoaded(img);
                }
              }
            });

            // set imgsComplete
            raf(function () {
              imgsLoadedCheck(arrayFromNodeList(imgs), function () {
                imgsComplete = true;
              });
            });

            // reset imgs for auto height: check visible imgs only
            if (hasOption("autoHeight")) {
              imgs = getImageArray(index, Math.min(index + items - 1, slideCountNew - 1));
            }

            lazyload
              ? initSliderTransformStyleCheck()
              : raf(function () {
                  imgsLoadedCheck(arrayFromNodeList(imgs), initSliderTransformStyleCheck);
                });
          } else {
            // set container transform property
            if (carousel) {
              doContainerTransformSilent();
            }

            // update slider tools and events
            initTools();
            initEvents();
          }
        }

        function initSliderTransformStyleCheck() {
          if (autoWidth && slideCount > 1) {
            // check styles application
            var num = loop ? index : slideCount - 1;

            (function stylesApplicationCheck() {
              var left = slideItems[num].getBoundingClientRect().left;
              var right = slideItems[num - 1].getBoundingClientRect().right;

              Math.abs(left - right) <= 1
                ? initSliderTransformCore()
                : setTimeout(function () {
                    stylesApplicationCheck();
                  }, 16);
            })();
          } else {
            initSliderTransformCore();
          }
        }

        function initSliderTransformCore() {
          // run Fn()s which are rely on image loading
          if (!horizontal || autoWidth) {
            setSlidePositions();

            if (autoWidth) {
              rightBoundary = getRightBoundary();
              if (freezable) {
                freeze = getFreeze();
              }
              indexMax = getIndexMax(); // <= slidePositions, rightBoundary <=
              resetVariblesWhenDisable(disable || freeze);
            } else {
              updateContentWrapperHeight();
            }
          }

          // set container transform property
          if (carousel) {
            doContainerTransformSilent();
          }

          // update slider tools and events
          initTools();
          initEvents();
        }

        function initSheet() {
          // gallery:
          // set animation classes and left value for gallery slider
          if (!carousel) {
            for (var i = index, l = index + Math.min(slideCount, items); i < l; i++) {
              var item = slideItems[i];
              item.style.left = ((i - index) * 100) / items + "%";
              addClass(item, animateIn);
              removeClass(item, animateNormal);
            }
          }

          // #### LAYOUT

          // ## INLINE-BLOCK VS FLOAT

          // ## PercentageLayout:
          // slides: inline-block
          // remove blank space between slides by set font-size: 0

          // ## Non PercentageLayout:
          // slides: float
          //         margin-right: -100%
          //         margin-left: ~

          // Resource: https://docs.google.com/spreadsheets/d/147up245wwTXeQYve3BRSAD4oVcvQmuGsFteJOeA5xNQ/edit?usp=sharing
          if (horizontal) {
            if (PERCENTAGELAYOUT || autoWidth) {
              addCSSRule(
                sheet,
                "#" + slideId + " > .tns-item",
                "font-size:" + win.getComputedStyle(slideItems[0]).fontSize + ";",
                getCssRulesLength(sheet)
              );
              addCSSRule(sheet, "#" + slideId, "font-size:0;", getCssRulesLength(sheet));
            } else if (carousel) {
              forEach(slideItems, function (slide, i) {
                slide.style.marginLeft = getSlideMarginLeft(i);
              });
            }
          }

          // ## BASIC STYLES
          if (CSSMQ) {
            // middle wrapper style
            if (TRANSITIONDURATION) {
              var str = middleWrapper && options.autoHeight ? getTransitionDurationStyle(options.speed) : "";
              addCSSRule(sheet, "#" + slideId + "-mw", str, getCssRulesLength(sheet));
            }

            // inner wrapper styles
            str = getInnerWrapperStyles(
              options.edgePadding,
              options.gutter,
              options.fixedWidth,
              options.speed,
              options.autoHeight
            );
            addCSSRule(sheet, "#" + slideId + "-iw", str, getCssRulesLength(sheet));

            // container styles
            if (carousel) {
              str =
                horizontal && !autoWidth
                  ? "width:" + getContainerWidth(options.fixedWidth, options.gutter, options.items) + ";"
                  : "";
              if (TRANSITIONDURATION) {
                str += getTransitionDurationStyle(speed);
              }
              addCSSRule(sheet, "#" + slideId, str, getCssRulesLength(sheet));
            }

            // slide styles
            str = horizontal && !autoWidth ? getSlideWidthStyle(options.fixedWidth, options.gutter, options.items) : "";
            if (options.gutter) {
              str += getSlideGutterStyle(options.gutter);
            }
            // set gallery items transition-duration
            if (!carousel) {
              if (TRANSITIONDURATION) {
                str += getTransitionDurationStyle(speed);
              }
              if (ANIMATIONDURATION) {
                str += getAnimationDurationStyle(speed);
              }
            }
            if (str) {
              addCSSRule(sheet, "#" + slideId + " > .tns-item", str, getCssRulesLength(sheet));
            }

            // non CSS mediaqueries: IE8
            // ## update inner wrapper, container, slides if needed
            // set inline styles for inner wrapper & container
            // insert stylesheet (one line) for slides only (since slides are many)
          } else {
            // middle wrapper styles
            update_carousel_transition_duration();

            // inner wrapper styles
            innerWrapper.style.cssText = getInnerWrapperStyles(edgePadding, gutter, fixedWidth, autoHeight);

            // container styles
            if (carousel && horizontal && !autoWidth) {
              container.style.width = getContainerWidth(fixedWidth, gutter, items);
            }

            // slide styles
            var str = horizontal && !autoWidth ? getSlideWidthStyle(fixedWidth, gutter, items) : "";
            if (gutter) {
              str += getSlideGutterStyle(gutter);
            }

            // append to the last line
            if (str) {
              addCSSRule(sheet, "#" + slideId + " > .tns-item", str, getCssRulesLength(sheet));
            }
          }

          // ## MEDIAQUERIES
          if (responsive && CSSMQ) {
            for (var bp in responsive) {
              // bp: convert string to number
              bp = parseInt(bp);

              var opts = responsive[bp],
                str = "",
                middleWrapperStr = "",
                innerWrapperStr = "",
                containerStr = "",
                slideStr = "",
                itemsBP = !autoWidth ? getOption("items", bp) : null,
                fixedWidthBP = getOption("fixedWidth", bp),
                speedBP = getOption("speed", bp),
                edgePaddingBP = getOption("edgePadding", bp),
                autoHeightBP = getOption("autoHeight", bp),
                gutterBP = getOption("gutter", bp);

              // middle wrapper string
              if (TRANSITIONDURATION && middleWrapper && getOption("autoHeight", bp) && "speed" in opts) {
                middleWrapperStr = "#" + slideId + "-mw{" + getTransitionDurationStyle(speedBP) + "}";
              }

              // inner wrapper string
              if ("edgePadding" in opts || "gutter" in opts) {
                innerWrapperStr =
                  "#" +
                  slideId +
                  "-iw{" +
                  getInnerWrapperStyles(edgePaddingBP, gutterBP, fixedWidthBP, speedBP, autoHeightBP) +
                  "}";
              }

              // container string
              if (
                carousel &&
                horizontal &&
                !autoWidth &&
                ("fixedWidth" in opts || "items" in opts || (fixedWidth && "gutter" in opts))
              ) {
                containerStr = "width:" + getContainerWidth(fixedWidthBP, gutterBP, itemsBP) + ";";
              }
              if (TRANSITIONDURATION && "speed" in opts) {
                containerStr += getTransitionDurationStyle(speedBP);
              }
              if (containerStr) {
                containerStr = "#" + slideId + "{" + containerStr + "}";
              }

              // slide string
              if ("fixedWidth" in opts || (fixedWidth && "gutter" in opts) || (!carousel && "items" in opts)) {
                slideStr += getSlideWidthStyle(fixedWidthBP, gutterBP, itemsBP);
              }
              if ("gutter" in opts) {
                slideStr += getSlideGutterStyle(gutterBP);
              }
              // set gallery items transition-duration
              if (!carousel && "speed" in opts) {
                if (TRANSITIONDURATION) {
                  slideStr += getTransitionDurationStyle(speedBP);
                }
                if (ANIMATIONDURATION) {
                  slideStr += getAnimationDurationStyle(speedBP);
                }
              }
              if (slideStr) {
                slideStr = "#" + slideId + " > .tns-item{" + slideStr + "}";
              }

              // add up
              str = middleWrapperStr + innerWrapperStr + containerStr + slideStr;

              if (str) {
                sheet.insertRule("@media (min-width: " + bp / 16 + "em) {" + str + "}", sheet.cssRules.length);
              }
            }
          }
        }

        function initTools() {
          // == slides ==
          updateSlideStatus();

          // == live region ==
          outerWrapper.insertAdjacentHTML(
            "afterbegin",
            '<div class="tns-liveregion tns-visually-hidden" aria-live="polite" aria-atomic="true">slide <span class="current">' +
              getLiveRegionStr() +
              "</span>  of " +
              slideCount +
              "</div>"
          );
          liveregionCurrent = outerWrapper.querySelector(".tns-liveregion .current");

          // == autoplayInit ==
          if (hasAutoplay) {
            var txt = autoplay ? "stop" : "start";
            if (autoplayButton) {
              setAttrs(autoplayButton, { "data-action": txt });
            } else if (options.autoplayButtonOutput) {
              outerWrapper.insertAdjacentHTML(
                getInsertPosition(options.autoplayPosition),
                '<button type="button" data-action="' +
                  txt +
                  '">' +
                  autoplayHtmlStrings[0] +
                  txt +
                  autoplayHtmlStrings[1] +
                  autoplayText[0] +
                  "</button>"
              );
              autoplayButton = outerWrapper.querySelector("[data-action]");
            }

            // add event
            if (autoplayButton) {
              addEvents(autoplayButton, { click: toggleAutoplay });
            }

            if (autoplay) {
              startAutoplay();
              if (autoplayHoverPause) {
                addEvents(container, hoverEvents);
              }
              if (autoplayResetOnVisibility) {
                addEvents(container, visibilityEvent);
              }
            }
          }

          // == navInit ==
          if (hasNav) {
            var initIndex = !carousel ? 0 : cloneCount;
            // customized nav
            // will not hide the navs in case they're thumbnails
            if (navContainer) {
              setAttrs(navContainer, { "aria-label": "Carousel Pagination" });
              navItems = navContainer.children;
              forEach(navItems, function (item, i) {
                setAttrs(item, {
                  "data-nav": i,
                  tabindex: "-1",
                  "aria-label": navStr + (i + 1),
                  "aria-controls": slideId,
                });
              });

              // generated nav
            } else {
              var navHtml = "",
                hiddenStr = navAsThumbnails ? "" : 'style="display:none"';
              for (var i = 0; i < slideCount; i++) {
                // hide nav items by default
                navHtml +=
                  '<button type="button" data-nav="' +
                  i +
                  '" tabindex="-1" aria-controls="' +
                  slideId +
                  '" ' +
                  hiddenStr +
                  ' aria-label="' +
                  navStr +
                  (i + 1) +
                  '"></button>';
              }
              navHtml = '<div class="tns-nav" aria-label="Carousel Pagination">' + navHtml + "</div>";
              outerWrapper.insertAdjacentHTML(getInsertPosition(options.navPosition), navHtml);

              navContainer = outerWrapper.querySelector(".tns-nav");
              navItems = navContainer.children;
            }

            updateNavVisibility();

            // add transition
            if (TRANSITIONDURATION) {
              var prefix = TRANSITIONDURATION.substring(0, TRANSITIONDURATION.length - 18).toLowerCase(),
                str = "transition: all " + speed / 1000 + "s";

              if (prefix) {
                str = "-" + prefix + "-" + str;
              }

              addCSSRule(sheet, "[aria-controls^=" + slideId + "-item]", str, getCssRulesLength(sheet));
            }

            setAttrs(navItems[navCurrentIndex], { "aria-label": navStr + (navCurrentIndex + 1) + navStrCurrent });
            removeAttrs(navItems[navCurrentIndex], "tabindex");
            addClass(navItems[navCurrentIndex], navActiveClass);

            // add events
            addEvents(navContainer, navEvents);
          }

          // == controlsInit ==
          if (hasControls) {
            if (!controlsContainer && (!prevButton || !nextButton)) {
              outerWrapper.insertAdjacentHTML(
                getInsertPosition(options.controlsPosition),
                '<div class="tns-controls" aria-label="Carousel Navigation" tabindex="0"><button type="button" data-controls="prev" tabindex="-1" aria-controls="' +
                  slideId +
                  '">' +
                  controlsText[0] +
                  '</button><button type="button" data-controls="next" tabindex="-1" aria-controls="' +
                  slideId +
                  '">' +
                  controlsText[1] +
                  "</button></div>"
              );

              controlsContainer = outerWrapper.querySelector(".tns-controls");
            }

            if (!prevButton || !nextButton) {
              prevButton = controlsContainer.children[0];
              nextButton = controlsContainer.children[1];
            }

            if (options.controlsContainer) {
              setAttrs(controlsContainer, {
                "aria-label": "Carousel Navigation",
                tabindex: "0",
              });
            }

            if (options.controlsContainer || (options.prevButton && options.nextButton)) {
              setAttrs([prevButton, nextButton], {
                "aria-controls": slideId,
                tabindex: "-1",
              });
            }

            if (options.controlsContainer || (options.prevButton && options.nextButton)) {
              setAttrs(prevButton, { "data-controls": "prev" });
              setAttrs(nextButton, { "data-controls": "next" });
            }

            prevIsButton = isButton(prevButton);
            nextIsButton = isButton(nextButton);

            updateControlsStatus();

            // add events
            if (controlsContainer) {
              addEvents(controlsContainer, controlsEvents);
            } else {
              addEvents(prevButton, controlsEvents);
              addEvents(nextButton, controlsEvents);
            }
          }

          // hide tools if needed
          disableUI();
        }

        function initEvents() {
          // add events
          if (carousel && TRANSITIONEND) {
            var eve = {};
            eve[TRANSITIONEND] = onTransitionEnd;
            addEvents(container, eve);
          }

          if (touch) {
            addEvents(container, touchEvents, options.preventScrollOnTouch);
          }
          if (mouseDrag) {
            addEvents(container, dragEvents);
          }
          if (arrowKeys) {
            addEvents(doc, docmentKeydownEvent);
          }

          if (nested === "inner") {
            events.on("outerResized", function () {
              resizeTasks();
              events.emit("innerLoaded", info());
            });
          } else if (responsive || fixedWidth || autoWidth || autoHeight || !horizontal) {
            addEvents(win, { resize: onResize });
          }

          if (autoHeight) {
            if (nested === "outer") {
              events.on("innerLoaded", doAutoHeight);
            } else if (!disable) {
              doAutoHeight();
            }
          }

          doLazyLoad();
          if (disable) {
            disableSlider();
          } else if (freeze) {
            freezeSlider();
          }

          events.on("indexChanged", additionalUpdates);
          if (nested === "inner") {
            events.emit("innerLoaded", info());
          }
          if (typeof onInit === "function") {
            onInit(info());
          }
          isOn = true;
        }

        function destroy() {
          // sheet
          sheet.disabled = true;
          if (sheet.ownerNode) {
            sheet.ownerNode.remove();
          }

          // remove win event listeners
          removeEvents(win, { resize: onResize });

          // arrowKeys, controls, nav
          if (arrowKeys) {
            removeEvents(doc, docmentKeydownEvent);
          }
          if (controlsContainer) {
            removeEvents(controlsContainer, controlsEvents);
          }
          if (navContainer) {
            removeEvents(navContainer, navEvents);
          }

          // autoplay
          removeEvents(container, hoverEvents);
          removeEvents(container, visibilityEvent);
          if (autoplayButton) {
            removeEvents(autoplayButton, { click: toggleAutoplay });
          }
          if (autoplay) {
            clearInterval(autoplayTimer);
          }

          // container
          if (carousel && TRANSITIONEND) {
            var eve = {};
            eve[TRANSITIONEND] = onTransitionEnd;
            removeEvents(container, eve);
          }
          if (touch) {
            removeEvents(container, touchEvents);
          }
          if (mouseDrag) {
            removeEvents(container, dragEvents);
          }

          // cache Object values in options && reset HTML
          var htmlList = [
            containerHTML,
            controlsContainerHTML,
            prevButtonHTML,
            nextButtonHTML,
            navContainerHTML,
            autoplayButtonHTML,
          ];

          tnsList.forEach(function (item, i) {
            var el = item === "container" ? outerWrapper : options[item];

            if (typeof el === "object" && el) {
              var prevEl = el.previousElementSibling ? el.previousElementSibling : false,
                parentEl = el.parentNode;
              el.outerHTML = htmlList[i];
              options[item] = prevEl ? prevEl.nextElementSibling : parentEl.firstElementChild;
            }
          });

          // reset variables
          tnsList = animateIn = animateOut = animateDelay = animateNormal = horizontal = outerWrapper = innerWrapper = container = containerParent = containerHTML = slideItems = slideCount = breakpointZone = windowWidth = autoWidth = fixedWidth = edgePadding = gutter = viewport = items = slideBy = viewportMax = arrowKeys = speed = rewind = loop = autoHeight = sheet = lazyload = slidePositions = slideItemsOut = cloneCount = slideCountNew = hasRightDeadZone = rightBoundary = updateIndexBeforeTransform = transformAttr = transformPrefix = transformPostfix = getIndexMax = index = indexCached = indexMin = indexMax = resizeTimer = swipeAngle = moveDirectionExpected = running = onInit = events = newContainerClasses = slideId = disable = disabled = freezable = freeze = frozen = controlsEvents = navEvents = hoverEvents = visibilityEvent = docmentKeydownEvent = touchEvents = dragEvents = hasControls = hasNav = navAsThumbnails = hasAutoplay = hasTouch = hasMouseDrag = slideActiveClass = imgCompleteClass = imgEvents = imgsComplete = controls = controlsText = controlsContainer = controlsContainerHTML = prevButton = nextButton = prevIsButton = nextIsButton = nav = navContainer = navContainerHTML = navItems = pages = pagesCached = navClicked = navCurrentIndex = navCurrentIndexCached = navActiveClass = navStr = navStrCurrent = autoplay = autoplayTimeout = autoplayDirection = autoplayText = autoplayHoverPause = autoplayButton = autoplayButtonHTML = autoplayResetOnVisibility = autoplayHtmlStrings = autoplayTimer = animating = autoplayHoverPaused = autoplayUserPaused = autoplayVisibilityPaused = initPosition = lastPosition = translateInit = disX = disY = panStart = rafIndex = getDist = touch = mouseDrag = null;
          // check variables
          // [animateIn, animateOut, animateDelay, animateNormal, horizontal, outerWrapper, innerWrapper, container, containerParent, containerHTML, slideItems, slideCount, breakpointZone, windowWidth, autoWidth, fixedWidth, edgePadding, gutter, viewport, items, slideBy, viewportMax, arrowKeys, speed, rewind, loop, autoHeight, sheet, lazyload, slidePositions, slideItemsOut, cloneCount, slideCountNew, hasRightDeadZone, rightBoundary, updateIndexBeforeTransform, transformAttr, transformPrefix, transformPostfix, getIndexMax, index, indexCached, indexMin, indexMax, resizeTimer, swipeAngle, moveDirectionExpected, running, onInit, events, newContainerClasses, slideId, disable, disabled, freezable, freeze, frozen, controlsEvents, navEvents, hoverEvents, visibilityEvent, docmentKeydownEvent, touchEvents, dragEvents, hasControls, hasNav, navAsThumbnails, hasAutoplay, hasTouch, hasMouseDrag, slideActiveClass, imgCompleteClass, imgEvents, imgsComplete, controls, controlsText, controlsContainer, controlsContainerHTML, prevButton, nextButton, prevIsButton, nextIsButton, nav, navContainer, navContainerHTML, navItems, pages, pagesCached, navClicked, navCurrentIndex, navCurrentIndexCached, navActiveClass, navStr, navStrCurrent, autoplay, autoplayTimeout, autoplayDirection, autoplayText, autoplayHoverPause, autoplayButton, autoplayButtonHTML, autoplayResetOnVisibility, autoplayHtmlStrings, autoplayTimer, animating, autoplayHoverPaused, autoplayUserPaused, autoplayVisibilityPaused, initPosition, lastPosition, translateInit, disX, disY, panStart, rafIndex, getDist, touch, mouseDrag ].forEach(function(item) { if (item !== null) { console.log(item); } });

          for (var a in this) {
            if (a !== "rebuild") {
              this[a] = null;
            }
          }
          isOn = false;
        }

        // === ON RESIZE ===
        // responsive || fixedWidth || autoWidth || !horizontal
        function onResize(e) {
          raf(function () {
            resizeTasks(getEvent(e));
          });
        }

        function resizeTasks(e) {
          if (!isOn) {
            return;
          }
          if (nested === "outer") {
            events.emit("outerResized", info(e));
          }
          windowWidth = getWindowWidth();
          var bpChanged,
            breakpointZoneTem = breakpointZone,
            needContainerTransform = false;

          if (responsive) {
            setBreakpointZone();
            bpChanged = breakpointZoneTem !== breakpointZone;
            // if (hasRightDeadZone) { needContainerTransform = true; } // *?
            if (bpChanged) {
              events.emit("newBreakpointStart", info(e));
            }
          }

          var indChanged,
            itemsChanged,
            itemsTem = items,
            disableTem = disable,
            freezeTem = freeze,
            arrowKeysTem = arrowKeys,
            controlsTem = controls,
            navTem = nav,
            touchTem = touch,
            mouseDragTem = mouseDrag,
            autoplayTem = autoplay,
            autoplayHoverPauseTem = autoplayHoverPause,
            autoplayResetOnVisibilityTem = autoplayResetOnVisibility,
            indexTem = index;

          if (bpChanged) {
            var fixedWidthTem = fixedWidth,
              autoHeightTem = autoHeight,
              controlsTextTem = controlsText,
              centerTem = center,
              autoplayTextTem = autoplayText;

            if (!CSSMQ) {
              var gutterTem = gutter,
                edgePaddingTem = edgePadding;
            }
          }

          // get option:
          // fixed width: viewport, fixedWidth, gutter => items
          // others: window width => all variables
          // all: items => slideBy
          arrowKeys = getOption("arrowKeys");
          controls = getOption("controls");
          nav = getOption("nav");
          touch = getOption("touch");
          center = getOption("center");
          mouseDrag = getOption("mouseDrag");
          autoplay = getOption("autoplay");
          autoplayHoverPause = getOption("autoplayHoverPause");
          autoplayResetOnVisibility = getOption("autoplayResetOnVisibility");

          if (bpChanged) {
            disable = getOption("disable");
            fixedWidth = getOption("fixedWidth");
            speed = getOption("speed");
            autoHeight = getOption("autoHeight");
            controlsText = getOption("controlsText");
            autoplayText = getOption("autoplayText");
            autoplayTimeout = getOption("autoplayTimeout");

            if (!CSSMQ) {
              edgePadding = getOption("edgePadding");
              gutter = getOption("gutter");
            }
          }
          // update options
          resetVariblesWhenDisable(disable);

          viewport = getViewportWidth(); // <= edgePadding, gutter
          if ((!horizontal || autoWidth) && !disable) {
            setSlidePositions();
            if (!horizontal) {
              updateContentWrapperHeight(); // <= setSlidePositions
              needContainerTransform = true;
            }
          }
          if (fixedWidth || autoWidth) {
            rightBoundary = getRightBoundary(); // autoWidth: <= viewport, slidePositions, gutter
            // fixedWidth: <= viewport, fixedWidth, gutter
            indexMax = getIndexMax(); // autoWidth: <= rightBoundary, slidePositions
            // fixedWidth: <= rightBoundary, fixedWidth, gutter
          }

          if (bpChanged || fixedWidth) {
            items = getOption("items");
            slideBy = getOption("slideBy");
            itemsChanged = items !== itemsTem;

            if (itemsChanged) {
              if (!fixedWidth && !autoWidth) {
                indexMax = getIndexMax();
              } // <= items
              // check index before transform in case
              // slider reach the right edge then items become bigger
              updateIndex();
            }
          }

          if (bpChanged) {
            if (disable !== disableTem) {
              if (disable) {
                disableSlider();
              } else {
                enableSlider(); // <= slidePositions, rightBoundary, indexMax
              }
            }
          }

          if (freezable && (bpChanged || fixedWidth || autoWidth)) {
            freeze = getFreeze(); // <= autoWidth: slidePositions, gutter, viewport, rightBoundary
            // <= fixedWidth: fixedWidth, gutter, rightBoundary
            // <= others: items

            if (freeze !== freezeTem) {
              if (freeze) {
                doContainerTransform(getContainerTransformValue(getStartIndex(0)));
                freezeSlider();
              } else {
                unfreezeSlider();
                needContainerTransform = true;
              }
            }
          }

          resetVariblesWhenDisable(disable || freeze); // controls, nav, touch, mouseDrag, arrowKeys, autoplay, autoplayHoverPause, autoplayResetOnVisibility
          if (!autoplay) {
            autoplayHoverPause = autoplayResetOnVisibility = false;
          }

          if (arrowKeys !== arrowKeysTem) {
            arrowKeys ? addEvents(doc, docmentKeydownEvent) : removeEvents(doc, docmentKeydownEvent);
          }
          if (controls !== controlsTem) {
            if (controls) {
              if (controlsContainer) {
                showElement(controlsContainer);
              } else {
                if (prevButton) {
                  showElement(prevButton);
                }
                if (nextButton) {
                  showElement(nextButton);
                }
              }
            } else {
              if (controlsContainer) {
                hideElement(controlsContainer);
              } else {
                if (prevButton) {
                  hideElement(prevButton);
                }
                if (nextButton) {
                  hideElement(nextButton);
                }
              }
            }
          }
          if (nav !== navTem) {
            if (nav) {
              showElement(navContainer);
              updateNavVisibility();
            } else {
              hideElement(navContainer);
            }
          }
          if (touch !== touchTem) {
            touch
              ? addEvents(container, touchEvents, options.preventScrollOnTouch)
              : removeEvents(container, touchEvents);
          }
          if (mouseDrag !== mouseDragTem) {
            mouseDrag ? addEvents(container, dragEvents) : removeEvents(container, dragEvents);
          }
          if (autoplay !== autoplayTem) {
            if (autoplay) {
              if (autoplayButton) {
                showElement(autoplayButton);
              }
              if (!animating && !autoplayUserPaused) {
                startAutoplay();
              }
            } else {
              if (autoplayButton) {
                hideElement(autoplayButton);
              }
              if (animating) {
                stopAutoplay();
              }
            }
          }
          if (autoplayHoverPause !== autoplayHoverPauseTem) {
            autoplayHoverPause ? addEvents(container, hoverEvents) : removeEvents(container, hoverEvents);
          }
          if (autoplayResetOnVisibility !== autoplayResetOnVisibilityTem) {
            autoplayResetOnVisibility ? addEvents(doc, visibilityEvent) : removeEvents(doc, visibilityEvent);
          }

          if (bpChanged) {
            if (fixedWidth !== fixedWidthTem || center !== centerTem) {
              needContainerTransform = true;
            }

            if (autoHeight !== autoHeightTem) {
              if (!autoHeight) {
                innerWrapper.style.height = "";
              }
            }

            if (controls && controlsText !== controlsTextTem) {
              prevButton.innerHTML = controlsText[0];
              nextButton.innerHTML = controlsText[1];
            }

            if (autoplayButton && autoplayText !== autoplayTextTem) {
              var i = autoplay ? 1 : 0,
                html = autoplayButton.innerHTML,
                len = html.length - autoplayTextTem[i].length;
              if (html.substring(len) === autoplayTextTem[i]) {
                autoplayButton.innerHTML = html.substring(0, len) + autoplayText[i];
              }
            }
          } else {
            if (center && (fixedWidth || autoWidth)) {
              needContainerTransform = true;
            }
          }

          if (itemsChanged || (fixedWidth && !autoWidth)) {
            pages = getPages();
            updateNavVisibility();
          }

          indChanged = index !== indexTem;
          if (indChanged) {
            events.emit("indexChanged", info());
            needContainerTransform = true;
          } else if (itemsChanged) {
            if (!indChanged) {
              additionalUpdates();
            }
          } else if (fixedWidth || autoWidth) {
            doLazyLoad();
            updateSlideStatus();
            updateLiveRegion();
          }

          if (itemsChanged && !carousel) {
            updateGallerySlidePositions();
          }

          if (!disable && !freeze) {
            // non-mediaqueries: IE8
            if (bpChanged && !CSSMQ) {
              // middle wrapper styles

              // inner wrapper styles
              if (edgePadding !== edgePaddingTem || gutter !== gutterTem) {
                innerWrapper.style.cssText = getInnerWrapperStyles(edgePadding, gutter, fixedWidth, speed, autoHeight);
              }

              if (horizontal) {
                // container styles
                if (carousel) {
                  container.style.width = getContainerWidth(fixedWidth, gutter, items);
                }

                // slide styles
                var str = getSlideWidthStyle(fixedWidth, gutter, items) + getSlideGutterStyle(gutter);

                // remove the last line and
                // add new styles
                removeCSSRule(sheet, getCssRulesLength(sheet) - 1);
                addCSSRule(sheet, "#" + slideId + " > .tns-item", str, getCssRulesLength(sheet));
              }
            }

            // auto height
            if (autoHeight) {
              doAutoHeight();
            }

            if (needContainerTransform) {
              doContainerTransformSilent();
              indexCached = index;
            }
          }

          if (bpChanged) {
            events.emit("newBreakpointEnd", info(e));
          }
        }

        // === INITIALIZATION FUNCTIONS === //
        function getFreeze() {
          if (!fixedWidth && !autoWidth) {
            var a = center ? items - (items - 1) / 2 : items;
            return slideCount <= a;
          }

          var width = fixedWidth ? (fixedWidth + gutter) * slideCount : slidePositions[slideCount],
            vp = edgePadding ? viewport + edgePadding * 2 : viewport + gutter;

          if (center) {
            vp -= fixedWidth
              ? (viewport - fixedWidth) / 2
              : (viewport - (slidePositions[index + 1] - slidePositions[index] - gutter)) / 2;
          }

          return width <= vp;
        }

        function setBreakpointZone() {
          breakpointZone = 0;
          for (var bp in responsive) {
            bp = parseInt(bp); // convert string to number
            if (windowWidth >= bp) {
              breakpointZone = bp;
            }
          }
        }

        // (slideBy, indexMin, indexMax) => index
        var updateIndex = (function () {
          return loop
            ? carousel
              ? // loop + carousel
                function () {
                  var leftEdge = indexMin,
                    rightEdge = indexMax;

                  leftEdge += slideBy;
                  rightEdge -= slideBy;

                  // adjust edges when has edge paddings
                  // or fixed-width slider with extra space on the right side
                  if (edgePadding) {
                    leftEdge += 1;
                    rightEdge -= 1;
                  } else if (fixedWidth) {
                    if ((viewport + gutter) % (fixedWidth + gutter)) {
                      rightEdge -= 1;
                    }
                  }

                  if (cloneCount) {
                    if (index > rightEdge) {
                      index -= slideCount;
                    } else if (index < leftEdge) {
                      index += slideCount;
                    }
                  }
                }
              : // loop + gallery
                function () {
                  if (index > indexMax) {
                    while (index >= indexMin + slideCount) {
                      index -= slideCount;
                    }
                  } else if (index < indexMin) {
                    while (index <= indexMax - slideCount) {
                      index += slideCount;
                    }
                  }
                }
            : // non-loop
              function () {
                index = Math.max(indexMin, Math.min(indexMax, index));
              };
        })();

        function disableUI() {
          if (!autoplay && autoplayButton) {
            hideElement(autoplayButton);
          }
          if (!nav && navContainer) {
            hideElement(navContainer);
          }
          if (!controls) {
            if (controlsContainer) {
              hideElement(controlsContainer);
            } else {
              if (prevButton) {
                hideElement(prevButton);
              }
              if (nextButton) {
                hideElement(nextButton);
              }
            }
          }
        }

        function enableUI() {
          if (autoplay && autoplayButton) {
            showElement(autoplayButton);
          }
          if (nav && navContainer) {
            showElement(navContainer);
          }
          if (controls) {
            if (controlsContainer) {
              showElement(controlsContainer);
            } else {
              if (prevButton) {
                showElement(prevButton);
              }
              if (nextButton) {
                showElement(nextButton);
              }
            }
          }
        }

        function freezeSlider() {
          if (frozen) {
            return;
          }

          // remove edge padding from inner wrapper
          if (edgePadding) {
            innerWrapper.style.margin = "0px";
          }

          // add class tns-transparent to cloned slides
          if (cloneCount) {
            var str = "tns-transparent";
            for (var i = cloneCount; i--; ) {
              if (carousel) {
                addClass(slideItems[i], str);
              }
              addClass(slideItems[slideCountNew - i - 1], str);
            }
          }

          // update tools
          disableUI();

          frozen = true;
        }

        function unfreezeSlider() {
          if (!frozen) {
            return;
          }

          // restore edge padding for inner wrapper
          // for mordern browsers
          if (edgePadding && CSSMQ) {
            innerWrapper.style.margin = "";
          }

          // remove class tns-transparent to cloned slides
          if (cloneCount) {
            var str = "tns-transparent";
            for (var i = cloneCount; i--; ) {
              if (carousel) {
                removeClass(slideItems[i], str);
              }
              removeClass(slideItems[slideCountNew - i - 1], str);
            }
          }

          // update tools
          enableUI();

          frozen = false;
        }

        function disableSlider() {
          if (disabled) {
            return;
          }

          sheet.disabled = true;
          container.className = container.className.replace(newContainerClasses.substring(1), "");
          removeAttrs(container, ["style"]);
          if (loop) {
            for (var j = cloneCount; j--; ) {
              if (carousel) {
                hideElement(slideItems[j]);
              }
              hideElement(slideItems[slideCountNew - j - 1]);
            }
          }

          // vertical slider
          if (!horizontal || !carousel) {
            removeAttrs(innerWrapper, ["style"]);
          }

          // gallery
          if (!carousel) {
            for (var i = index, l = index + slideCount; i < l; i++) {
              var item = slideItems[i];
              removeAttrs(item, ["style"]);
              removeClass(item, animateIn);
              removeClass(item, animateNormal);
            }
          }

          // update tools
          disableUI();

          disabled = true;
        }

        function enableSlider() {
          if (!disabled) {
            return;
          }

          sheet.disabled = false;
          container.className += newContainerClasses;
          doContainerTransformSilent();

          if (loop) {
            for (var j = cloneCount; j--; ) {
              if (carousel) {
                showElement(slideItems[j]);
              }
              showElement(slideItems[slideCountNew - j - 1]);
            }
          }

          // gallery
          if (!carousel) {
            for (var i = index, l = index + slideCount; i < l; i++) {
              var item = slideItems[i],
                classN = i < index + items ? animateIn : animateNormal;
              item.style.left = ((i - index) * 100) / items + "%";
              addClass(item, classN);
            }
          }

          // update tools
          enableUI();

          disabled = false;
        }

        function updateLiveRegion() {
          var str = getLiveRegionStr();
          if (liveregionCurrent.innerHTML !== str) {
            liveregionCurrent.innerHTML = str;
          }
        }

        function getLiveRegionStr() {
          var arr = getVisibleSlideRange(),
            start = arr[0] + 1,
            end = arr[1] + 1;
          return start === end ? start + "" : start + " to " + end;
        }

        function getVisibleSlideRange(val) {
          if (val == null) {
            val = getContainerTransformValue();
          }
          var start = index,
            end,
            rangestart,
            rangeend;

          // get range start, range end for autoWidth and fixedWidth
          if (center || edgePadding) {
            if (autoWidth || fixedWidth) {
              rangestart = -(parseFloat(val) + edgePadding);
              rangeend = rangestart + viewport + edgePadding * 2;
            }
          } else {
            if (autoWidth) {
              rangestart = slidePositions[index];
              rangeend = rangestart + viewport;
            }
          }

          // get start, end
          // - check auto width
          if (autoWidth) {
            slidePositions.forEach(function (point, i) {
              if (i < slideCountNew) {
                if ((center || edgePadding) && point <= rangestart + 0.5) {
                  start = i;
                }
                if (rangeend - point >= 0.5) {
                  end = i;
                }
              }
            });

            // - check percentage width, fixed width
          } else {
            if (fixedWidth) {
              var cell = fixedWidth + gutter;
              if (center || edgePadding) {
                start = Math.floor(rangestart / cell);
                end = Math.ceil(rangeend / cell - 1);
              } else {
                end = start + Math.ceil(viewport / cell) - 1;
              }
            } else {
              if (center || edgePadding) {
                var a = items - 1;
                if (center) {
                  start -= a / 2;
                  end = index + a / 2;
                } else {
                  end = index + a;
                }

                if (edgePadding) {
                  var b = (edgePadding * items) / viewport;
                  start -= b;
                  end += b;
                }

                start = Math.floor(start);
                end = Math.ceil(end);
              } else {
                end = start + items - 1;
              }
            }

            start = Math.max(start, 0);
            end = Math.min(end, slideCountNew - 1);
          }

          return [start, end];
        }

        function doLazyLoad() {
          if (lazyload && !disable) {
            var arg = getVisibleSlideRange();
            arg.push(lazyloadSelector);

            getImageArray.apply(null, arg).forEach(function (img) {
              if (!hasClass(img, imgCompleteClass)) {
                // stop propagation transitionend event to container
                var eve = {};
                eve[TRANSITIONEND] = function (e) {
                  e.stopPropagation();
                };
                addEvents(img, eve);

                addEvents(img, imgEvents);

                // update src
                img.src = getAttr(img, "data-src");

                // update srcset
                var srcset = getAttr(img, "data-srcset");
                if (srcset) {
                  img.srcset = srcset;
                }

                addClass(img, "loading");
              }
            });
          }
        }

        function onImgLoaded(e) {
          imgLoaded(getTarget(e));
        }

        function onImgFailed(e) {
          imgFailed(getTarget(e));
        }

        function imgLoaded(img) {
          addClass(img, "loaded");
          imgCompleted(img);
        }

        function imgFailed(img) {
          addClass(img, "failed");
          imgCompleted(img);
        }

        function imgCompleted(img) {
          addClass(img, imgCompleteClass);
          removeClass(img, "loading");
          removeEvents(img, imgEvents);
        }

        function getImageArray(start, end, imgSelector) {
          var imgs = [];
          if (!imgSelector) {
            imgSelector = "img";
          }

          while (start <= end) {
            forEach(slideItems[start].querySelectorAll(imgSelector), function (img) {
              imgs.push(img);
            });
            start++;
          }

          return imgs;
        }

        // check if all visible images are loaded
        // and update container height if it's done
        function doAutoHeight() {
          var imgs = getImageArray.apply(null, getVisibleSlideRange());
          raf(function () {
            imgsLoadedCheck(imgs, updateInnerWrapperHeight);
          });
        }

        function imgsLoadedCheck(imgs, cb) {
          // execute callback function if all images are complete
          if (imgsComplete) {
            return cb();
          }

          // check image classes
          imgs.forEach(function (img, index) {
            if (!lazyload && img.complete) {
              imgCompleted(img);
            } // Check image.complete
            if (hasClass(img, imgCompleteClass)) {
              imgs.splice(index, 1);
            }
          });

          // execute callback function if selected images are all complete
          if (!imgs.length) {
            return cb();
          }

          // otherwise execute this functiona again
          raf(function () {
            imgsLoadedCheck(imgs, cb);
          });
        }

        function additionalUpdates() {
          doLazyLoad();
          updateSlideStatus();
          updateLiveRegion();
          updateControlsStatus();
          updateNavStatus();
        }

        function update_carousel_transition_duration() {
          if (carousel && autoHeight) {
            middleWrapper.style[TRANSITIONDURATION] = speed / 1000 + "s";
          }
        }

        function getMaxSlideHeight(slideStart, slideRange) {
          var heights = [];
          for (var i = slideStart, l = Math.min(slideStart + slideRange, slideCountNew); i < l; i++) {
            heights.push(slideItems[i].offsetHeight);
          }

          return Math.max.apply(null, heights);
        }

        // update inner wrapper height
        // 1. get the max-height of the visible slides
        // 2. set transitionDuration to speed
        // 3. update inner wrapper height to max-height
        // 4. set transitionDuration to 0s after transition done
        function updateInnerWrapperHeight() {
          var maxHeight = autoHeight ? getMaxSlideHeight(index, items) : getMaxSlideHeight(cloneCount, slideCount),
            wp = middleWrapper ? middleWrapper : innerWrapper;

          if (wp.style.height !== maxHeight) {
            wp.style.height = maxHeight + "px";
          }
        }

        // get the distance from the top edge of the first slide to each slide
        // (init) => slidePositions
        function setSlidePositions() {
          slidePositions = [0];
          var attr = horizontal ? "left" : "top",
            attr2 = horizontal ? "right" : "bottom",
            base = slideItems[0].getBoundingClientRect()[attr];

          forEach(slideItems, function (item, i) {
            // skip the first slide
            if (i) {
              slidePositions.push(item.getBoundingClientRect()[attr] - base);
            }
            // add the end edge
            if (i === slideCountNew - 1) {
              slidePositions.push(item.getBoundingClientRect()[attr2] - base);
            }
          });
        }

        // update slide
        function updateSlideStatus() {
          var range = getVisibleSlideRange(),
            start = range[0],
            end = range[1];

          forEach(slideItems, function (item, i) {
            // show slides
            if (i >= start && i <= end) {
              if (hasAttr(item, "aria-hidden")) {
                removeAttrs(item, ["aria-hidden", "tabindex"]);
                addClass(item, slideActiveClass);
              }
              // hide slides
            } else {
              if (!hasAttr(item, "aria-hidden")) {
                setAttrs(item, {
                  "aria-hidden": "true",
                  tabindex: "-1",
                });
                removeClass(item, slideActiveClass);
              }
            }
          });
        }

        // gallery: update slide position
        function updateGallerySlidePositions() {
          var l = index + Math.min(slideCount, items);
          for (var i = slideCountNew; i--; ) {
            var item = slideItems[i];

            if (i >= index && i < l) {
              // add transitions to visible slides when adjusting their positions
              addClass(item, "tns-moving");

              item.style.left = ((i - index) * 100) / items + "%";
              addClass(item, animateIn);
              removeClass(item, animateNormal);
            } else if (item.style.left) {
              item.style.left = "";
              addClass(item, animateNormal);
              removeClass(item, animateIn);
            }

            // remove outlet animation
            removeClass(item, animateOut);
          }

          // removing '.tns-moving'
          setTimeout(function () {
            forEach(slideItems, function (el) {
              removeClass(el, "tns-moving");
            });
          }, 300);
        }

        // set tabindex on Nav
        function updateNavStatus() {
          // get current nav
          if (nav) {
            navCurrentIndex = navClicked >= 0 ? navClicked : getCurrentNavIndex();
            navClicked = -1;

            if (navCurrentIndex !== navCurrentIndexCached) {
              var navPrev = navItems[navCurrentIndexCached],
                navCurrent = navItems[navCurrentIndex];

              setAttrs(navPrev, {
                tabindex: "-1",
                "aria-label": navStr + (navCurrentIndexCached + 1),
              });
              removeClass(navPrev, navActiveClass);

              setAttrs(navCurrent, { "aria-label": navStr + (navCurrentIndex + 1) + navStrCurrent });
              removeAttrs(navCurrent, "tabindex");
              addClass(navCurrent, navActiveClass);

              navCurrentIndexCached = navCurrentIndex;
            }
          }
        }

        function getLowerCaseNodeName(el) {
          return el.nodeName.toLowerCase();
        }

        function isButton(el) {
          return getLowerCaseNodeName(el) === "button";
        }

        function isAriaDisabled(el) {
          return el.getAttribute("aria-disabled") === "true";
        }

        function disEnableElement(isButton, el, val) {
          if (isButton) {
            el.disabled = val;
          } else {
            el.setAttribute("aria-disabled", val.toString());
          }
        }

        // set 'disabled' to true on controls when reach the edges
        function updateControlsStatus() {
          if (!controls || rewind || loop) {
            return;
          }

          var prevDisabled = prevIsButton ? prevButton.disabled : isAriaDisabled(prevButton),
            nextDisabled = nextIsButton ? nextButton.disabled : isAriaDisabled(nextButton),
            disablePrev = index <= indexMin ? true : false,
            disableNext = !rewind && index >= indexMax ? true : false;

          if (disablePrev && !prevDisabled) {
            disEnableElement(prevIsButton, prevButton, true);
          }
          if (!disablePrev && prevDisabled) {
            disEnableElement(prevIsButton, prevButton, false);
          }
          if (disableNext && !nextDisabled) {
            disEnableElement(nextIsButton, nextButton, true);
          }
          if (!disableNext && nextDisabled) {
            disEnableElement(nextIsButton, nextButton, false);
          }
        }

        // set duration
        function resetDuration(el, str) {
          if (TRANSITIONDURATION) {
            el.style[TRANSITIONDURATION] = str;
          }
        }

        function getSliderWidth() {
          return fixedWidth ? (fixedWidth + gutter) * slideCountNew : slidePositions[slideCountNew];
        }

        function getCenterGap(num) {
          if (num == null) {
            num = index;
          }

          var gap = edgePadding ? gutter : 0;
          return autoWidth
            ? (viewport - gap - (slidePositions[num + 1] - slidePositions[num] - gutter)) / 2
            : fixedWidth
            ? (viewport - fixedWidth) / 2
            : (items - 1) / 2;
        }

        function getRightBoundary() {
          var gap = edgePadding ? gutter : 0,
            result = viewport + gap - getSliderWidth();

          if (center && !loop) {
            result = fixedWidth
              ? -(fixedWidth + gutter) * (slideCountNew - 1) - getCenterGap()
              : getCenterGap(slideCountNew - 1) - slidePositions[slideCountNew - 1];
          }
          if (result > 0) {
            result = 0;
          }

          return result;
        }

        function getContainerTransformValue(num) {
          if (num == null) {
            num = index;
          }

          var val;
          if (horizontal && !autoWidth) {
            if (fixedWidth) {
              val = -(fixedWidth + gutter) * num;
              if (center) {
                val += getCenterGap();
              }
            } else {
              var denominator = TRANSFORM ? slideCountNew : items;
              if (center) {
                num -= getCenterGap();
              }
              val = (-num * 100) / denominator;
            }
          } else {
            val = -slidePositions[num];
            if (center && autoWidth) {
              val += getCenterGap();
            }
          }

          if (hasRightDeadZone) {
            val = Math.max(val, rightBoundary);
          }

          val += horizontal && !autoWidth && !fixedWidth ? "%" : "px";

          return val;
        }

        function doContainerTransformSilent(val) {
          resetDuration(container, "0s");
          doContainerTransform(val);
        }

        function doContainerTransform(val) {
          if (val == null) {
            val = getContainerTransformValue();
          }
          container.style[transformAttr] = transformPrefix + val + transformPostfix;
        }

        function animateSlide(number, classOut, classIn, isOut) {
          var l = number + items;
          if (!loop) {
            l = Math.min(l, slideCountNew);
          }

          for (var i = number; i < l; i++) {
            var item = slideItems[i];

            // set item positions
            if (!isOut) {
              item.style.left = ((i - index) * 100) / items + "%";
            }

            if (animateDelay && TRANSITIONDELAY) {
              item.style[TRANSITIONDELAY] = item.style[ANIMATIONDELAY] = (animateDelay * (i - number)) / 1000 + "s";
            }
            removeClass(item, classOut);
            addClass(item, classIn);

            if (isOut) {
              slideItemsOut.push(item);
            }
          }
        }

        // make transfer after click/drag:
        // 1. change 'transform' property for mordern browsers
        // 2. change 'left' property for legacy browsers
        var transformCore = (function () {
          return carousel
            ? function () {
                resetDuration(container, "");
                if (TRANSITIONDURATION || !speed) {
                  // for morden browsers with non-zero duration or
                  // zero duration for all browsers
                  doContainerTransform();
                  // run fallback function manually
                  // when duration is 0 / container is hidden
                  if (!speed || !isVisible(container)) {
                    onTransitionEnd();
                  }
                } else {
                  // for old browser with non-zero duration
                  jsTransform(
                    container,
                    transformAttr,
                    transformPrefix,
                    transformPostfix,
                    getContainerTransformValue(),
                    speed,
                    onTransitionEnd
                  );
                }

                if (!horizontal) {
                  updateContentWrapperHeight();
                }
              }
            : function () {
                slideItemsOut = [];

                var eve = {};
                eve[TRANSITIONEND] = eve[ANIMATIONEND] = onTransitionEnd;
                removeEvents(slideItems[indexCached], eve);
                addEvents(slideItems[index], eve);

                animateSlide(indexCached, animateIn, animateOut, true);
                animateSlide(index, animateNormal, animateIn);

                // run fallback function manually
                // when transition or animation not supported / duration is 0
                if (!TRANSITIONEND || !ANIMATIONEND || !speed || !isVisible(container)) {
                  onTransitionEnd();
                }
              };
        })();

        function render(e, sliderMoved) {
          if (updateIndexBeforeTransform) {
            updateIndex();
          }

          // render when slider was moved (touch or drag) even though index may not change
          if (index !== indexCached || sliderMoved) {
            // events
            events.emit("indexChanged", info());
            events.emit("transitionStart", info());
            if (autoHeight) {
              doAutoHeight();
            }

            // pause autoplay when click or keydown from user
            if (animating && e && ["click", "keydown"].indexOf(e.type) >= 0) {
              stopAutoplay();
            }

            running = true;
            transformCore();
          }
        }

        /*
         * Transfer prefixed properties to the same format
         * CSS: -Webkit-Transform => webkittransform
         * JS: WebkitTransform => webkittransform
         * @param {string} str - property
         *
         */
        function strTrans(str) {
          return str.toLowerCase().replace(/-/g, "");
        }

        // AFTER TRANSFORM
        // Things need to be done after a transfer:
        // 1. check index
        // 2. add classes to visible slide
        // 3. disable controls buttons when reach the first/last slide in non-loop slider
        // 4. update nav status
        // 5. lazyload images
        // 6. update container height
        function onTransitionEnd(event) {
          // check running on gallery mode
          // make sure trantionend/animationend events run only once
          if (carousel || running) {
            events.emit("transitionEnd", info(event));

            if (!carousel && slideItemsOut.length > 0) {
              for (var i = 0; i < slideItemsOut.length; i++) {
                var item = slideItemsOut[i];
                // set item positions
                item.style.left = "";

                if (ANIMATIONDELAY && TRANSITIONDELAY) {
                  item.style[ANIMATIONDELAY] = "";
                  item.style[TRANSITIONDELAY] = "";
                }
                removeClass(item, animateOut);
                addClass(item, animateNormal);
              }
            }

            /* update slides, nav, controls after checking ...
             * => legacy browsers who don't support 'event'
             *    have to check event first, otherwise event.target will cause an error
             * => or 'gallery' mode:
             *   + event target is slide item
             * => or 'carousel' mode:
             *   + event target is container,
             *   + event.property is the same with transform attribute
             */
            if (
              !event ||
              (!carousel && event.target.parentNode === container) ||
              (event.target === container && strTrans(event.propertyName) === strTrans(transformAttr))
            ) {
              if (!updateIndexBeforeTransform) {
                var indexTem = index;
                updateIndex();
                if (index !== indexTem) {
                  events.emit("indexChanged", info());

                  doContainerTransformSilent();
                }
              }

              if (nested === "inner") {
                events.emit("innerLoaded", info());
              }
              running = false;
              indexCached = index;
            }
          }
        }

        // # ACTIONS
        function goTo(targetIndex, e) {
          if (freeze) {
            return;
          }

          // prev slideBy
          if (targetIndex === "prev") {
            onControlsClick(e, -1);

            // next slideBy
          } else if (targetIndex === "next") {
            onControlsClick(e, 1);

            // go to exact slide
          } else {
            if (running) {
              if (preventActionWhenRunning) {
                return;
              } else {
                onTransitionEnd();
              }
            }

            var absIndex = getAbsIndex(),
              indexGap = 0;

            if (targetIndex === "first") {
              indexGap = -absIndex;
            } else if (targetIndex === "last") {
              indexGap = carousel ? slideCount - items - absIndex : slideCount - 1 - absIndex;
            } else {
              if (typeof targetIndex !== "number") {
                targetIndex = parseInt(targetIndex);
              }

              if (!isNaN(targetIndex)) {
                // from directly called goTo function
                if (!e) {
                  targetIndex = Math.max(0, Math.min(slideCount - 1, targetIndex));
                }

                indexGap = targetIndex - absIndex;
              }
            }

            // gallery: make sure new page won't overlap with current page
            if (!carousel && indexGap && Math.abs(indexGap) < items) {
              var factor = indexGap > 0 ? 1 : -1;
              indexGap +=
                index + indexGap - slideCount >= indexMin ? slideCount * factor : slideCount * 2 * factor * -1;
            }

            index += indexGap;

            // make sure index is in range
            if (carousel && loop) {
              if (index < indexMin) {
                index += slideCount;
              }
              if (index > indexMax) {
                index -= slideCount;
              }
            }

            // if index is changed, start rendering
            if (getAbsIndex(index) !== getAbsIndex(indexCached)) {
              render(e);
            }
          }
        }

        // on controls click
        function onControlsClick(e, dir) {
          if (running) {
            if (preventActionWhenRunning) {
              return;
            } else {
              onTransitionEnd();
            }
          }
          var passEventObject;

          if (!dir) {
            e = getEvent(e);
            var target = getTarget(e);

            while (target !== controlsContainer && [prevButton, nextButton].indexOf(target) < 0) {
              target = target.parentNode;
            }

            var targetIn = [prevButton, nextButton].indexOf(target);
            if (targetIn >= 0) {
              passEventObject = true;
              dir = targetIn === 0 ? -1 : 1;
            }
          }

          if (rewind) {
            if (index === indexMin && dir === -1) {
              goTo("last", e);
              return;
            } else if (index === indexMax && dir === 1) {
              goTo("first", e);
              return;
            }
          }

          if (dir) {
            index += slideBy * dir;
            if (autoWidth) {
              index = Math.floor(index);
            }
            // pass e when click control buttons or keydown
            render(passEventObject || (e && e.type === "keydown") ? e : null);
          }
        }

        // on nav click
        function onNavClick(e) {
          if (running) {
            if (preventActionWhenRunning) {
              return;
            } else {
              onTransitionEnd();
            }
          }

          e = getEvent(e);
          var target = getTarget(e),
            navIndex;

          // find the clicked nav item
          while (target !== navContainer && !hasAttr(target, "data-nav")) {
            target = target.parentNode;
          }
          if (hasAttr(target, "data-nav")) {
            var navIndex = (navClicked = Number(getAttr(target, "data-nav"))),
              targetIndexBase = fixedWidth || autoWidth ? (navIndex * slideCount) / pages : navIndex * items,
              targetIndex = navAsThumbnails ? navIndex : Math.min(Math.ceil(targetIndexBase), slideCount - 1);
            goTo(targetIndex, e);

            if (navCurrentIndex === navIndex) {
              if (animating) {
                stopAutoplay();
              }
              navClicked = -1; // reset navClicked
            }
          }
        }

        // autoplay functions
        function setAutoplayTimer() {
          autoplayTimer = setInterval(function () {
            onControlsClick(null, autoplayDirection);
          }, autoplayTimeout);

          animating = true;
        }

        function stopAutoplayTimer() {
          clearInterval(autoplayTimer);
          animating = false;
        }

        function updateAutoplayButton(action, txt) {
          setAttrs(autoplayButton, { "data-action": action });
          autoplayButton.innerHTML = autoplayHtmlStrings[0] + action + autoplayHtmlStrings[1] + txt;
        }

        function startAutoplay() {
          setAutoplayTimer();
          if (autoplayButton) {
            updateAutoplayButton("stop", autoplayText[1]);
          }
        }

        function stopAutoplay() {
          stopAutoplayTimer();
          if (autoplayButton) {
            updateAutoplayButton("start", autoplayText[0]);
          }
        }

        // programaitcally play/pause the slider
        function play() {
          if (autoplay && !animating) {
            startAutoplay();
            autoplayUserPaused = false;
          }
        }
        function pause() {
          if (animating) {
            stopAutoplay();
            autoplayUserPaused = true;
          }
        }

        function toggleAutoplay() {
          if (animating) {
            stopAutoplay();
            autoplayUserPaused = true;
          } else {
            startAutoplay();
            autoplayUserPaused = false;
          }
        }

        function onVisibilityChange() {
          if (doc.hidden) {
            if (animating) {
              stopAutoplayTimer();
              autoplayVisibilityPaused = true;
            }
          } else if (autoplayVisibilityPaused) {
            setAutoplayTimer();
            autoplayVisibilityPaused = false;
          }
        }

        function mouseoverPause() {
          if (animating) {
            stopAutoplayTimer();
            autoplayHoverPaused = true;
          }
        }

        function mouseoutRestart() {
          if (autoplayHoverPaused) {
            setAutoplayTimer();
            autoplayHoverPaused = false;
          }
        }

        // keydown events on document
        function onDocumentKeydown(e) {
          e = getEvent(e);
          var keyIndex = [KEYS.LEFT, KEYS.RIGHT].indexOf(e.keyCode);

          if (keyIndex >= 0) {
            onControlsClick(e, keyIndex === 0 ? -1 : 1);
          }
        }

        // on key control
        function onControlsKeydown(e) {
          e = getEvent(e);
          var keyIndex = [KEYS.LEFT, KEYS.RIGHT].indexOf(e.keyCode);

          if (keyIndex >= 0) {
            if (keyIndex === 0) {
              if (!prevButton.disabled) {
                onControlsClick(e, -1);
              }
            } else if (!nextButton.disabled) {
              onControlsClick(e, 1);
            }
          }
        }

        // set focus
        function setFocus(el) {
          el.focus();
        }

        // on key nav
        function onNavKeydown(e) {
          e = getEvent(e);
          var curElement = doc.activeElement;
          if (!hasAttr(curElement, "data-nav")) {
            return;
          }

          // var code = e.keyCode,
          var keyIndex = [KEYS.LEFT, KEYS.RIGHT, KEYS.ENTER, KEYS.SPACE].indexOf(e.keyCode),
            navIndex = Number(getAttr(curElement, "data-nav"));

          if (keyIndex >= 0) {
            if (keyIndex === 0) {
              if (navIndex > 0) {
                setFocus(navItems[navIndex - 1]);
              }
            } else if (keyIndex === 1) {
              if (navIndex < pages - 1) {
                setFocus(navItems[navIndex + 1]);
              }
            } else {
              navClicked = navIndex;
              goTo(navIndex, e);
            }
          }
        }

        function getEvent(e) {
          e = e || win.event;
          return isTouchEvent(e) ? e.changedTouches[0] : e;
        }
        function getTarget(e) {
          return e.target || win.event.srcElement;
        }

        function isTouchEvent(e) {
          return e.type.indexOf("touch") >= 0;
        }

        function preventDefaultBehavior(e) {
          e.preventDefault ? e.preventDefault() : (e.returnValue = false);
        }

        function getMoveDirectionExpected() {
          return (
            getTouchDirection(
              toDegree(lastPosition.y - initPosition.y, lastPosition.x - initPosition.x),
              swipeAngle
            ) === options.axis
          );
        }

        function onPanStart(e) {
          if (running) {
            if (preventActionWhenRunning) {
              return;
            } else {
              onTransitionEnd();
            }
          }

          if (autoplay && animating) {
            stopAutoplayTimer();
          }

          panStart = true;
          if (rafIndex) {
            caf(rafIndex);
            rafIndex = null;
          }

          var $ = getEvent(e);
          events.emit(isTouchEvent(e) ? "touchStart" : "dragStart", info(e));

          if (!isTouchEvent(e) && ["img", "a"].indexOf(getLowerCaseNodeName(getTarget(e))) >= 0) {
            preventDefaultBehavior(e);
          }

          lastPosition.x = initPosition.x = $.clientX;
          lastPosition.y = initPosition.y = $.clientY;
          if (carousel) {
            translateInit = parseFloat(container.style[transformAttr].replace(transformPrefix, ""));
            resetDuration(container, "0s");
          }
        }

        function onPanMove(e) {
          if (panStart) {
            var $ = getEvent(e);
            lastPosition.x = $.clientX;
            lastPosition.y = $.clientY;

            if (carousel) {
              if (!rafIndex) {
                rafIndex = raf(function () {
                  panUpdate(e);
                });
              }
            } else {
              if (moveDirectionExpected === "?") {
                moveDirectionExpected = getMoveDirectionExpected();
              }
              if (moveDirectionExpected) {
                preventScroll = true;
              }
            }

            if ((typeof e.cancelable !== "boolean" || e.cancelable) && preventScroll) {
              e.preventDefault();
            }
          }
        }

        function panUpdate(e) {
          if (!moveDirectionExpected) {
            panStart = false;
            return;
          }
          caf(rafIndex);
          if (panStart) {
            rafIndex = raf(function () {
              panUpdate(e);
            });
          }

          if (moveDirectionExpected === "?") {
            moveDirectionExpected = getMoveDirectionExpected();
          }
          if (moveDirectionExpected) {
            if (!preventScroll && isTouchEvent(e)) {
              preventScroll = true;
            }

            try {
              if (e.type) {
                events.emit(isTouchEvent(e) ? "touchMove" : "dragMove", info(e));
              }
            } catch (err) {}

            var x = translateInit,
              dist = getDist(lastPosition, initPosition);
            if (!horizontal || fixedWidth || autoWidth) {
              x += dist;
              x += "px";
            } else {
              var percentageX = TRANSFORM
                ? (dist * items * 100) / ((viewport + gutter) * slideCountNew)
                : (dist * 100) / (viewport + gutter);
              x += percentageX;
              x += "%";
            }

            container.style[transformAttr] = transformPrefix + x + transformPostfix;
          }
        }

        function onPanEnd(e) {
          if (panStart) {
            if (rafIndex) {
              caf(rafIndex);
              rafIndex = null;
            }
            if (carousel) {
              resetDuration(container, "");
            }
            panStart = false;

            var $ = getEvent(e);
            lastPosition.x = $.clientX;
            lastPosition.y = $.clientY;
            var dist = getDist(lastPosition, initPosition);

            if (Math.abs(dist)) {
              // drag vs click
              if (!isTouchEvent(e)) {
                // prevent "click"
                var target = getTarget(e);
                addEvents(target, {
                  click: function preventClick(e) {
                    preventDefaultBehavior(e);
                    removeEvents(target, { click: preventClick });
                  },
                });
              }

              if (carousel) {
                rafIndex = raf(function () {
                  if (horizontal && !autoWidth) {
                    var indexMoved = (-dist * items) / (viewport + gutter);
                    indexMoved = dist > 0 ? Math.floor(indexMoved) : Math.ceil(indexMoved);
                    index += indexMoved;
                  } else {
                    var moved = -(translateInit + dist);
                    if (moved <= 0) {
                      index = indexMin;
                    } else if (moved >= slidePositions[slideCountNew - 1]) {
                      index = indexMax;
                    } else {
                      var i = 0;
                      while (i < slideCountNew && moved >= slidePositions[i]) {
                        index = i;
                        if (moved > slidePositions[i] && dist < 0) {
                          index += 1;
                        }
                        i++;
                      }
                    }
                  }

                  render(e, dist);
                  events.emit(isTouchEvent(e) ? "touchEnd" : "dragEnd", info(e));
                });
              } else {
                if (moveDirectionExpected) {
                  onControlsClick(e, dist > 0 ? -1 : 1);
                }
              }
            }
          }

          // reset
          if (options.preventScrollOnTouch === "auto") {
            preventScroll = false;
          }
          if (swipeAngle) {
            moveDirectionExpected = "?";
          }
          if (autoplay && !animating) {
            setAutoplayTimer();
          }
        }

        // === RESIZE FUNCTIONS === //
        // (slidePositions, index, items) => vertical_conentWrapper.height
        function updateContentWrapperHeight() {
          var wp = middleWrapper ? middleWrapper : innerWrapper;
          wp.style.height = slidePositions[index + items] - slidePositions[index] + "px";
        }

        function getPages() {
          var rough = fixedWidth ? ((fixedWidth + gutter) * slideCount) / viewport : slideCount / items;
          return Math.min(Math.ceil(rough), slideCount);
        }

        /*
         * 1. update visible nav items list
         * 2. add "hidden" attributes to previous visible nav items
         * 3. remove "hidden" attrubutes to new visible nav items
         */
        function updateNavVisibility() {
          if (!nav || navAsThumbnails) {
            return;
          }

          if (pages !== pagesCached) {
            var min = pagesCached,
              max = pages,
              fn = showElement;

            if (pagesCached > pages) {
              min = pages;
              max = pagesCached;
              fn = hideElement;
            }

            while (min < max) {
              fn(navItems[min]);
              min++;
            }

            // cache pages
            pagesCached = pages;
          }
        }

        function info(e) {
          return {
            container: container,
            slideItems: slideItems,
            navContainer: navContainer,
            navItems: navItems,
            controlsContainer: controlsContainer,
            hasControls: hasControls,
            prevButton: prevButton,
            nextButton: nextButton,
            items: items,
            slideBy: slideBy,
            cloneCount: cloneCount,
            slideCount: slideCount,
            slideCountNew: slideCountNew,
            index: index,
            indexCached: indexCached,
            displayIndex: getCurrentSlide(),
            navCurrentIndex: navCurrentIndex,
            navCurrentIndexCached: navCurrentIndexCached,
            pages: pages,
            pagesCached: pagesCached,
            sheet: sheet,
            isOn: isOn,
            event: e || {},
          };
        }

        return {
          version: "2.9.3",
          getInfo: info,
          events: events,
          goTo: goTo,
          play: play,
          pause: pause,
          isOn: isOn,
          updateSliderHeight: updateInnerWrapperHeight,
          refresh: initSliderTransform,
          destroy: destroy,
          rebuild: function () {
            return tns(extend_extend(options, optionsElements));
          },
        };
      };

      // EXTERNAL MODULE: ./node_modules/easytimer.js/dist/easytimer.js
      var easytimer = __webpack_require__(6);

      // CONCATENATED MODULE: ./node_modules/@shopify/theme-product-form/listeners.js
      function Listeners() {
        this.entries = [];
      }

      Listeners.prototype.add = function (element, event, fn) {
        this.entries.push({ element: element, event: event, fn: fn });
        element.addEventListener(event, fn);
      };

      Listeners.prototype.removeAll = function () {
        this.entries = this.entries.filter(function (listener) {
          listener.element.removeEventListener(listener.event, listener.fn);
          return false;
        });
      };

      // CONCATENATED MODULE: ./node_modules/@shopify/theme-product/theme-product.js
      /**
       * Returns a product JSON object when passed a product URL
       * @param {*} url
       */
      function getProductJson(handle) {
        return fetch("/products/" + handle + ".js").then(function (response) {
          return response.json();
        });
      }

      /**
       * Find a match in the project JSON (using a ID number) and return the variant (as an Object)
       * @param {Object} product Product JSON object
       * @param {Number} value Accepts Number (e.g. 6908023078973)
       * @returns {Object} The variant object once a match has been successful. Otherwise null will be return
       */
      function getVariantFromId(product, value) {
        _validateProductStructure(product);

        if (typeof value !== "number") {
          throw new TypeError(value + " is not a Number.");
        }

        var result = product.variants.filter(function (variant) {
          return variant.id === value;
        });

        return result[0] || null;
      }

      /**
       * Convert the Object (with 'name' and 'value' keys) into an Array of values, then find a match & return the variant (as an Object)
       * @param {Object} product Product JSON object
       * @param {Object} collection Object with 'name' and 'value' keys (e.g. [{ name: "Size", value: "36" }, { name: "Color", value: "Black" }])
       * @returns {Object || null} The variant object once a match has been successful. Otherwise null will be returned
       */
      function getVariantFromSerializedArray(product, collection) {
        _validateProductStructure(product);

        // If value is an array of options
        var optionArray = _createOptionArrayFromOptionCollection(product, collection);
        return getVariantFromOptionArray(product, optionArray);
      }

      /**
       * Find a match in the project JSON (using Array with option values) and return the variant (as an Object)
       * @param {Object} product Product JSON object
       * @param {Array} options List of submitted values (e.g. ['36', 'Black'])
       * @returns {Object || null} The variant object once a match has been successful. Otherwise null will be returned
       */
      function getVariantFromOptionArray(product, options) {
        _validateProductStructure(product);
        _validateOptionsArray(options);

        var result = product.variants.filter(function (variant) {
          return options.every(function (option, index) {
            return variant.options[index] === option;
          });
        });

        return result[0] || null;
      }

      /**
       * Creates an array of selected options from the object
       * Loops through the project.options and check if the "option name" exist (product.options.name) and matches the target
       * @param {Object} product Product JSON object
       * @param {Array} collection Array of object (e.g. [{ name: "Size", value: "36" }, { name: "Color", value: "Black" }])
       * @returns {Array} The result of the matched values. (e.g. ['36', 'Black'])
       */
      function _createOptionArrayFromOptionCollection(product, collection) {
        _validateProductStructure(product);
        _validateSerializedArray(collection);

        var optionArray = [];

        collection.forEach(function (option) {
          for (var i = 0; i < product.options.length; i++) {
            if (product.options[i].name.toLowerCase() === option.name.toLowerCase()) {
              optionArray[i] = option.value;
              break;
            }
          }
        });

        return optionArray;
      }

      /**
       * Check if the product data is a valid JS object
       * Error will be thrown if type is invalid
       * @param {object} product Product JSON object
       */
      function _validateProductStructure(product) {
        if (typeof product !== "object") {
          throw new TypeError(product + " is not an object.");
        }

        if (Object.keys(product).length === 0 && product.constructor === Object) {
          throw new Error(product + " is empty.");
        }
      }

      /**
       * Validate the structure of the array
       * It must be formatted like jQuery's serializeArray()
       * @param {Array} collection Array of object [{ name: "Size", value: "36" }, { name: "Color", value: "Black" }]
       */
      function _validateSerializedArray(collection) {
        if (!Array.isArray(collection)) {
          throw new TypeError(collection + " is not an array.");
        }

        if (collection.length === 0) {
          return [];
        }

        if (collection[0].hasOwnProperty("name")) {
          if (typeof collection[0].name !== "string") {
            throw new TypeError(
              "Invalid value type passed for name of option " + collection[0].name + ". Value should be string."
            );
          }
        } else {
          throw new Error(collection[0] + "does not contain name key.");
        }
      }

      /**
       * Validate the structure of the array
       * It must be formatted as list of values
       * @param {Array} collection Array of object (e.g. ['36', 'Black'])
       */
      function _validateOptionsArray(options) {
        if (Array.isArray(options) && typeof options[0] === "object") {
          throw new Error(options + "is not a valid array of options.");
        }
      }

      // CONCATENATED MODULE: ./node_modules/@shopify/theme-product-form/theme-product-form.js

      var selectors = {
        idInput: '[name="id"]',
        optionInput: '[name^="options"]',
        quantityInput: '[name="quantity"]',
        propertyInput: '[name^="properties"]',
      };

      // Public Methods
      // -----------------------------------------------------------------------------

      /**
       * Returns a URL with a variant ID query parameter. Useful for updating window.history
       * with a new URL based on the currently select product variant.
       * @param {string} url - The URL you wish to append the variant ID to
       * @param {number} id  - The variant ID you wish to append to the URL
       * @returns {string} - The new url which includes the variant ID query parameter
       */

      function getUrlWithVariant(url, id) {
        if (/variant=/.test(url)) {
          return url.replace(/(variant=)[^&]+/, "$1" + id);
        } else if (/\?/.test(url)) {
          return url.concat("&variant=").concat(id);
        }

        return url.concat("?variant=").concat(id);
      }

      /**
       * Constructor class that creates a new instance of a product form controller.
       *
       * @param {Element} element - DOM element which is equal to the <form> node wrapping product form inputs
       * @param {Object} product - A product object
       * @param {Object} options - Optional options object
       * @param {Function} options.onOptionChange - Callback for whenever an option input changes
       * @param {Function} options.onQuantityChange - Callback for whenever an quantity input changes
       * @param {Function} options.onPropertyChange - Callback for whenever a property input changes
       * @param {Function} options.onFormSubmit - Callback for whenever the product form is submitted
       */
      function ProductForm(element, product, options) {
        this.element = element;
        this.product = _validateProductObject(product);

        options = options || {};

        this._listeners = new Listeners();
        this._listeners.add(this.element, "submit", this._onSubmit.bind(this, options));

        this.optionInputs = this._initInputs(selectors.optionInput, options.onOptionChange);

        this.quantityInputs = this._initInputs(selectors.quantityInput, options.onQuantityChange);

        this.propertyInputs = this._initInputs(selectors.propertyInput, options.onPropertyChange);
      }

      /**
       * Cleans up all event handlers that were assigned when the Product Form was constructed.
       * Useful for use when a section needs to be reloaded in the theme editor.
       */
      ProductForm.prototype.destroy = function () {
        this._listeners.removeAll();
      };

      /**
       * Getter method which returns the array of currently selected option values
       *
       * @returns {Array} An array of option values
       */
      ProductForm.prototype.options = function () {
        return _serializeOptionValues(this.optionInputs, function (item) {
          var regex = /(?:^(options\[))(.*?)(?:\])/;
          item.name = regex.exec(item.name)[2]; // Use just the value between 'options[' and ']'
          return item;
        });
      };

      /**
       * Getter method which returns the currently selected variant, or `null` if variant
       * doesn't exist.
       *
       * @returns {Object|null} Variant object
       */
      ProductForm.prototype.variant = function () {
        return getVariantFromSerializedArray(this.product, this.options());
      };

      /**
       * Getter method which returns a collection of objects containing name and values
       * of property inputs
       *
       * @returns {Array} Collection of objects with name and value keys
       */
      ProductForm.prototype.properties = function () {
        var properties = _serializePropertyValues(this.propertyInputs, function (propertyName) {
          var regex = /(?:^(properties\[))(.*?)(?:\])/;
          var name = regex.exec(propertyName)[2]; // Use just the value between 'properties[' and ']'
          return name;
        });

        return Object.entries(properties).length === 0 ? null : properties;
      };

      /**
       * Getter method which returns the current quantity or 1 if no quantity input is
       * included in the form
       *
       * @returns {Array} Collection of objects with name and value keys
       */
      ProductForm.prototype.quantity = function () {
        return this.quantityInputs[0] ? Number.parseInt(this.quantityInputs[0].value, 10) : 1;
      };

      // Private Methods
      // -----------------------------------------------------------------------------
      ProductForm.prototype._setIdInputValue = function (value) {
        var idInputElement = this.element.querySelector(selectors.idInput);

        if (!idInputElement) {
          idInputElement = document.createElement("input");
          idInputElement.type = "hidden";
          idInputElement.name = "id";
          this.element.appendChild(idInputElement);
        }

        idInputElement.value = value.toString();
      };

      ProductForm.prototype._onSubmit = function (options, event) {
        event.dataset = this._getProductFormEventData();

        this._setIdInputValue(event.dataset.variant.id);

        if (options.onFormSubmit) {
          options.onFormSubmit(event);
        }
      };

      ProductForm.prototype._onFormEvent = function (cb) {
        if (typeof cb === "undefined") {
          return Function.prototype;
        }

        return function (event) {
          event.dataset = this._getProductFormEventData();
          cb(event);
        }.bind(this);
      };

      ProductForm.prototype._initInputs = function (selector, cb) {
        var elements = Array.prototype.slice.call(this.element.querySelectorAll(selector));

        return elements.map(
          function (element) {
            this._listeners.add(element, "change", this._onFormEvent(cb));
            return element;
          }.bind(this)
        );
      };

      ProductForm.prototype._getProductFormEventData = function () {
        return {
          options: this.options(),
          variant: this.variant(),
          properties: this.properties(),
          quantity: this.quantity(),
        };
      };

      function _serializeOptionValues(inputs, transform) {
        return inputs.reduce(function (options, input) {
          if (
            input.checked || // If input is a checked (means type radio or checkbox)
            (input.type !== "radio" && input.type !== "checkbox") // Or if its any other type of input
          ) {
            options.push(transform({ name: input.name, value: input.value }));
          }

          return options;
        }, []);
      }

      function _serializePropertyValues(inputs, transform) {
        return inputs.reduce(function (properties, input) {
          if (
            input.checked || // If input is a checked (means type radio or checkbox)
            (input.type !== "radio" && input.type !== "checkbox") // Or if its any other type of input
          ) {
            properties[transform(input.name)] = input.value;
          }

          return properties;
        }, {});
      }

      function _validateProductObject(product) {
        if (typeof product !== "object") {
          throw new TypeError(product + " is not an object.");
        }

        if (typeof product.variants[0].options === "undefined") {
          throw new TypeError(
            "Product object is invalid. Make sure you use the product object that is output from {{ product | json }} or from the http://[your-product-url].js route"
          );
        }

        return product;
      }

      // CONCATENATED MODULE: ./node_modules/@shopify/theme-addresses/loader.js
      var query =
        "query countries($locale: SupportedLocale!) {" +
        "  countries(locale: $locale) {" +
        "    name" +
        "    code" +
        "    labels {" +
        "      address1" +
        "      address2" +
        "      city" +
        "      company" +
        "      country" +
        "      firstName" +
        "      lastName" +
        "      phone" +
        "      postalCode" +
        "      zone" +
        "    }" +
        "    formatting {" +
        "      edit" +
        "    }" +
        "    zones {" +
        "      name" +
        "      code" +
        "    }" +
        "  }" +
        "}";

      var GRAPHQL_ENDPOINT = "https://country-service.shopifycloud.com/graphql";

      function loadCountries(locale) {
        var response = fetch(GRAPHQL_ENDPOINT, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
          },
          body: JSON.stringify({
            query: query,
            operationName: "countries",
            variables: {
              locale: toSupportedLocale(locale),
            },
          }),
        });

        return response
          .then(function (res) {
            return res.json();
          })
          .then(function (countries) {
            return countries.data.countries;
          });
      }

      var DEFAULT_LOCALE = "EN";
      var SUPPORTED_LOCALES = ["DA", "DE", "EN", "ES", "FR", "IT", "JA", "NL", "PT", "PT_BR"];

      function toSupportedLocale(locale) {
        var supportedLocale = locale.replace(/-/, "_").toUpperCase();

        if (SUPPORTED_LOCALES.indexOf(supportedLocale) !== -1) {
          return supportedLocale;
        } else if (SUPPORTED_LOCALES.indexOf(supportedLocale.substring(0, 2)) !== -1) {
          return supportedLocale.substring(0, 2);
        } else {
          return DEFAULT_LOCALE;
        }
      }

      // CONCATENATED MODULE: ./node_modules/@shopify/theme-addresses/helpers.js
      function mergeObjects() {
        var to = Object({});

        for (var index = 0; index < arguments.length; index++) {
          var nextSource = arguments[index];

          if (nextSource) {
            for (var nextKey in nextSource) {
              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
        return to;
      }

      // CONCATENATED MODULE: ./node_modules/@shopify/theme-addresses/addressForm.js

      var FIELD_REGEXP = /({\w+})/g;
      var LINE_DELIMITER = "_";
      var INPUT_SELECTORS = {
        lastName: '[name="address[last_name]"]',
        firstName: '[name="address[first_name]"]',
        company: '[name="address[company]"]',
        address1: '[name="address[address1]"]',
        address2: '[name="address[address2]"]',
        country: '[name="address[country]"]',
        zone: '[name="address[province]"]',
        postalCode: '[name="address[zip]"]',
        city: '[name="address[city]"]',
        phone: '[name="address[phone]"]',
      };

      function AddressForm(rootEl, locale, options) {
        locale = locale || "en";
        options = options || { inputSelectors: {} };
        var formElements = loadFormElements(rootEl, mergeObjects(INPUT_SELECTORS, options.inputSelectors));

        validateElements(formElements);

        return loadShippingCountries(options.shippingCountriesOnly).then(function (shippingCountryCodes) {
          return loadCountries(locale).then(function (countries) {
            addressForm_init(rootEl, formElements, filterCountries(countries, shippingCountryCodes));
          });
        });
      }

      /**
       * Runs when countries have been loaded
       */
      function addressForm_init(rootEl, formElements, countries) {
        populateCountries(formElements, countries);
        var selectedCountry = formElements.country.input ? formElements.country.input.value : null;
        setEventListeners(rootEl, formElements, countries);
        handleCountryChange(rootEl, formElements, selectedCountry, countries);
      }

      /**
       * Handles when a country change: set labels, reorder fields, populate zones
       */
      function handleCountryChange(rootEl, formElements, countryCode, countries) {
        var country = getCountry(countryCode, countries);

        setLabels(formElements, country);
        reorderFields(rootEl, formElements, country);
        populateZones(formElements, country);
      }

      /**
       * Sets up event listener for country change
       */
      function setEventListeners(rootEl, formElements, countries) {
        formElements.country.input.addEventListener("change", function (event) {
          handleCountryChange(rootEl, formElements, event.target.value, countries);
        });
      }

      /**
       * Reorder fields in the DOM and add data-attribute to fields given a country
       */
      function reorderFields(rootEl, formElements, country) {
        var formFormat = country.formatting.edit;

        var countryWrapper = formElements.country.wrapper;
        var afterCountry = false;

        getOrderedField(formFormat).forEach(function (row) {
          row.forEach(function (line) {
            formElements[line].wrapper.dataset.lineCount = row.length;
            if (!formElements[line].wrapper) {
              return;
            }
            if (line === "country") {
              afterCountry = true;
              return;
            }

            if (afterCountry) {
              rootEl.append(formElements[line].wrapper);
            } else {
              rootEl.insertBefore(formElements[line].wrapper, countryWrapper);
            }
          });
        });
      }

      /**
       * Update labels for a given country
       */
      function setLabels(formElements, country) {
        Object.keys(formElements).forEach(function (formElementName) {
          formElements[formElementName].labels.forEach(function (label) {
            label.textContent = country.labels[formElementName];
          });
        });
      }

      /**
       * Add right countries in the dropdown for a given country
       */
      function populateCountries(formElements, countries) {
        var countrySelect = formElements.country.input;
        var duplicatedCountrySelect = countrySelect.cloneNode(true);

        countries.forEach(function (country) {
          var optionElement = document.createElement("option");
          optionElement.value = country.code;
          optionElement.textContent = country.name;
          duplicatedCountrySelect.appendChild(optionElement);
        });

        countrySelect.innerHTML = duplicatedCountrySelect.innerHTML;

        if (countrySelect.dataset.default) {
          countrySelect.value = countrySelect.dataset.default;
        }
      }

      /**
       * Add right zones in the dropdown for a given country
       */
      function populateZones(formElements, country) {
        var zoneEl = formElements.zone;
        if (!zoneEl) {
          return;
        }

        if (country.zones.length === 0) {
          zoneEl.wrapper.dataset.ariaHidden = "true";
          zoneEl.input.innerHTML = "";
          return;
        }

        zoneEl.wrapper.dataset.ariaHidden = "false";

        var zoneSelect = zoneEl.input;
        var duplicatedZoneSelect = zoneSelect.cloneNode(true);
        duplicatedZoneSelect.innerHTML = "";

        country.zones.forEach(function (zone) {
          var optionElement = document.createElement("option");
          optionElement.value = zone.code;
          optionElement.textContent = zone.name;
          duplicatedZoneSelect.appendChild(optionElement);
        });

        zoneSelect.innerHTML = duplicatedZoneSelect.innerHTML;

        if (zoneSelect.dataset.default) {
          zoneSelect.value = zoneSelect.dataset.default;
        }
      }

      /**
       * Will throw if an input or a label is missing from the wrapper
       */
      function validateElements(formElements) {
        Object.keys(formElements).forEach(function (elementKey) {
          var element = formElements[elementKey].input;
          var labels = formElements[elementKey].labels;

          if (!element) {
            return;
          }

          if (typeof element !== "object") {
            throw new TypeError(formElements[elementKey] + " is missing an input or select.");
          } else if (typeof labels !== "object") {
            throw new TypeError(formElements[elementKey] + " is missing a label.");
          }
        });
      }

      /**
       * Given an countryCode (eg. 'CA'), will return the data of that country
       */
      function getCountry(countryCode, countries) {
        countryCode = countryCode || "CA";
        return countries.filter(function (country) {
          return country.code === countryCode;
        })[0];
      }

      /**
       * Given a format (eg. "{firstName}{lastName}_{company}_{address1}_{address2}_{city}_{country}{province}{zip}_{phone}")
       * will return an array of how the form needs to be formatted, eg.:
       * =>
       * [
       *   ['firstName', 'lastName'],
       *   ['company'],
       *   ['address1'],
       *   ['address2'],
       *   ['city'],
       *   ['country', 'province', 'zip'],
       *   ['phone']
       * ]
       */
      function getOrderedField(format) {
        return format.split(LINE_DELIMITER).map(function (fields) {
          var result = fields.match(FIELD_REGEXP);
          if (!result) {
            return [];
          }

          return result.map(function (fieldName) {
            var newFieldName = fieldName.replace(/[{}]/g, "");

            switch (newFieldName) {
              case "zip":
                return "postalCode";
              case "province":
                return "zone";
              default:
                return newFieldName;
            }
          });
        });
      }

      /**
       * Given a rootEl where all `input`s, `select`s, and `labels` are nested, it
       * will returns all form elements (wrapper, input and labels) of the form.
       * See `FormElements` type for details
       */
      function loadFormElements(rootEl, inputSelectors) {
        var elements = {};
        Object.keys(INPUT_SELECTORS).forEach(function (inputKey) {
          var input = rootEl.querySelector(inputSelectors[inputKey]);
          elements[inputKey] = input
            ? {
                wrapper: input.parentElement,
                input: input,
                labels: document.querySelectorAll('[for="' + input.id + '"]'),
              }
            : {};
        });

        return elements;
      }

      /**
       * If shippingCountriesOnly is set to true, will return the list of countries the
       * shop ships to. Otherwise returns null.
       */
      function loadShippingCountries(shippingCountriesOnly) {
        if (!shippingCountriesOnly) {
          // eslint-disable-next-line no-undef
          return Promise.resolve(null);
        }

        var response = fetch(location.origin + "/meta.json");

        return response
          .then(function (res) {
            return res.json();
          })
          .then(function (meta) {
            // If ships_to_countries has * in the list, it means the shop ships to
            // all countries
            return meta.ships_to_countries.indexOf("*") !== -1 ? null : meta.ships_to_countries;
          })
          .catch(function () {
            return null;
          });
      }

      /**
       * Only returns countries that are in includedCountryCodes
       * Returns all countries if no includedCountryCodes is passed
       */
      function filterCountries(countries, includedCountryCodes) {
        if (!includedCountryCodes) {
          return countries;
        }

        return countries.filter(function (country) {
          return includedCountryCodes.indexOf(country.code) !== -1;
        });
      }

      // CONCATENATED MODULE: ./node_modules/@shopify/theme-addresses/theme-addresses.js

      // EXTERNAL MODULE: ./node_modules/@shopify/theme-currency/dist/currency.cjs.js
      var currency_cjs = __webpack_require__(1);

      // EXTERNAL MODULE: ./node_modules/@shopify/theme-images/dist/images.cjs.js
      var images_cjs = __webpack_require__(4);

      // CONCATENATED MODULE: ./node_modules/@shopify/theme-cart/request.js
      function getDefaultRequestConfig() {
        return JSON.parse(
          JSON.stringify({
            credentials: "same-origin",
            headers: {
              "X-Requested-With": "XMLHttpRequest",
              "Content-Type": "application/json;",
            },
          })
        );
      }

      function fetchJSON(url, config) {
        return fetch(url, config).then(function (response) {
          if (!response.ok) {
            throw response;
          }
          return response.json();
        });
      }

      function request_cart() {
        return fetchJSON("/cart.js", getDefaultRequestConfig());
      }

      function cartAdd(id, quantity, properties) {
        var config = getDefaultRequestConfig();

        config.method = "POST";
        config.body = JSON.stringify({
          id: id,
          quantity: quantity,
          properties: properties,
        });

        return fetchJSON("/cart/add.js", config);
      }

      function cartAddFromForm(formData) {
        var config = getDefaultRequestConfig();
        delete config.headers["Content-Type"];

        config.method = "POST";
        config.body = formData;

        return fetchJSON("/cart/add.js", config);
      }

      function cartChange(line, options) {
        var config = getDefaultRequestConfig();

        options = options || {};

        config.method = "POST";
        config.body = JSON.stringify({
          line: line,
          quantity: options.quantity,
          properties: options.properties,
        });

        return fetchJSON("/cart/change.js", config);
      }

      function cartClear() {
        var config = getDefaultRequestConfig();
        config.method = "POST";

        return fetchJSON("/cart/clear.js", config);
      }

      function cartUpdate(body) {
        var config = getDefaultRequestConfig();

        config.method = "POST";
        config.body = JSON.stringify(body);

        return fetchJSON("/cart/update.js", config);
      }

      function cartShippingRates() {
        return fetchJSON("/cart/shipping_rates.json", getDefaultRequestConfig());
      }

      // CONCATENATED MODULE: ./node_modules/@shopify/theme-cart/validate.js
      function validate_key(key) {
        if (typeof key !== "string" || key.split(":").length !== 2) {
          throw new TypeError("Theme Cart: Provided key value is not a string with the format xxx:xxx");
        }
      }

      function quantity(quantity) {
        if (typeof quantity !== "number" || isNaN(quantity)) {
          throw new TypeError("Theme Cart: An object which specifies a quantity or properties value is required");
        }
      }

      function validate_id(id) {
        if (typeof id !== "number" || isNaN(id)) {
          throw new TypeError("Theme Cart: Variant ID must be a number");
        }
      }

      function validate_properties(properties) {
        if (typeof properties !== "object") {
          throw new TypeError("Theme Cart: Properties must be an object");
        }
      }

      function validate_form(form) {
        if (!(form instanceof HTMLFormElement)) {
          throw new TypeError("Theme Cart: Form must be an instance of HTMLFormElement");
        }
      }

      function validate_options(options) {
        if (typeof options !== "object") {
          throw new TypeError("Theme Cart: Options must be an object");
        }

        if (typeof options.quantity === "undefined" && typeof options.properties === "undefined") {
          throw new Error("Theme Cart: You muse define a value for quantity or properties");
        }

        if (typeof options.quantity !== "undefined") {
          quantity(options.quantity);
        }

        if (typeof options.properties !== "undefined") {
          validate_properties(options.properties);
        }
      }

      // CONCATENATED MODULE: ./node_modules/@shopify/theme-cart/theme-cart.js
      /**
       * Cart Template Script
       * ------------------------------------------------------------------------------
       * A file that contains scripts highly couple code to the Cart template.
       *
       * @namespace cart
       */

      /**
       * Returns the state object of the cart
       * @returns {Promise} Resolves with the state object of the cart (https://help.shopify.com/en/themes/development/getting-started/using-ajax-api#get-cart)
       */
      function getState() {
        return request_cart();
      }

      /**
       * Returns the index of the cart line item
       * @param {string} key The unique key of the line item
       * @returns {Promise} Resolves with the index number of the line item
       */
      function getItemIndex(key) {
        validate_key(key);

        return request_cart().then(function (state) {
          var index = -1;

          state.items.forEach(function (item, i) {
            index = item.key === key ? i + 1 : index;
          });

          if (index === -1) {
            return Promise.reject(new Error("Theme Cart: Unable to match line item with provided key"));
          }

          return index;
        });
      }

      /**
       * Fetches the line item object
       * @param {string} key The unique key of the line item
       * @returns {Promise} Resolves with the line item object (See response of cart/add.js https://help.shopify.com/en/themes/development/getting-started/using-ajax-api#add-to-cart)
       */
      function getItem(key) {
        validate_key(key);

        return request_cart().then(function (state) {
          var lineItem = null;

          state.items.forEach(function (item) {
            lineItem = item.key === key ? item : lineItem;
          });

          if (lineItem === null) {
            return Promise.reject(new Error("Theme Cart: Unable to match line item with provided key"));
          }

          return lineItem;
        });
      }

      /**
       * Add a new line item to the cart
       * @param {number} id The variant's unique ID
       * @param {object} options Optional values to pass to /cart/add.js
       * @param {number} options.quantity The quantity of items to be added to the cart
       * @param {object} options.properties Line item property key/values (https://help.shopify.com/en/themes/liquid/objects/line_item#line_item-properties)
       * @returns {Promise} Resolves with the line item object (See response of cart/add.js https://help.shopify.com/en/themes/development/getting-started/using-ajax-api#add-to-cart)
       */
      function addItem(id, options) {
        options = options || {};

        validate_id(id);

        return cartAdd(id, options.quantity, options.properties);
      }

      /**
       * Add a new line item to the cart from a product form
       * @param {object} form DOM element which is equal to the <form> node
       * @returns {Promise} Resolves with the line item object (See response of cart/add.js https://help.shopify.com/en/themes/development/getting-started/using-ajax-api#add-to-cart)
       */
      function addItemFromForm(form) {
        validate_form(form);

        var formData = new FormData(form);
        validate_id(parseInt(formData.get("id"), 10));

        return cartAddFromForm(formData);
      }

      /**
       * Changes the quantity and/or properties of an existing line item.
       * @param {string} key The unique key of the line item (https://help.shopify.com/en/themes/liquid/objects/line_item#line_item-key)
       * @param {object} options Optional values to pass to /cart/add.js
       * @param {number} options.quantity The quantity of items to be added to the cart
       * @param {object} options.properties Line item property key/values (https://help.shopify.com/en/themes/liquid/objects/line_item#line_item-properties)
       * @returns {Promise} Resolves with the state object of the cart (https://help.shopify.com/en/themes/development/getting-started/using-ajax-api#get-cart)
       */
      function updateItem(key, options) {
        validate_key(key);
        validate_options(options);

        return getItemIndex(key).then(function (line) {
          return cartChange(line, options);
        });
      }

      /**
       * Removes a line item from the cart
       * @param {string} key The unique key of the line item (https://help.shopify.com/en/themes/liquid/objects/line_item#line_item-key)
       * @returns {Promise} Resolves with the state object of the cart (https://help.shopify.com/en/themes/development/getting-started/using-ajax-api#get-cart)
       */
      function removeItem(key) {
        validate_key(key);

        return getItemIndex(key).then(function (line) {
          return cartChange(line, { quantity: 0 });
        });
      }

      /**
       * Sets all quantities of all line items in the cart to zero. This does not remove cart attributes nor the cart note.
       * @returns {Promise} Resolves with the state object of the cart (https://help.shopify.com/en/themes/development/getting-started/using-ajax-api#get-cart)
       */
      function clearItems() {
        return cartClear();
      }

      /**
       * Gets all cart attributes
       * @returns {Promise} Resolves with the cart attributes object
       */
      function getAttributes() {
        return request_cart().then(function (state) {
          return state.attributes;
        });
      }

      /**
       * Sets all cart attributes
       * @returns {Promise} Resolves with the cart state object
       */
      function updateAttributes(attributes) {
        return cartUpdate({ attributes: attributes });
      }

      /**
       * Clears all cart attributes
       * @returns {Promise} Resolves with the cart state object
       */
      function clearAttributes() {
        return getAttributes().then(function (attributes) {
          for (var key in attributes) {
            attributes[key] = "";
          }
          return updateAttributes(attributes);
        });
      }

      /**
       * Gets cart note
       * @returns {Promise} Resolves with the cart note string
       */
      function getNote() {
        return request_cart().then(function (state) {
          return state.note;
        });
      }

      /**
       * Sets cart note
       * @returns {Promise} Resolves with the cart state object
       */
      function updateNote(note) {
        return cartUpdate({ note: note });
      }

      /**
       * Clears cart note
       * @returns {Promise} Resolves with the cart state object
       */
      function clearNote() {
        return cartUpdate({ note: "" });
      }

      /**
       * Get estimated shipping rates.
       * @returns {Promise} Resolves with response of /cart/shipping_rates.json (https://help.shopify.com/en/themes/development/getting-started/using-ajax-api#get-shipping-rates)
       */
      function getShippingRates() {
        return cartShippingRates();
      }

      // CONCATENATED MODULE: ./node_modules/drift-zoom/es/util/dom.js
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype
              ? "symbol"
              : typeof obj;
          };
        }
        return _typeof(obj);
      }

      // This is not really a perfect check, but works fine.
      // From http://stackoverflow.com/questions/384286
      var HAS_DOM_2 = (typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement)) === "object";
      function isDOMElement(obj) {
        return HAS_DOM_2
          ? obj instanceof HTMLElement
          : obj && _typeof(obj) === "object" && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === "string";
      }
      function addClasses(el, classNames) {
        classNames.forEach(function (className) {
          el.classList.add(className);
        });
      }
      function removeClasses(el, classNames) {
        classNames.forEach(function (className) {
          el.classList.remove(className);
        });
      }
      //# sourceMappingURL=dom.js.map
      // CONCATENATED MODULE: ./node_modules/drift-zoom/es/injectBaseStylesheet.js
      /* UNMINIFIED RULES

const RULES = `
@keyframes noop {
  0% { zoom: 1; }
}

@-webkit-keyframes noop {
  0% { zoom: 1; }
}

.drift-zoom-pane.drift-open {
  display: block;
}

.drift-zoom-pane.drift-opening, .drift-zoom-pane.drift-closing {
  animation: noop 1ms;
  -webkit-animation: noop 1ms;
}

.drift-zoom-pane {
  position: absolute;
  overflow: hidden;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  pointer-events: none;
}

.drift-zoom-pane-loader {
  display: none;
}

.drift-zoom-pane img {
  position: absolute;
  display: block;
  max-width: none;
  max-height: none;
}

.drift-bounding-box {
  position: absolute;
  pointer-events: none;
}
`;

*/
      var RULES =
        ".drift-bounding-box,.drift-zoom-pane{position:absolute;pointer-events:none}@keyframes noop{0%{zoom:1}}@-webkit-keyframes noop{0%{zoom:1}}.drift-zoom-pane.drift-open{display:block}.drift-zoom-pane.drift-closing,.drift-zoom-pane.drift-opening{animation:noop 1ms;-webkit-animation:noop 1ms}.drift-zoom-pane{overflow:hidden;width:100%;height:100%;top:0;left:0}.drift-zoom-pane-loader{display:none}.drift-zoom-pane img{position:absolute;display:block;max-width:none;max-height:none}";
      function injectBaseStylesheet() {
        if (document.querySelector(".drift-base-styles")) {
          return;
        }

        var styleEl = document.createElement("style");
        styleEl.type = "text/css";
        styleEl.classList.add("drift-base-styles");
        styleEl.appendChild(document.createTextNode(RULES));
        var head = document.head;
        head.insertBefore(styleEl, head.firstChild);
      }
      //# sourceMappingURL=injectBaseStylesheet.js.map
      // CONCATENATED MODULE: ./node_modules/drift-zoom/es/util/throwIfMissing.js
      function throwIfMissing() {
        throw new Error("Missing parameter");
      }
      //# sourceMappingURL=throwIfMissing.js.map
      // CONCATENATED MODULE: ./node_modules/drift-zoom/es/BoundingBox.js
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      var BoundingBox_BoundingBox =
        /*#__PURE__*/
        (function () {
          function BoundingBox(options) {
            _classCallCheck(this, BoundingBox);

            this.isShowing = false;
            var _options$namespace = options.namespace,
              namespace = _options$namespace === void 0 ? null : _options$namespace,
              _options$zoomFactor = options.zoomFactor,
              zoomFactor = _options$zoomFactor === void 0 ? throwIfMissing() : _options$zoomFactor,
              _options$containerEl = options.containerEl,
              containerEl = _options$containerEl === void 0 ? throwIfMissing() : _options$containerEl;
            this.settings = {
              namespace: namespace,
              zoomFactor: zoomFactor,
              containerEl: containerEl,
            };
            this.openClasses = this._buildClasses("open");

            this._buildElement();
          }

          _createClass(BoundingBox, [
            {
              key: "_buildClasses",
              value: function _buildClasses(suffix) {
                var classes = ["drift-".concat(suffix)];
                var ns = this.settings.namespace;

                if (ns) {
                  classes.push("".concat(ns, "-").concat(suffix));
                }

                return classes;
              },
            },
            {
              key: "_buildElement",
              value: function _buildElement() {
                this.el = document.createElement("div");
                addClasses(this.el, this._buildClasses("bounding-box"));
              },
            },
            {
              key: "show",
              value: function show(zoomPaneWidth, zoomPaneHeight) {
                this.isShowing = true;
                this.settings.containerEl.appendChild(this.el);
                var style = this.el.style;
                style.width = "".concat(Math.round(zoomPaneWidth / this.settings.zoomFactor), "px");
                style.height = "".concat(Math.round(zoomPaneHeight / this.settings.zoomFactor), "px");
                addClasses(this.el, this.openClasses);
              },
            },
            {
              key: "hide",
              value: function hide() {
                if (this.isShowing) {
                  this.settings.containerEl.removeChild(this.el);
                }

                this.isShowing = false;
                removeClasses(this.el, this.openClasses);
              },
            },
            {
              key: "setPosition",
              value: function setPosition(percentageOffsetX, percentageOffsetY, triggerRect) {
                var pageXOffset = window.pageXOffset;
                var pageYOffset = window.pageYOffset;
                var inlineLeft =
                  triggerRect.left + percentageOffsetX * triggerRect.width - this.el.clientWidth / 2 + pageXOffset;
                var inlineTop =
                  triggerRect.top + percentageOffsetY * triggerRect.height - this.el.clientHeight / 2 + pageYOffset;

                if (inlineLeft < triggerRect.left + pageXOffset) {
                  inlineLeft = triggerRect.left + pageXOffset;
                } else if (inlineLeft + this.el.clientWidth > triggerRect.left + triggerRect.width + pageXOffset) {
                  inlineLeft = triggerRect.left + triggerRect.width - this.el.clientWidth + pageXOffset;
                }

                if (inlineTop < triggerRect.top + pageYOffset) {
                  inlineTop = triggerRect.top + pageYOffset;
                } else if (inlineTop + this.el.clientHeight > triggerRect.top + triggerRect.height + pageYOffset) {
                  inlineTop = triggerRect.top + triggerRect.height - this.el.clientHeight + pageYOffset;
                }

                this.el.style.left = "".concat(inlineLeft, "px");
                this.el.style.top = "".concat(inlineTop, "px");
              },
            },
          ]);

          return BoundingBox;
        })();

      //# sourceMappingURL=BoundingBox.js.map
      // CONCATENATED MODULE: ./node_modules/drift-zoom/es/Trigger.js
      function Trigger_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function Trigger_defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function Trigger_createClass(Constructor, protoProps, staticProps) {
        if (protoProps) Trigger_defineProperties(Constructor.prototype, protoProps);
        if (staticProps) Trigger_defineProperties(Constructor, staticProps);
        return Constructor;
      }

      var Trigger_Trigger =
        /*#__PURE__*/
        (function () {
          function Trigger() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            Trigger_classCallCheck(this, Trigger);

            this._show = this._show.bind(this);
            this._hide = this._hide.bind(this);
            this._handleEntry = this._handleEntry.bind(this);
            this._handleMovement = this._handleMovement.bind(this);
            var _options$el = options.el,
              el = _options$el === void 0 ? throwIfMissing() : _options$el,
              _options$zoomPane = options.zoomPane,
              zoomPane = _options$zoomPane === void 0 ? throwIfMissing() : _options$zoomPane,
              _options$sourceAttrib = options.sourceAttribute,
              sourceAttribute = _options$sourceAttrib === void 0 ? throwIfMissing() : _options$sourceAttrib,
              _options$handleTouch = options.handleTouch,
              handleTouch = _options$handleTouch === void 0 ? throwIfMissing() : _options$handleTouch,
              _options$onShow = options.onShow,
              onShow = _options$onShow === void 0 ? null : _options$onShow,
              _options$onHide = options.onHide,
              onHide = _options$onHide === void 0 ? null : _options$onHide,
              _options$hoverDelay = options.hoverDelay,
              hoverDelay = _options$hoverDelay === void 0 ? 0 : _options$hoverDelay,
              _options$touchDelay = options.touchDelay,
              touchDelay = _options$touchDelay === void 0 ? 0 : _options$touchDelay,
              _options$hoverBoundin = options.hoverBoundingBox,
              hoverBoundingBox = _options$hoverBoundin === void 0 ? throwIfMissing() : _options$hoverBoundin,
              _options$touchBoundin = options.touchBoundingBox,
              touchBoundingBox = _options$touchBoundin === void 0 ? throwIfMissing() : _options$touchBoundin,
              _options$namespace = options.namespace,
              namespace = _options$namespace === void 0 ? null : _options$namespace,
              _options$zoomFactor = options.zoomFactor,
              zoomFactor = _options$zoomFactor === void 0 ? throwIfMissing() : _options$zoomFactor,
              _options$boundingBoxC = options.boundingBoxContainer,
              boundingBoxContainer = _options$boundingBoxC === void 0 ? throwIfMissing() : _options$boundingBoxC;
            this.settings = {
              el: el,
              zoomPane: zoomPane,
              sourceAttribute: sourceAttribute,
              handleTouch: handleTouch,
              onShow: onShow,
              onHide: onHide,
              hoverDelay: hoverDelay,
              touchDelay: touchDelay,
              hoverBoundingBox: hoverBoundingBox,
              touchBoundingBox: touchBoundingBox,
              namespace: namespace,
              zoomFactor: zoomFactor,
              boundingBoxContainer: boundingBoxContainer,
            };

            if (this.settings.hoverBoundingBox || this.settings.touchBoundingBox) {
              this.boundingBox = new BoundingBox_BoundingBox({
                namespace: this.settings.namespace,
                zoomFactor: this.settings.zoomFactor,
                containerEl: this.settings.boundingBoxContainer,
              });
            }

            this.enabled = true;

            this._bindEvents();
          }

          Trigger_createClass(Trigger, [
            {
              key: "_preventDefault",
              value: function _preventDefault(event) {
                event.preventDefault();
              },
            },
            {
              key: "_preventDefaultAllowTouchScroll",
              value: function _preventDefaultAllowTouchScroll(event) {
                if (!this.settings.touchDelay || !this._isTouchEvent(event) || this.isShowing) {
                  event.preventDefault();
                }
              },
            },
            {
              key: "_isTouchEvent",
              value: function _isTouchEvent(event) {
                return !!event.touches;
              },
            },
            {
              key: "_bindEvents",
              value: function _bindEvents() {
                this.settings.el.addEventListener("mouseenter", this._handleEntry, false);
                this.settings.el.addEventListener("mouseleave", this._hide, false);
                this.settings.el.addEventListener("mousemove", this._handleMovement, false);

                if (this.settings.handleTouch) {
                  this.settings.el.addEventListener("touchstart", this._handleEntry, false);
                  this.settings.el.addEventListener("touchend", this._hide, false);
                  this.settings.el.addEventListener("touchmove", this._handleMovement, false);
                } else {
                  this.settings.el.addEventListener("touchstart", this._preventDefault, false);
                  this.settings.el.addEventListener("touchend", this._preventDefault, false);
                  this.settings.el.addEventListener("touchmove", this._preventDefault, false);
                }
              },
            },
            {
              key: "_unbindEvents",
              value: function _unbindEvents() {
                this.settings.el.removeEventListener("mouseenter", this._handleEntry, false);
                this.settings.el.removeEventListener("mouseleave", this._hide, false);
                this.settings.el.removeEventListener("mousemove", this._handleMovement, false);

                if (this.settings.handleTouch) {
                  this.settings.el.removeEventListener("touchstart", this._handleEntry, false);
                  this.settings.el.removeEventListener("touchend", this._hide, false);
                  this.settings.el.removeEventListener("touchmove", this._handleMovement, false);
                } else {
                  this.settings.el.removeEventListener("touchstart", this._preventDefault, false);
                  this.settings.el.removeEventListener("touchend", this._preventDefault, false);
                  this.settings.el.removeEventListener("touchmove", this._preventDefault, false);
                }
              },
            },
            {
              key: "_handleEntry",
              value: function _handleEntry(e) {
                this._preventDefaultAllowTouchScroll(e);

                this._lastMovement = e;

                if (e.type == "mouseenter" && this.settings.hoverDelay) {
                  this.entryTimeout = setTimeout(this._show, this.settings.hoverDelay);
                } else if (this.settings.touchDelay) {
                  this.entryTimeout = setTimeout(this._show, this.settings.touchDelay);
                } else {
                  this._show();
                }
              },
            },
            {
              key: "_show",
              value: function _show() {
                if (!this.enabled) {
                  return;
                }

                var onShow = this.settings.onShow;

                if (onShow && typeof onShow === "function") {
                  onShow();
                }

                this.settings.zoomPane.show(
                  this.settings.el.getAttribute(this.settings.sourceAttribute),
                  this.settings.el.clientWidth,
                  this.settings.el.clientHeight
                );

                if (this._lastMovement) {
                  var touchActivated = this._lastMovement.touches;

                  if (
                    (touchActivated && this.settings.touchBoundingBox) ||
                    (!touchActivated && this.settings.hoverBoundingBox)
                  ) {
                    this.boundingBox.show(
                      this.settings.zoomPane.el.clientWidth,
                      this.settings.zoomPane.el.clientHeight
                    );
                  }
                }

                this._handleMovement();
              },
            },
            {
              key: "_hide",
              value: function _hide(e) {
                if (e) {
                  this._preventDefaultAllowTouchScroll(e);
                }

                this._lastMovement = null;

                if (this.entryTimeout) {
                  clearTimeout(this.entryTimeout);
                }

                if (this.boundingBox) {
                  this.boundingBox.hide();
                }

                var onHide = this.settings.onHide;

                if (onHide && typeof onHide === "function") {
                  onHide();
                }

                this.settings.zoomPane.hide();
              },
            },
            {
              key: "_handleMovement",
              value: function _handleMovement(e) {
                if (e) {
                  this._preventDefaultAllowTouchScroll(e);

                  this._lastMovement = e;
                } else if (this._lastMovement) {
                  e = this._lastMovement;
                } else {
                  return;
                }

                var movementX;
                var movementY;

                if (e.touches) {
                  var firstTouch = e.touches[0];
                  movementX = firstTouch.clientX;
                  movementY = firstTouch.clientY;
                } else {
                  movementX = e.clientX;
                  movementY = e.clientY;
                }

                var el = this.settings.el;
                var rect = el.getBoundingClientRect();
                var offsetX = movementX - rect.left;
                var offsetY = movementY - rect.top;
                var percentageOffsetX = offsetX / this.settings.el.clientWidth;
                var percentageOffsetY = offsetY / this.settings.el.clientHeight;

                if (this.boundingBox) {
                  this.boundingBox.setPosition(percentageOffsetX, percentageOffsetY, rect);
                }

                this.settings.zoomPane.setPosition(percentageOffsetX, percentageOffsetY, rect);
              },
            },
            {
              key: "isShowing",
              get: function get() {
                return this.settings.zoomPane.isShowing;
              },
            },
          ]);

          return Trigger;
        })();

      //# sourceMappingURL=Trigger.js.map
      // CONCATENATED MODULE: ./node_modules/drift-zoom/es/ZoomPane.js
      function ZoomPane_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function ZoomPane_defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function ZoomPane_createClass(Constructor, protoProps, staticProps) {
        if (protoProps) ZoomPane_defineProperties(Constructor.prototype, protoProps);
        if (staticProps) ZoomPane_defineProperties(Constructor, staticProps);
        return Constructor;
      }

      // All officially-supported browsers have this, but it's easy to
      // account for, just in case.

      var divStyle = document.createElement("div").style;
      var HAS_ANIMATION =
        typeof document === "undefined" ? false : "animation" in divStyle || "webkitAnimation" in divStyle;

      var ZoomPane_ZoomPane =
        /*#__PURE__*/
        (function () {
          function ZoomPane() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            ZoomPane_classCallCheck(this, ZoomPane);

            this._completeShow = this._completeShow.bind(this);
            this._completeHide = this._completeHide.bind(this);
            this._handleLoad = this._handleLoad.bind(this);
            this.isShowing = false;
            var _options$container = options.container,
              container = _options$container === void 0 ? null : _options$container,
              _options$zoomFactor = options.zoomFactor,
              zoomFactor = _options$zoomFactor === void 0 ? throwIfMissing() : _options$zoomFactor,
              _options$inline = options.inline,
              inline = _options$inline === void 0 ? throwIfMissing() : _options$inline,
              _options$namespace = options.namespace,
              namespace = _options$namespace === void 0 ? null : _options$namespace,
              _options$showWhitespa = options.showWhitespaceAtEdges,
              showWhitespaceAtEdges = _options$showWhitespa === void 0 ? throwIfMissing() : _options$showWhitespa,
              _options$containInlin = options.containInline,
              containInline = _options$containInlin === void 0 ? throwIfMissing() : _options$containInlin,
              _options$inlineOffset = options.inlineOffsetX,
              inlineOffsetX = _options$inlineOffset === void 0 ? 0 : _options$inlineOffset,
              _options$inlineOffset2 = options.inlineOffsetY,
              inlineOffsetY = _options$inlineOffset2 === void 0 ? 0 : _options$inlineOffset2,
              _options$inlineContai = options.inlineContainer,
              inlineContainer = _options$inlineContai === void 0 ? document.body : _options$inlineContai;
            this.settings = {
              container: container,
              zoomFactor: zoomFactor,
              inline: inline,
              namespace: namespace,
              showWhitespaceAtEdges: showWhitespaceAtEdges,
              containInline: containInline,
              inlineOffsetX: inlineOffsetX,
              inlineOffsetY: inlineOffsetY,
              inlineContainer: inlineContainer,
            };
            this.openClasses = this._buildClasses("open");
            this.openingClasses = this._buildClasses("opening");
            this.closingClasses = this._buildClasses("closing");
            this.inlineClasses = this._buildClasses("inline");
            this.loadingClasses = this._buildClasses("loading");

            this._buildElement();
          }

          ZoomPane_createClass(ZoomPane, [
            {
              key: "_buildClasses",
              value: function _buildClasses(suffix) {
                var classes = ["drift-".concat(suffix)];
                var ns = this.settings.namespace;

                if (ns) {
                  classes.push("".concat(ns, "-").concat(suffix));
                }

                return classes;
              },
            },
            {
              key: "_buildElement",
              value: function _buildElement() {
                this.el = document.createElement("div");
                addClasses(this.el, this._buildClasses("zoom-pane"));
                var loaderEl = document.createElement("div");
                addClasses(loaderEl, this._buildClasses("zoom-pane-loader"));
                this.el.appendChild(loaderEl);
                this.imgEl = document.createElement("img");
                this.el.appendChild(this.imgEl);
              },
            },
            {
              key: "_setImageURL",
              value: function _setImageURL(imageURL) {
                this.imgEl.setAttribute("src", imageURL);
              },
            },
            {
              key: "_setImageSize",
              value: function _setImageSize(triggerWidth, triggerHeight) {
                this.imgEl.style.width = "".concat(triggerWidth * this.settings.zoomFactor, "px");
                this.imgEl.style.height = "".concat(triggerHeight * this.settings.zoomFactor, "px");
              }, // `percentageOffsetX` and `percentageOffsetY` must be percentages
              // expressed as floats between `0' and `1`.
            },
            {
              key: "setPosition",
              value: function setPosition(percentageOffsetX, percentageOffsetY, triggerRect) {
                var imgElWidth = this.imgEl.offsetWidth;
                var imgElHeight = this.imgEl.offsetHeight;
                var elWidth = this.el.offsetWidth;
                var elHeight = this.el.offsetHeight;
                var centreOfContainerX = elWidth / 2;
                var centreOfContainerY = elHeight / 2;
                var targetImgXToBeCentre = imgElWidth * percentageOffsetX;
                var targetImgYToBeCentre = imgElHeight * percentageOffsetY;
                var left = centreOfContainerX - targetImgXToBeCentre;
                var top = centreOfContainerY - targetImgYToBeCentre;
                var differenceBetweenContainerWidthAndImgWidth = elWidth - imgElWidth;
                var differenceBetweenContainerHeightAndImgHeight = elHeight - imgElHeight;
                var isContainerLargerThanImgX = differenceBetweenContainerWidthAndImgWidth > 0;
                var isContainerLargerThanImgY = differenceBetweenContainerHeightAndImgHeight > 0;
                var minLeft = isContainerLargerThanImgX ? differenceBetweenContainerWidthAndImgWidth / 2 : 0;
                var minTop = isContainerLargerThanImgY ? differenceBetweenContainerHeightAndImgHeight / 2 : 0;
                var maxLeft = isContainerLargerThanImgX
                  ? differenceBetweenContainerWidthAndImgWidth / 2
                  : differenceBetweenContainerWidthAndImgWidth;
                var maxTop = isContainerLargerThanImgY
                  ? differenceBetweenContainerHeightAndImgHeight / 2
                  : differenceBetweenContainerHeightAndImgHeight;

                if (this.el.parentElement === this.settings.inlineContainer) {
                  // This may be needed in the future to deal with browser event
                  // inconsistencies, but it's difficult to tell for sure.
                  // let scrollX = isTouch ? 0 : window.scrollX;
                  // let scrollY = isTouch ? 0 : window.scrollY;
                  var scrollX = window.pageXOffset;
                  var scrollY = window.pageYOffset;
                  var inlineLeft =
                    triggerRect.left +
                    percentageOffsetX * triggerRect.width -
                    elWidth / 2 +
                    this.settings.inlineOffsetX +
                    scrollX;
                  var inlineTop =
                    triggerRect.top +
                    percentageOffsetY * triggerRect.height -
                    elHeight / 2 +
                    this.settings.inlineOffsetY +
                    scrollY;

                  if (this.settings.containInline) {
                    if (inlineLeft < triggerRect.left + scrollX) {
                      inlineLeft = triggerRect.left + scrollX;
                    } else if (inlineLeft + elWidth > triggerRect.left + triggerRect.width + scrollX) {
                      inlineLeft = triggerRect.left + triggerRect.width - elWidth + scrollX;
                    }

                    if (inlineTop < triggerRect.top + scrollY) {
                      inlineTop = triggerRect.top + scrollY;
                    } else if (inlineTop + elHeight > triggerRect.top + triggerRect.height + scrollY) {
                      inlineTop = triggerRect.top + triggerRect.height - elHeight + scrollY;
                    }
                  }

                  this.el.style.left = "".concat(inlineLeft, "px");
                  this.el.style.top = "".concat(inlineTop, "px");
                }

                if (!this.settings.showWhitespaceAtEdges) {
                  if (left > minLeft) {
                    left = minLeft;
                  } else if (left < maxLeft) {
                    left = maxLeft;
                  }

                  if (top > minTop) {
                    top = minTop;
                  } else if (top < maxTop) {
                    top = maxTop;
                  }
                }

                this.imgEl.style.transform = "translate(".concat(left, "px, ").concat(top, "px)");
                this.imgEl.style.webkitTransform = "translate(".concat(left, "px, ").concat(top, "px)");
              },
            },
            {
              key: "_removeListenersAndResetClasses",
              value: function _removeListenersAndResetClasses() {
                this.el.removeEventListener("animationend", this._completeShow, false);
                this.el.removeEventListener("animationend", this._completeHide, false);
                this.el.removeEventListener("webkitAnimationEnd", this._completeShow, false);
                this.el.removeEventListener("webkitAnimationEnd", this._completeHide, false);
                removeClasses(this.el, this.openClasses);
                removeClasses(this.el, this.closingClasses);
              },
            },
            {
              key: "show",
              value: function show(imageURL, triggerWidth, triggerHeight) {
                this._removeListenersAndResetClasses();

                this.isShowing = true;
                addClasses(this.el, this.openClasses);

                if (this.imgEl.getAttribute("src") != imageURL) {
                  addClasses(this.el, this.loadingClasses);
                  this.imgEl.addEventListener("load", this._handleLoad, false);

                  this._setImageURL(imageURL);
                }

                this._setImageSize(triggerWidth, triggerHeight);

                if (this._isInline) {
                  this._showInline();
                } else {
                  this._showInContainer();
                }

                if (HAS_ANIMATION) {
                  this.el.addEventListener("animationend", this._completeShow, false);
                  this.el.addEventListener("webkitAnimationEnd", this._completeShow, false);
                  addClasses(this.el, this.openingClasses);
                }
              },
            },
            {
              key: "_showInline",
              value: function _showInline() {
                this.settings.inlineContainer.appendChild(this.el);
                addClasses(this.el, this.inlineClasses);
              },
            },
            {
              key: "_showInContainer",
              value: function _showInContainer() {
                this.settings.container.appendChild(this.el);
              },
            },
            {
              key: "hide",
              value: function hide() {
                this._removeListenersAndResetClasses();

                this.isShowing = false;

                if (HAS_ANIMATION) {
                  this.el.addEventListener("animationend", this._completeHide, false);
                  this.el.addEventListener("webkitAnimationEnd", this._completeHide, false);
                  addClasses(this.el, this.closingClasses);
                } else {
                  removeClasses(this.el, this.openClasses);
                  removeClasses(this.el, this.inlineClasses);
                }
              },
            },
            {
              key: "_completeShow",
              value: function _completeShow() {
                this.el.removeEventListener("animationend", this._completeShow, false);
                this.el.removeEventListener("webkitAnimationEnd", this._completeShow, false);
                removeClasses(this.el, this.openingClasses);
              },
            },
            {
              key: "_completeHide",
              value: function _completeHide() {
                this.el.removeEventListener("animationend", this._completeHide, false);
                this.el.removeEventListener("webkitAnimationEnd", this._completeHide, false);
                removeClasses(this.el, this.openClasses);
                removeClasses(this.el, this.closingClasses);
                removeClasses(this.el, this.inlineClasses);
                this.el.setAttribute("style", ""); // The window could have been resized above or below `inline`
                // limits since the ZoomPane was shown. Because of this, we
                // can't rely on `this._isInline` here.

                if (this.el.parentElement === this.settings.container) {
                  this.settings.container.removeChild(this.el);
                } else if (this.el.parentElement === this.settings.inlineContainer) {
                  this.settings.inlineContainer.removeChild(this.el);
                }
              },
            },
            {
              key: "_handleLoad",
              value: function _handleLoad() {
                this.imgEl.removeEventListener("load", this._handleLoad, false);
                removeClasses(this.el, this.loadingClasses);
              },
            },
            {
              key: "_isInline",
              get: function get() {
                var inline = this.settings.inline;
                return inline === true || (typeof inline === "number" && window.innerWidth <= inline);
              },
            },
          ]);

          return ZoomPane;
        })();

      //# sourceMappingURL=ZoomPane.js.map
      // CONCATENATED MODULE: ./node_modules/drift-zoom/es/Drift.js
      function Drift_classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function Drift_defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function Drift_createClass(Constructor, protoProps, staticProps) {
        if (protoProps) Drift_defineProperties(Constructor.prototype, protoProps);
        if (staticProps) Drift_defineProperties(Constructor, staticProps);
        return Constructor;
      }

      var Drift_Drift =
        /*#__PURE__*/
        (function () {
          function Drift(triggerEl) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            Drift_classCallCheck(this, Drift);

            this.VERSION = "1.4.0";
            this.triggerEl = triggerEl;
            this.destroy = this.destroy.bind(this);

            if (!isDOMElement(this.triggerEl)) {
              throw new TypeError("`new Drift` requires a DOM element as its first argument.");
            } // Prefix for generated element class names (e.g. `my-ns` will
            // result in classes such as `my-ns-pane`. Default `drift-`
            // prefixed classes will always be added as well.

            var namespace = options["namespace"] || null; // Whether the ZoomPane should show whitespace when near the edges.

            var showWhitespaceAtEdges = options["showWhitespaceAtEdges"] || false; // Whether the inline ZoomPane should stay inside
            // the bounds of its image.

            var containInline = options["containInline"] || false; // How much to offset the ZoomPane from the
            // interaction point when inline.

            var inlineOffsetX = options["inlineOffsetX"] || 0;
            var inlineOffsetY = options["inlineOffsetY"] || 0; // A DOM element to append the inline ZoomPane to

            var inlineContainer = options["inlineContainer"] || document.body; // Which trigger attribute to pull the ZoomPane image source from.

            var sourceAttribute = options["sourceAttribute"] || "data-zoom"; // How much to magnify the trigger by in the ZoomPane.
            // (e.g., `zoomFactor: 3` will result in a 900 px wide ZoomPane imag
            // if the trigger is displayed at 300 px wide)

            var zoomFactor = options["zoomFactor"] || 3; // A DOM element to append the non-inline ZoomPane to.
            // Required if `inlinePane !== true`.

            var paneContainer = options["paneContainer"] === undefined ? document.body : options["paneContainer"]; // When to switch to an inline ZoomPane. This can be a boolean or
            // an integer. If `true`, the ZoomPane will always be inline,
            // if `false`, it will switch to inline when `windowWidth <= inlinePane`

            var inlinePane = options["inlinePane"] || 375; // If `true`, touch events will trigger the zoom, like mouse events.

            var handleTouch = "handleTouch" in options ? !!options["handleTouch"] : true; // If present (and a function), this will be called
            // whenever the ZoomPane is shown.

            var onShow = options["onShow"] || null; // If present (and a function), this will be called
            // whenever the ZoomPane is hidden.

            var onHide = options["onHide"] || null; // Add base styles to the page. See the "Theming"
            // section of README.md for more information.

            var injectBaseStyles = "injectBaseStyles" in options ? !!options["injectBaseStyles"] : true; // An optional number that determines how long to wait before
            // showing the ZoomPane because of a `mouseenter` event.

            var hoverDelay = options["hoverDelay"] || 0; // An optional number that determines how long to wait before
            // showing the ZoomPane because of a `touchstart` event.
            // It's unlikely that you would want to use this option, since
            // "tap and hold" is much more intentional than a hover event.

            var touchDelay = options["touchDelay"] || 0; // If true, a bounding box will show the area currently being previewed
            // during mouse hover

            var hoverBoundingBox = options["hoverBoundingBox"] || false; // If true, a bounding box will show the area currently being previewed
            // during touch events

            var touchBoundingBox = options["touchBoundingBox"] || false; // A DOM element to append the bounding box to.

            var boundingBoxContainer = options["boundingBoxContainer"] || document.body;

            if (inlinePane !== true && !isDOMElement(paneContainer)) {
              throw new TypeError("`paneContainer` must be a DOM element when `inlinePane !== true`");
            }

            if (!isDOMElement(inlineContainer)) {
              throw new TypeError("`inlineContainer` must be a DOM element");
            }

            this.settings = {
              namespace: namespace,
              showWhitespaceAtEdges: showWhitespaceAtEdges,
              containInline: containInline,
              inlineOffsetX: inlineOffsetX,
              inlineOffsetY: inlineOffsetY,
              inlineContainer: inlineContainer,
              sourceAttribute: sourceAttribute,
              zoomFactor: zoomFactor,
              paneContainer: paneContainer,
              inlinePane: inlinePane,
              handleTouch: handleTouch,
              onShow: onShow,
              onHide: onHide,
              injectBaseStyles: injectBaseStyles,
              hoverDelay: hoverDelay,
              touchDelay: touchDelay,
              hoverBoundingBox: hoverBoundingBox,
              touchBoundingBox: touchBoundingBox,
              boundingBoxContainer: boundingBoxContainer,
            };

            if (this.settings.injectBaseStyles) {
              injectBaseStylesheet();
            }

            this._buildZoomPane();

            this._buildTrigger();
          }

          Drift_createClass(Drift, [
            {
              key: "_buildZoomPane",
              value: function _buildZoomPane() {
                this.zoomPane = new ZoomPane_ZoomPane({
                  container: this.settings.paneContainer,
                  zoomFactor: this.settings.zoomFactor,
                  showWhitespaceAtEdges: this.settings.showWhitespaceAtEdges,
                  containInline: this.settings.containInline,
                  inline: this.settings.inlinePane,
                  namespace: this.settings.namespace,
                  inlineOffsetX: this.settings.inlineOffsetX,
                  inlineOffsetY: this.settings.inlineOffsetY,
                  inlineContainer: this.settings.inlineContainer,
                });
              },
            },
            {
              key: "_buildTrigger",
              value: function _buildTrigger() {
                this.trigger = new Trigger_Trigger({
                  el: this.triggerEl,
                  zoomPane: this.zoomPane,
                  handleTouch: this.settings.handleTouch,
                  onShow: this.settings.onShow,
                  onHide: this.settings.onHide,
                  sourceAttribute: this.settings.sourceAttribute,
                  hoverDelay: this.settings.hoverDelay,
                  touchDelay: this.settings.touchDelay,
                  hoverBoundingBox: this.settings.hoverBoundingBox,
                  touchBoundingBox: this.settings.touchBoundingBox,
                  namespace: this.settings.namespace,
                  zoomFactor: this.settings.zoomFactor,
                  boundingBoxContainer: this.settings.boundingBoxContainer,
                });
              },
            },
            {
              key: "setZoomImageURL",
              value: function setZoomImageURL(imageURL) {
                this.zoomPane._setImageURL(imageURL);
              },
            },
            {
              key: "disable",
              value: function disable() {
                this.trigger.enabled = false;
              },
            },
            {
              key: "enable",
              value: function enable() {
                this.trigger.enabled = true;
              },
            },
            {
              key: "destroy",
              value: function destroy() {
                this.trigger._hide();

                this.trigger._unbindEvents();
              },
            },
            {
              key: "isShowing",
              get: function get() {
                return this.zoomPane.isShowing;
              },
            },
            {
              key: "zoomFactor",
              get: function get() {
                return this.settings.zoomFactor;
              },
              set: function set(zf) {
                this.settings.zoomFactor = zf;
                this.zoomPane.settings.zoomFactor = zf;
                this.trigger.settings.zoomFactor = zf;
                this.boundingBox.settings.zoomFactor = zf;
              },
            },
          ]);

          return Drift;
        })(); // Public API

      /* eslint-disable no-self-assign */

      Object.defineProperty(Drift_Drift.prototype, "isShowing", {
        get: function get() {
          return this.isShowing;
        },
      });
      Object.defineProperty(Drift_Drift.prototype, "zoomFactor", {
        get: function get() {
          return this.zoomFactor;
        },
        set: function set(value) {
          this.zoomFactor = value;
        },
      });
      Drift_Drift.prototype["setZoomImageURL"] = Drift_Drift.prototype.setZoomImageURL;
      Drift_Drift.prototype["disable"] = Drift_Drift.prototype.disable;
      Drift_Drift.prototype["enable"] = Drift_Drift.prototype.enable;
      Drift_Drift.prototype["destroy"] = Drift_Drift.prototype.destroy;
      /* eslint-enable no-self-assign */
      //# sourceMappingURL=Drift.js.map
      // CONCATENATED MODULE: ./app/scripts/_arn.js

      var _settings;

      window.lazySizesConfig = window.lazySizesConfig || {};
      lazySizesConfig.loadHidden = false;
      lazySizesConfig.loadMode = 1;

      window.lazySizesConfig.getOptimumX = function (_element) {
        return window.devicePixelRatio > 1.6 ? devicePixelRatio * 0.9 : 1;
      };

      var oldWidth = 0,
        dialog = {
          error: "#errorNotify",
        };
      var AT_Main = {
        onClick: function onClick(className, callBack) {
          var container = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
          var target = container.querySelectorAll(className);
          target.length &&
            target.forEach(function (el, index) {
              el.addEventListener("click", callBack);
            });
        },
        isExist: function isExist(element) {
          return element == null || typeof element == "undefined" ? false : true;
        },
        getWidthBrowser: function getWidthBrowser() {
          /*Get width browser*/
          var myWidth;

          if (typeof window.innerWidth == "number") {
            /*Non-IE*/
            myWidth = window.innerWidth;
          } else if (
            document.documentElement &&
            (document.documentElement.clientWidth || document.documentElement.clientHeight)
          ) {
            /*IE 6+ in 'standards compliant mode'*/
            myWidth = document.documentElement.clientWidth;
          } else if (document.body && (document.body.clientWidth || document.body.clientHeight)) {
            /*IE 4 compatible*/
            myWidth = document.body.clientWidth;
          }

          return myWidth;
        },
        getHeightBrowser: function getHeightBrowser() {
          /*Get height browser*/
          var result;

          if (typeof window.innerHeight == "number") {
            /*Non-IE*/
            result = window.innerHeight;
          } else if (
            document.documentElement &&
            (document.documentElement.clientWidth || document.documentElement.clientHeight)
          ) {
            /*IE 6+ in 'standards compliant mode'*/
            result = document.documentElement.clientHeight;
          } else if (document.body && (document.body.clientWidth || document.body.clientHeight)) {
            /*IE 4 compatible*/
            result = document.body.clientHeight;
          }

          return result;
        },
        debounceTime: function debounceTime(time, func) {
          var timeout;
          return function () {
            var context = this,
              args = arguments;

            var excuteFn = function excuteFn() {
              func.apply(context, args);
            };

            clearTimeout(timeout);
            timeout = setTimeout(excuteFn, time);
          };
        },
        fadeIn: function fadeIn(elem) {
          var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 400;
          if (!elem) return;
          elem.style.opacity = 0;
          elem.style.filter = "alpha(opacity=0)";
          elem.style.display = "inline-block";
          elem.style.visibility = "visible";

          if (ms) {
            var opacity = 0;
            var timer = setInterval(function () {
              opacity += 50 / ms;

              if (opacity >= 1) {
                clearInterval(timer);
                opacity = 1;
              }

              elem.style.opacity = opacity;
              elem.style.filter = "alpha(opacity=" + opacity * 100 + ")";
            }, 50);
          } else {
            elem.style.opacity = 1;
            elem.style.filter = "alpha(opacity=1)";
          }
        },
        fadeOut: function fadeOut(elem) {
          var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 400;
          if (!elem) return;

          if (ms) {
            var opacity = 1;
            var timer = setInterval(function () {
              opacity -= 50 / ms;

              if (opacity <= 0) {
                clearInterval(timer);
                opacity = 0;
                elem.style.display = "none";
                elem.style.visibility = "hidden";
              }

              elem.style.opacity = opacity;
              elem.style.filter = "alpha(opacity=" + opacity * 100 + ")";
            }, 50);
          } else {
            elem.style.opacity = 0;
            elem.style.filter = "alpha(opacity=0)";
            elem.style.display = "none";
            elem.style.visibility = "hidden";
          }
        },
        detectDeviceType: function detectDeviceType() {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
            ? "Mobile"
            : "Desktop";
        },
        scrollBarWidth: function scrollBarWidth() {
          var _document$body$getBou = document.body.getBoundingClientRect(),
            left = _document$body$getBou.left,
            right = _document$body$getBou.right;

          if (left + right < window.innerWidth) return window.innerWidth - (left + right);
          return 0;
        },
        initDialog: function initDialog() {
          AT_Main.onClick("[data-dialog-trigger]", function (e) {
            var _this = e.currentTarget,
              value = _this.getAttribute("data-dialog-trigger"),
              _target = document.querySelector(value);

            if (!AT_Main.isExist(_target)) {
              return;
            }

            _target.classList.toggle("is-open");

            if (!_target.classList.contains("is-open")) {
              return;
            }

            AT_Main.disablePageScroll(true);
            /***
             *
             * Search Dialog
             *
             ***/

            if (value == AT_Search.settings.searchDialog) {
              _target.querySelector('input[name="q"]').focus();
            }
          });
          AT_Main.onClick("[data-dialog-close]", function (e) {
            var _this = e.currentTarget,
              _target = _this.closest("dialog");

            if (!AT_Main.isExist(_target)) {
              return;
            }

            _target.classList.remove("is-open");

            AT_Main.disablePageScroll(false);
          });
        },
        triggerDialog: function triggerDialog(target) {
          var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "show";

          var _target = document.querySelector(target);

          if (!AT_Main.isExist(_target)) {
            return;
          }

          if (method == "show") {
            document.querySelectorAll("dialog.is-open, .cart-drawer.active").length &&
              document.querySelectorAll("dialog.is-open, .cart-drawer.active").forEach(function (element) {
                element.classList.remove("is-open", "active");
              });

            _target.classList.add("is-open");

            _target.classList.contains("is-open") && AT_Main.disablePageScroll(true);
          }

          if (method == "close") {
            _target.classList.remove("is-open");

            AT_Main.disablePageScroll(false);
          }
        },
        tabPanel_init: function tabPanel_init() {
          var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          var $container = container || document;
          $container.querySelectorAll(".featured_group_tab-ui .featured_group_tab-pane").forEach(function (e, i) {});
          AT_Main.onClick(".featured_group_tab-ui .featured_group_tab-link a", function (e) {
            e.preventDefault();

            var _this = e.currentTarget,
              _target = $container.querySelector(_this.getAttribute("href"));

            if (_this.closest(".featured_group_tab-link").classList.contains("active") || !AT_Main.isExist(_target)) {
              return;
            }

            var paneParent = _target.closest(".featured_group_tab-ui");

            paneParent
              .querySelectorAll(".featured_group_tab-pane.active, .featured_group_tab-link.active")
              .forEach(function (e, i) {
                e.classList.remove("active");
              });

            _this.closest(".featured_group_tab-link").classList.add("active");

            _target.classList.add("active");
          });
        },
        initSlideShow: function initSlideShow($container) {
          var ss = $container,
            sliderTNS,
            slideItem = ss.querySelectorAll(".slide-item"),
            slideConfig = ss.querySelector('input[name="slideConfig"]'),
            loop = false,
            autoplay = false,
            autoplayTimeout = 5000,
            animateIn = "tns-fadeIn",
            animateOut = "tns-fadeOut",
            speed = 300;

          if (slideItem.length > 1) {
            if (typeof slideConfig != "undefined") {
              loop = JSON.parse(slideConfig.getAttribute("data-loop"));
              autoplayTimeout = +(slideConfig.getAttribute("data-autoplay") || "0");
              autoplay = autoplayTimeout > 0 ? true : false;
            }

            sliderTNS = tns({
              container: ss.querySelector(".slideshow-wrapper"),
              items: 1,
              slideBy: 1,
              startIndex: 0,
              nav: false,
              autoplayHoverPause: true,
              loop: loop,
              speed: speed,
              autoplayButtonOutput: false,
              autoplay: autoplay,
              autoplayTimeout: autoplayTimeout,
              controlsPosition: "bottom",
              controlsContainer: ss.querySelector(".slideshow-controls"),
              animateIn: animateIn,
              animateOut: animateOut,
              preventActionWhenRunning: true,
            });
            slideItem.forEach(function (v, i) {
              v.addEventListener("shopify:block:select", function (e) {
                var index = +v.getAttribute("data-index");
                sliderTNS.goTo(index);
              });
            });
          }
        },
        initSlider: function initSlider(container) {
          var ss = container,
            conf = ss.querySelector('input[name="sectionSlideConfig"]'),
            target = ss.querySelectorAll(".slide_ui-element");

          if (!AT_Main.isExist(target) || !AT_Main.isExist(conf)) {
            return;
          }

          var autoplay = false,
            autoplayTimeout = 5000,
            center = false,
            animateIn = "tns-fadeIn",
            animateOut = "tns-fadeOut",
            speed = 300,
            edgePadding = 0,
            controls = conf.getAttribute("data-nav") ? JSON.parse(conf.getAttribute("data-nav")) : false,
            nav = conf.getAttribute("data-dot") ? JSON.parse(conf.getAttribute("data-dot")) : false,
            loop = conf.getAttribute("data-loop") ? JSON.parse(conf.getAttribute("data-loop")) : false,
            autoWidth = conf.getAttribute("data-auto-width") ? JSON.parse(conf.getAttribute("data-auto-width")) : false,
            items = conf.getAttribute("data-items").split(","),
            gutters = conf.getAttribute("data-gutters") || "",
            itemClass = conf.getAttribute("data-item-class");
          gutters = gutters.replace(/[^\d.,]/g, "").split(",");
          target.forEach(function (v, i) {
            var wrapper = v.closest("div[data-slide-wrapper]") || ss;
            v.classList.contains("slide_mobile-center") && (center = true);
            v.classList.remove("row", "d-grid");
            var responsive = {
              0: {
                items: +items[5] || +items[0],
                gutter: +gutters[5] || +gutters[0],
                center: center,
              },
              375: {
                items: +items[4] || +items[0],
                gutter: +gutters[4] || +gutters[0],
                center: center,
              },
              576: {
                items: +items[3] || +items[0],
                gutter: +gutters[3] || +gutters[0],
                center: center,
              },
              768: {
                items: +items[2] || +items[0],
                gutter: +gutters[2] || +gutters[0],
                center: false,
              },
              992: {
                items: +items[1] || +items[0],
                gutter: +gutters[1] || +gutters[0],
                center: false,
              },
              1200: {
                items: +items[0] || +items[0],
                gutter: +gutters[0] || +gutters[0],
                center: false,
              },
            };

            if (itemClass != "") {
              for (var i = 0; i < v.children.length; i++) {
                v.children[i].className = itemClass;
              }
            }

            if (ss.getAttribute("data-section-type") == "featured-testimonials") {
              edgePadding = +window.getComputedStyle(ss, null).getPropertyValue("padding-left").replace("px", "");
              ss.style.paddingLeft = 0;
            }

            var sliderTNS = tns({
              container: v,
              items: items[5],
              slideBy: "page",
              startIndex: 0,
              loop: loop,
              speed: speed,
              autoWidth: autoWidth,
              edgePadding: edgePadding,
              mouseDrag: true,
              swipeAngle: 30,
              autoplayButtonOutput: false,
              autoplay: autoplay,
              autoplayTimeout: autoplayTimeout,
              animateIn: animateIn,
              animateOut: animateOut,
              controls: controls,
              controlsPosition: "bottom",
              controlsContainer: wrapper.querySelector(".slide_ui-controls--nav"),
              nav: nav,
              navPosition: "bottom",
              responsive: responsive,
              preventActionWhenRunning: true,
              onInit: function onInit() {
                if (AT_Main.isExist(container.querySelector(".tns-nav"))) {
                  container.querySelector(".tns-nav").classList.add("slide_ui-controls", "slide_ui-controls--dot");
                }

                if (ss.getAttribute("data-section-type") == "featured-testimonials") {
                  window.addEventListener("resize", function () {
                    ss.style.paddingLeft = null;
                    var paddingLeft = +window
                        .getComputedStyle(ss, null)
                        .getPropertyValue("padding-left")
                        .replace("px", ""),
                      paddingRight = +window
                        .getComputedStyle(ss, null)
                        .getPropertyValue("padding-right")
                        .replace("px", "");
                    ss.querySelector(".tns-inner").style.marginLeft = paddingLeft;
                    ss.querySelector(".tns-inner").style.marginRight = paddingRight;
                    ss.style.paddingLeft = 0;
                  });
                }
              },
            });
            sliderTNS.events.on("dragMove", function (info, eventName) {
              v.classList.add("is-sliding");
            });
            sliderTNS.events.on("dragEnd", function (info, eventName) {
              v.classList.remove("is-sliding");
            });
          });
        },
        initSlider_forGallery: function initSlider_forGallery(container) {
          var ss = container,
            conf = ss.querySelector('input[name="sectionSlideConfig"]'),
            target = ss.querySelectorAll(".slide_ui-element");

          if (!AT_Main.isExist(target) || !AT_Main.isExist(conf)) {
            return;
          }

          var autoplay = false,
            autoplayTimeout = 5000,
            animateIn = "tns-fadeIn",
            animateOut = "tns-fadeOut",
            speed = 700,
            controls = conf.getAttribute("data-nav") ? JSON.parse(conf.getAttribute("data-nav")) : false,
            nav = conf.getAttribute("data-dot") ? JSON.parse(conf.getAttribute("data-dot")) : false,
            loop = conf.getAttribute("data-loop") ? JSON.parse(conf.getAttribute("data-loop")) : false,
            autoWidth = conf.getAttribute("data-auto-width") ? JSON.parse(conf.getAttribute("data-auto-width")) : false,
            _autoWidth = autoWidth,
            items = conf.getAttribute("data-items").split(","),
            gutters = conf.getAttribute("data-gutters") || "",
            itemClass = conf.getAttribute("data-item-class");
          gutters = gutters.replace(/[^\d.,]/g, "").split(",");
          var responsive = {
            0: {
              items: +items[5] || +items[0],
              gutter: +gutters[5] || +gutters[0],
            },
            375: {
              items: +items[4] || +items[0],
              gutter: +gutters[4] || +gutters[0],
            },
            576: {
              items: +items[3] || +items[0],
              gutter: +gutters[3] || +gutters[0],
            },
            768: {
              items: +items[2] || +items[0],
              gutter: +gutters[2] || +gutters[0],
            },
            992: {
              items: +items[1] || +items[0],
              gutter: +gutters[1] || +gutters[0],
            },
            1200: {
              items: +items[0] || +items[0],
              gutter: +gutters[0] || +gutters[0],
            },
          };
          _autoWidth = false; // if(autoWidth && AT_Main.getWidthBrowser() < 992){_autoWidth = false;}

          target.forEach(function (v, i) {
            if (itemClass != "") {
              for (var i = 0; i < v.children.length; i++) {
                v.children[i].className = itemClass;
              }
            } // v.classList.remove('row','d-grid');

            var wrapper = v.closest("div[data-slide-wrapper]") || ss;
            var sliderTNS = tns({
              container: v,
              autoWidth: _autoWidth,
              items: items[5],
              slideBy: 1,
              startIndex: 0,
              loop: loop,
              speed: speed,
              mouseDrag: true,
              swipeAngle: 30,
              autoplayButtonOutput: false,
              autoplay: autoplay,
              autoplayTimeout: autoplayTimeout,
              animateIn: animateIn,
              animateOut: animateOut,
              controls: controls,
              controlsPosition: "bottom",
              controlsContainer: wrapper.querySelector(".slide_ui-controls--nav"),
              nav: nav,
              navPosition: "bottom",
              responsive: responsive,
              preventActionWhenRunning: true,
              onInit: function onInit() {
                if (AT_Main.isExist(container.querySelector(".tns-nav"))) {
                  container.querySelector(".tns-nav").classList.add("slide_ui-controls", "slide_ui-controls--dot");
                }
              },
            });
            sliderTNS.events.on("transitionStart", function (info, eventName) {
              v.classList.add("is-sliding");
            });
            sliderTNS.events.on("transitionEnd", function (info, eventName) {
              v.classList.remove("is-sliding");
            });
          });
        },
        escape: function escape(text) {
          return text.replace(/[<>\&\"\']/g, function (c) {
            return "&#" + c.charCodeAt(0) + ";";
          });
        },
        handle: function handle(text) {
          return text
            .toLowerCase()
            .replace(/[^\w\s.\//]/gi, "")
            .trim()
            .replace(/[\s.\//]/g, "-");
        },
        removeSquareBracket: function removeSquareBracket(text) {
          return text.replace(/\[|\]/g, "");
        },
        setCookie: function setCookie(cname, cvalue, exdays) {
          var d = new Date(),
            end;
          d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);
          var expires = "expires=" + d.toUTCString();
          document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
        },
        getCookie: function getCookie(name) {
          var dc = document.cookie,
            prefix = name + "=",
            begin = dc.indexOf("; " + prefix);

          if (begin == -1) {
            begin = dc.indexOf(prefix);
            if (begin != 0) return null;
          } else {
            begin += 2;
            end = document.cookie.indexOf(";", begin);

            if (end == -1) {
              end = dc.length;
            }
          }

          return decodeURI(dc.substring(begin + prefix.length, end));
        },
        clickModal: function clickModal(target, $container) {
          AT_Main.isExist(target) &&
            target.addEventListener("click", function (e) {
              e.preventDefault();

              var _id = e.currentTarget.getAttribute("data-target") || "";

              var target = $container.querySelector(_id);

              if (_id == "" || !AT_Main.isExist(target)) {
                return;
              }

              if (target.classList.contains("active")) {
                target.classList.remove("active");
                AT_Main.disablePageScroll(false);
              } else {
                target.classList.add("active");
                AT_Main.disablePageScroll(true);
              }
            });
        },
        closeModal: function closeModal(target) {
          if (!AT_Main.isExist(target)) {
            return;
          }

          target.addEventListener("click", function (e) {
            e.preventDefault();

            var _id = e.currentTarget.getAttribute("data-parent") || "";

            var target = e.currentTarget.closest(_id);

            if (_id == "" || !AT_Main.isExist(target)) {
              return;
            }

            target.classList.remove("active");
            AT_Main.disablePageScroll(false);
          });
        },
        disablePageScroll: function disablePageScroll(bool) {
          var _document$body$classL2;

          var bodyExtendClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var bodyClass = [];
          bodyClass.push("modal-opened");
          bodyExtendClass != null && bodyClass.push(bodyExtendClass);

          if (bool) {
            var _document$body$classL;

            document.body.style.setProperty("padding-right", AT_Main.scrollBarWidth() + "px");

            (_document$body$classL = document.body.classList).add.apply(_document$body$classL, bodyClass);

            return;
          }

          document.body.style.removeProperty("padding-right");

          (_document$body$classL2 = document.body.classList).remove.apply(_document$body$classL2, bodyClass);

          return;
        },
        header: function header(container) {
          AT_Main.header.setStickyHeight = function () {};

          var headerSticky = container.querySelector(".header-sticky"),
            targetHeight = container.querySelector("[data-sticky-height]") || headerSticky;

          if (!AT_Main.isExist(headerSticky)) {
            return;
          }

          var headerPos = container.offsetTop + 100,
            setMinHeight = true;
          ((container.classList.contains("h-desk-overlay") && AT_Main.getWidthBrowser() > 991) ||
            (container.classList.contains("h-mobi-overlay") && AT_Main.getWidthBrowser() < 992)) &&
            (setMinHeight = false);
          setMinHeight && container.style.setProperty("min-height", "".concat(targetHeight.clientHeight, "px"));
          window.addEventListener("scroll", function (e) {
            var scrollTop = window.scrollY;

            if (scrollTop > headerPos) {
              headerSticky.classList.add("active");
            } else {
              headerSticky.classList.remove("active");
            }
          });
        },
        mobileBar: function mobileBar() {
          var mobileTarget = document.getElementById("mobile-bar");

          function __handle() {
            if (AT_Main.getWidthBrowser() >= 992) {
              return;
            }

            var scrollTop = window.scrollY + AT_Main.getHeightBrowser(),
              bodyHeight = document.body.clientHeight;

            if (scrollTop > bodyHeight - 100) {
              mobileTarget.classList.add("d-none");
            } else {
              mobileTarget.classList.remove("d-none");
            }
          }

          window.addEventListener("scroll", __handle);
          window.addEventListener("resize", __handle);
        },
        menuMobile: function menuMobile() {
          document.querySelectorAll(".hamburger-btn").length &&
            document.querySelectorAll(".hamburger-btn").forEach(function (v, i) {
              v.addEventListener("click", function (e) {
                e.preventDefault();

                var _this = e.currentTarget,
                  _id = _this.getAttribute("data-target") || "",
                  target = document.querySelector(_id);

                if (_id == "" || !AT_Main.isExist(target)) {
                  return;
                }

                if (target.classList.contains("active")) {
                  target.classList.remove("active");
                  AT_Main.disablePageScroll(false, "menuMobile-is-active");
                } else {
                  target.classList.add("active");
                  AT_Main.disablePageScroll(true, "menuMobile-is-active");
                }
              });
            });
          var closeMenu = document.querySelector(".menuMobile-close");

          if (AT_Main.isExist(closeMenu)) {
            closeMenu.addEventListener("click", function (e) {
              e.preventDefault();

              var _id = e.currentTarget.getAttribute("data-parent") || "";

              var target = e.currentTarget.closest(_id);

              if (_id == "" || !AT_Main.isExist(target)) {
                return;
              }

              target.classList.remove("active");
              AT_Main.disablePageScroll(false, "menuMobile-is-active");
            });
            window.addEventListener("resize", function (e) {
              AT_Main.getWidthBrowser() > 991 &&
                AT_Main.isExist(document.querySelector("#menuMobile.active")) &&
                closeMenu.click();
            });
          }

          var menuMobile = document.querySelector("#menuMobile");

          if (!AT_Main.isExist(menuMobile)) {
            return;
          }

          menuMobile.querySelectorAll("[data-submenu-link]").length &&
            menuMobile.querySelectorAll("[data-submenu-link]").forEach(function (element, index) {
              element.addEventListener("click", function (e) {
                var _this = e.currentTarget,
                  handle = _this.getAttribute("data-submenu-link"),
                  target = menuMobile.querySelector('[data-target="'.concat(handle, '"]'));

                if (!AT_Main.isExist(target)) {
                  return;
                }

                AT_Main.isExist(_this.closest(".mobile-layer.active")) &&
                  !_this.closest(".mobile-layer.active").classList.contains("main-layer") &&
                  _this.closest(".mobile-layer.active").classList.add("sub-opened");

                _this.closest(".mobile-layer").classList.remove("active");

                target.classList.add("active");
                target.classList.remove("hide");
              });
            });
          menuMobile.querySelectorAll(".mobile-layer").length &&
            menuMobile.querySelectorAll(".mobile-layer").forEach(function (element, index) {
              AT_Main.isExist(element.querySelector(".mobile-layer-title")) &&
                element.querySelector(".mobile-layer-title").addEventListener("click", function (e) {
                  var _this = e.currentTarget;

                  _this.closest(".mobile-layer").classList.remove("active");

                  if (AT_Main.isExist(menuMobile.querySelector(".sub-opened"))) {
                    menuMobile.querySelector(".sub-opened").classList.add("active");
                    menuMobile.querySelector(".sub-opened").classList.remove("sub-opened");
                  } else {
                    menuMobile.querySelectorAll(".mobile-layer")[0].classList.add("active");
                  }
                });
            });
        },
        megaMega_setPosition: function megaMega_setPosition() {
          var header = document.querySelector("#header-style"),
            target = header.querySelector(".horizontal-menu"),
            megaTarget = document.querySelector(".shopify-mega-menu");

          if (!AT_Main.isExist(target) || AT_Main.getWidthBrowser() < 992) {
            return;
          }

          var position = target.getBoundingClientRect(),
            top = position.top + position.height + (window.pageYOffset || document.documentElement.scrollTop);

          if (header.classList.contains("header-sticky") && header.classList.contains("active")) {
            top = position.top + target.clientHeight;
            megaTarget.classList.add("mega-sticky");
          } else {
            megaTarget.classList.remove("mega-sticky");
          }

          megaTarget.style.setProperty("top", top + "px");
          var overlay = document.querySelector("style#megaOverlayStyle");
          AT_Main.isExist(overlay) && overlay.remove();
          var overlayStyle = document.createElement("style");
          overlayStyle.id = "megaOverlayStyle";
          overlayStyle.innerHTML = ".boxed-wrapper:after{top: ".concat(top, "px;}");
          document.body.appendChild(overlayStyle);
        },
        initMegaMenu: function initMegaMenu() {
          var li = document.querySelectorAll("#header-style li.main-nav__item"),
            megaTarget = document.querySelector(".shopify-mega-menu"),
            megaBlock = document.querySelectorAll("[mega-block-target]");

          if (!AT_Main.isExist(megaTarget) || !megaBlock.length) {
            return;
          }

          megaTarget.addEventListener("mouseenter", function (e) {
            if (AT_Main.getWidthBrowser() < 992) {
              return;
            }

            megaTarget.classList.add("is-hover", "active");
            document.body.classList.add("megamenu-is-hover");
          });
          megaTarget.addEventListener("mouseleave", function (e) {
            if (AT_Main.getWidthBrowser() < 992) {
              return;
            }

            if (!megaTarget.classList.contains("is-live")) {
              megaTarget.classList.remove("is-hover", "active");
              document.body.classList.remove("megamenu-is-hover");
            }
          });
          li.length &&
            li.forEach(function (i) {
              i.addEventListener("mouseenter", function (e) {
                var value = e.currentTarget.querySelectorAll("a > span:not(.svg-element-ui)")[0].innerHTML || "";
                var currentActive = megaTarget.querySelectorAll(".mega-menu_desktop .mega-block.active");
                currentActive.length &&
                  currentActive.forEach(function (m) {
                    m.classList.remove("active");
                  });
                megaBlock.forEach(function (m) {
                  if (m.innerHTML == value) {
                    AT_Main.megaMega_setPosition();
                    m.closest(".mega-block").classList.add("active");
                    megaTarget.classList.add("active");
                    document.body.classList.add("megamenu-is-hover");
                  }
                });
              });
              i.addEventListener("mouseleave", function (e) {
                if (!megaTarget.classList.contains("is-live") && !megaTarget.classList.contains("is-hover")) {
                  megaTarget.classList.remove("active");
                  document.body.classList.remove("megamenu-is-hover");
                }
              });
            });
        },
        ajaxCall: function ajaxCall(url, callback, method, postData, dataType) {
          if (!window.XMLHttpRequest) {
            return null;
          }

          var req = new XMLHttpRequest();
          method = method || "GET";
          postData = postData || null;
          dataType = dataType || "text/plain";
          req.open(method, url);
          req.setRequestHeader("Content-Type", dataType);

          req.onreadystatechange = function () {
            if (req.readyState === 4) {
              if (req.status === 200) {
                callback(req.responseText);
              } else {
                console.log(req);
              }
            }
          };

          req.send(postData);
          return req;
        },
        productSettings: {
          actionCart: "[item-cart]",
          price_sale: "[item-price-sale]",
          price_compare: "[item-price-compare]",
          price: "[item-price-single]",
          soldout: "[item-soldout]",
          sku: "[item-sku]",
          cartBtnLabel: "[item-cart-btn-label]",
        },
        themeProduct: function themeProduct(container) {
          var formElement = container.querySelector("[data-product-form]"),
            productHandle = formElement.dataset.productHandle;
          var popupClick = container.querySelector("a[data-mobile-sidebar]");
          AT_Main.isExist(popupClick) && AT_Main.clickModal(popupClick, document.body);
          fetch("/products/".concat(productHandle, ".js"))
            .then(function (response) {
              return response.json();
            })
            .then(function (productJSON) {
              var productForm = new ProductForm(formElement, productJSON, {
                onOptionChange: AT_Main.themeProduct_variants,
              });
              AT_Main.initSwatch();
            });
        },
        themeProduct_variants: function themeProduct_variants(e) {
          var variant = e.dataset.variant,
            formSelect = e.target.closest("[data-product-form]"),
            settings = AT_Main.productSettings,
            target = formSelect.closest("[data-section-id]"),
            addCartBtn = target.querySelector('button[type="submit"]'),
            selectedID = target.querySelector('[name="id"]'),
            itemSKU = target.querySelector(settings.sku),
            actionCart = target.querySelector(settings.actionCart),
            soldout = target.querySelector(settings.soldout),
            cartBtnLabel = target.querySelector(settings.cartBtnLabel);

          if (variant === null) {
            addCartBtn.setAttribute("disabled", "disabled");
            actionCart.classList.add("hide");
            soldout.innerHTML = theme.cart.unavailable;
          } else if (variant) {
            var url = getUrlWithVariant(window.location.href, variant.id);
            window.history.replaceState(
              {
                path: url,
              },
              "",
              url
            );
            selectedID.value = variant.id;
            /* Update Featured Media */

            if (variant.featured_media) {
              var thumbnailSelect = target.querySelector(
                '[data-media-thumbnail-id="'.concat(variant.featured_media.id, '"]')
              );
              AT_Main.isExist(thumbnailSelect) && thumbnailSelect.click();
            }
            /* Product SKU */

            if (variant.sku.length) {
              itemSKU.innerHTML = variant.sku;
              itemSKU.closest("div").classList.remove("hide");
            } else {
              itemSKU.closest("div").classList.add("hide");
            }
            /* Update Button add cart */

            soldout.innerHTML = variant.available ? theme.cart.available : theme.cart.soldout;
            cartBtnLabel.innerHTML = variant.available ? theme.cart.available : theme.cart.soldout;

            if (!variant.available) {
              /* Sold out */
              addCartBtn.setAttribute("disabled", "disabled");
              actionCart.classList.add("hide");
            } else if (variant.available) {
              /* Available */
              addCartBtn.removeAttribute("disabled");
              actionCart.classList.remove("hide");
            }
          }
          /* Product Price */

          AT_Main.changePrice(variant, target, settings);
        },
        themeProduct_slide: function themeProduct_slide(container) {
          var mainMedia = container.querySelector("[data-main-media]"),
            thumbnailMedia = container.querySelector("[data-media-thumbnail]"),
            featuredIndex = container.querySelector("[data-media-id].active"),
            startIndex = AT_Main.isExist(featuredIndex) ? +featuredIndex.getAttribute("data-index") : 0;

          if (mainMedia.children.length < 2) {
            return;
          }

          if (mainMedia.querySelectorAll("[arn-data-zoom]").length && AT_Main.detectDeviceType() == "Desktop") {
            mainMedia.querySelectorAll("img").forEach(function (e) {
              var arnDrift = new Drift_Drift(e, {
                sourceAttribute: "arn-data-zoom",
                paneContainer: mainMedia.closest(".product-main-media"),
                containInline: true,
                handleTouch: false,
              });
            });
          }

          var mainTNS = tns({
            container: mainMedia,
            items: 1,
            startIndex: startIndex,
            mouseDrag: true,
            slideBy: "page",
            speed: 400,
            gutter: 30,
            controls: false,
            controlsContainer: ".product_single__media_control",
            navContainer: thumbnailMedia,
            navAsThumbnails: true,
            loop: false,
          });
          mainTNS.events.on("transitionStart", function (info, eventName) {
            mainMedia.classList.add("is-sliding");
          });
          mainTNS.events.on("transitionEnd", function (info, eventName) {
            mainMedia.classList.remove("is-sliding");
          });

          if (!AT_Main.isExist(thumbnailMedia)) {
            return;
          }

          thumbnailMedia.classList.remove("row", "d-grid");
          var conf = container.querySelector('input[name="sectionSlideConfig"]'),
            items = conf.getAttribute("data-items").split(","),
            nav = conf.getAttribute("data-dot") ? JSON.parse(conf.getAttribute("data-dot")) : false,
            gutters = conf.getAttribute("data-gutters") || "",
            itemClass = conf.getAttribute("data-item-class");
          gutters = gutters.replace(/[^\d.,]/g, "").split(",");

          if (itemClass != "") {
            for (var i = 0; i < thumbnailMedia.children.length; i++) {
              thumbnailMedia.children[i].className = itemClass;
            }
          }

          var responsive = {
            0: {
              items: +items[5] || +items[0],
              gutter: +gutters[5] || +gutters[0],
            },
            375: {
              items: +items[4] || +items[0],
              gutter: +gutters[4] || +gutters[0],
            },
            576: {
              items: +items[3] || +items[0],
              gutter: +gutters[3] || +gutters[0],
            },
            768: {
              items: +items[2] || +items[0],
              gutter: +gutters[2] || +gutters[0],
            },
            992: {
              items: +items[1] || +items[0],
              gutter: +gutters[1] || +gutters[0],
            },
            1200: {
              items: +items[0] || +items[0],
              gutter: +gutters[0] || +gutters[0],
            },
          };
          var thumbTNS = tns({
            container: thumbnailMedia,
            items: items[5],
            slideBy: "page",
            startIndex: 0,
            loop: false,
            mouseDrag: true,
            swipeAngle: 30,
            controls: true,
            controlsPosition: "bottom",
            controlsContainer: container.querySelector(".slide_ui-controls--nav"),
            nav: nav,
            responsive: responsive,
            preventActionWhenRunning: true,
            onInit: function onInit() {},
          });
          thumbTNS.events.on("transitionStart", function (info, eventName) {
            thumbnailMedia.classList.add("is-sliding");
          });
          thumbTNS.events.on("transitionEnd", function (info, eventName) {
            thumbnailMedia.classList.remove("is-sliding");
          });
        },
        changePrice: function changePrice(variant, target, settings) {
          var price = target.querySelector(settings.price) || {},
            priceSale = target.querySelector(settings.price_sale) || {},
            priceCompare = target.querySelector(settings.price_compare) || {},
            soldout = target.querySelector(settings.soldout) || {};
          price.classList.add("hide");
          priceSale.classList.add("hide");
          priceCompare.classList.add("hide");
          soldout.classList.add("hide");

          if (variant === null || !variant.available) {
            soldout.classList.remove("hide");
            return;
          }

          if (variant.available) {
            soldout.classList.add("hide");

            if (variant.compare_at_price != null && variant.compare_at_price > variant.price) {
              priceSale.innerHTML = currency_cjs["formatMoney"](variant.price, theme.currency.moneyFormat);
              priceCompare.innerHTML = currency_cjs["formatMoney"](
                variant.compare_at_price,
                theme.currency.moneyFormat
              );
              priceSale.classList.remove("hide");
              priceCompare.classList.remove("hide");
            } else {
              price.innerHTML = currency_cjs["formatMoney"](variant.price, theme.currency.moneyFormat);
              price.classList.remove("hide");
            }
          }
        },
        initSwatch: function initSwatch() {
          var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
          var swtArray = container.querySelectorAll('[data-swatch-wrapper] input[type="radio"]');

          if (!swtArray.length) {
            return;
          }

          swtArray.forEach(function (swt) {
            swt.addEventListener("change", function (e) {
              var value = swt.value,
                optionSelect = document.querySelector(swt.closest(".swatch-option").getAttribute("data-target"));
              optionSelect.value = value;
              optionSelect.dispatchEvent(new Event("change"));
            });
          });
        },
        init_EasyTimer: function init_EasyTimer(selector, time_second) {
          var timer = new easytimer["Timer"]();
          timer.start({
            countdown: true,
            startValues: {
              seconds: time_second,
            },
          });
          timer.addEventListener("secondsUpdated", function (e) {
            var d = timer.getTimeValues().days,
              h = timer.getTimeValues().hours,
              m = timer.getTimeValues().minutes,
              s = timer.getTimeValues().seconds;
            var totalHours = d * 24 + h;
            totalHours > 99
              ? AT_Main.easyTimer_HTML(selector.querySelector(".count-day"), d)
              : selector.querySelector(".count-day").classList.add("hide");
            AT_Main.easyTimer_HTML(selector.querySelector(".count-hrs"), totalHours > 99 ? h : totalHours);
            AT_Main.easyTimer_HTML(selector.querySelector(".count-min"), m);
            AT_Main.easyTimer_HTML(selector.querySelector(".count-sec"), s);

            if (!JSON.parse(selector.getAttribute("data-hide-label"))) {
              var d_t = d > 1 ? theme.dateLabel.days : theme.dateLabel.day,
                h_t = h > 1 ? theme.dateLabel.hours : theme.dateLabel.hour,
                m_t = m > 1 ? theme.dateLabel.minutes : theme.dateLabel.minute,
                s_t = s > 1 ? theme.dateLabel.seconds : theme.dateLabel.second;
              selector.querySelector(".count-day .date-label").innerHTML = d_t;
              selector.querySelector(".count-hrs .date-label").innerHTML = h_t;
              selector.querySelector(".count-min .date-label").innerHTML = m_t;
              selector.querySelector(".count-sec .date-label").innerHTML = s_t;
            }

            selector.classList.add("countdown-loaded");
          });
          timer.addEventListener("targetAchieved", function (e) {
            selector.classList.add("hide");
          });
        },
        easyTimer_HTML: function easyTimer_HTML(selector, value) {
          if (value > 9) {
            var arrValue = value.toString().split("");
            arrValue.forEach(function (val, index) {
              var target = selector.querySelector('.date-value[data-index="'.concat(index + 1, '"]'));

              if (!AT_Main.isExist(target)) {
                var prevElment = selector.querySelector('.date-value[data-index="'.concat(index, '"]'));
                var renderHTML = prevElment.outerHTML
                  .replace('data-index="'.concat(index, '"'), 'data-index="'.concat(index + 1, '"'))
                  .replace("".concat(prevElment.innerHTML, "</span>"), "".concat(arrValue[index], "</span"));
                selector
                  .querySelector('.date-value[data-index="'.concat(index, '"]'))
                  .insertAdjacentHTML("afterend", renderHTML);
                return;
              }

              target.innerHTML = arrValue[index];
            });
          } else {
            selector.querySelector('.date-value[data-index="1"]').innerHTML = 0;
            selector.querySelector('.date-value[data-index="2"]').innerHTML = value;
          }
        },
        initCountdown: function initCountdown() {
          var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          var container = target;

          if (container == null) {
            container = document;
          }

          var countdownItems = container.querySelectorAll(".countdown-time:not(.countdown-loaded)");

          if (!countdownItems.length) {
            return;
          }

          countdownItems.forEach(function (e) {
            if (!e.classList.contains("countdown-loaded")) {
              var _this = e,
                _value = _this.getAttribute("data-date").split("/"),
                _date = new Date(_value[2], Number(_value[0]) - 1, _value[1]).getTime() / 1000,
                _now = new Date().getTime() / 1000,
                countdownTime = _date > _now ? _date - _now : 0;

              if (countdownTime > 0) AT_Main.init_EasyTimer(_this, countdownTime);
              else _this.remove();
            }
          });
        },
        initCountryProvinceSelector: function initCountryProvinceSelector() {
          var target = document.querySelectorAll(".customer_address_table[data-id]");

          if (!target.length) {
            return;
          }

          new Shopify.CountryProvinceSelector("address_country_new", "address_province_new", {
            hideElement: "address_province_container_new",
          });
          target.forEach(function (element) {
            var formId = element.getAttribute("data-id");
            var countrySelector = "address_country_" + formId;
            var provinceSelector = "address_province_" + formId;
            var containerSelector = "address_province_container_" + formId;
            new Shopify.CountryProvinceSelector(countrySelector, provinceSelector, {
              hideElement: containerSelector,
            });
          });
        },
        initVideo: function initVideo(container) {
          AT_Main.onClick("[data-button-video]", function (e) {
            e.preventDefault();
            var parent = e.currentTarget.closest("[data-video-container]"),
              videoElement = parent.querySelector("[data-video-item]").children;

            if (parent.classList.contains("video-playing")) {
              parent.classList.remove("video-playing");
            } else {
              parent.classList.add("video-playing");
            }
          });
        },
        scrollToTop: function scrollToTop() {
          var bodyTop = document.documentElement.scrollTop || document.body.scrollTop;

          if (bodyTop > 0) {
            window.requestAnimationFrame(AT_Main.scrollToTop);
            window.scrollTo(0, bodyTop - bodyTop / 8);
          }
        },
        initEvents: function initEvents() {
          this.initDialog();
          /***
           *
           * Close Sidebar
           *
           ***/

          var closeSidebar = document.querySelectorAll("*[data-close-sidebar]");
          closeSidebar.length &&
            closeSidebar.forEach(function (e, i) {
              AT_Main.closeModal(e);
            });
          /***
           *
           * Back to top
           *
           ***/

          var backToTop = document.querySelector("#backToTop");

          if (AT_Main.isExist(backToTop)) {
            backToTop.addEventListener("click", function (e) {
              e.preventDefault();
              AT_Main.scrollToTop();
            });
            window.addEventListener("scroll", function (e) {
              var scrollTop = window.scrollY;

              if (scrollTop > 100 && scrollTop + window.innerHeight < document.body.clientHeight - 100) {
                backToTop.classList.add("active");
              } else {
                backToTop.classList.remove("active");
              }
            });
          }
          /***
           *
           * Continue Shopping Link
           *
           ***/

          if (Storage !== undefined) {
            if (document.body.classList.contains("templateCollection")) {
              sessionStorage.collection = theme.collectionLink;
            }

            if (AT_Main.isExist(document.querySelector("#continueShopping"))) {
              document.querySelector("#continueShopping").href = sessionStorage.collection;
            }
          }
          /***
           *
           * Hide Preview Panel
           *
           ***/

          if (window.location.href.includes("shopifypreview")) {
            window.addEventListener("load", function () {
              document.querySelector("#preview-bar-iframe").classList.add("hide");
              AT_Main.debounceTime(1000, function () {
                document.querySelector("#preview-bar-iframe").closest("html").style.paddingBottom = null;
              })();
            });
          }
          /***
           *
           * Resize Events
           *
           ***/

          window.addEventListener("resize", function () {
            if (oldWidth == AT_Main.getWidthBrowser()) {
              return;
            }

            oldWidth = AT_Main.getWidthBrowser();
            AT_Main.triggerDialog(AT_Search.settings.searchDialog, "close");
          });
          AT_Main.onClick("#announcement-bar--close", function (e) {
            e.preventDefault();

            var _parent = e.currentTarget.closest("[data-section-type]");

            if (_parent === null) {
              return;
            }

            AT_Main.fadeOut(_parent);
          });
        },
        init: function init() {
          oldWidth = AT_Main.getWidthBrowser();
          this.initEvents();
          this.menuMobile();
          this.initCountdown();
          this.initCountryProvinceSelector();
          AT_QuickView.init_quickView();
        },
      };
      var AT_Collection = {
        settings: {
          content: "[data-content-dynamic]",
          infiniteCounter: "[data-infinite-count]",
          infiniteBtn: ".btn-load-more",
          viewCounter: "[data-current-view]",
          filterElem: '[data-ajax="inactive"]',
          dynamicContent: "[data-dynamic-content]",
          gridList: "[data-gridlist]",
          productItem: "[data-product-item]",
        },
        updateCurrentView: function updateCurrentView(number) {
          var target = document.querySelectorAll(AT_Collection.settings.viewCounter);
          target.length &&
            target.forEach(function (e) {
              e.innerHTML = number;
            });
        },
        updateButton: function updateButton(content) {
          var settings = AT_Collection.settings;
          var btnLoadMore = document.querySelector(settings.infiniteBtn);

          if (!AT_Main.isExist(btnLoadMore)) {
            return;
          }

          btnLoadMore.closest("div").classList.remove("loading");
          var infiniteBtn = content.querySelector(settings.infiniteBtn);

          if (AT_Main.isExist(infiniteBtn)) {
            btnLoadMore.classList.remove("hide");
            btnLoadMore.setAttribute("href", infiniteBtn.getAttribute("href"));
          } else {
            btnLoadMore.classList.add("hide");
          }
        },
        handleGridList: function handleGridList() {
          var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
          var settings = AT_Collection.settings;
          var target = container.querySelectorAll(settings.gridList);
          target.length &&
            target.forEach(function (element) {
              element.addEventListener("click", function (e) {
                e.preventDefault();

                var _this = e.currentTarget,
                  className = _this.querySelector("input").value;

                document.querySelectorAll(settings.productItem).forEach(function (item) {
                  item.classList = [
                    item.getAttribute(AT_Main.removeSquareBracket(settings.productItem)),
                    className,
                  ].join(" ");
                });
                AT_Main.setCookie("collectionView", className, 1);
                console.log(AT_Main.getCookie("collectionView"));
              });
            });
          /*
          type: "POST",
          url: '/cart.js',
          dataType: 'json',
          data: {"attributes[pagination]": _va},*/
        },
        loadContent: function loadContent(url) {
          var settings = AT_Collection.settings;
          AT_Main.ajaxCall(url, function (resp) {
            var parser = new DOMParser();
            var doc = parser.parseFromString(resp, "text/html"),
              body = doc.querySelector(settings.content);
            body.querySelectorAll(":scope > *").forEach(function (child) {
              /*Add event for new Element*/
              AT_Cart.buttonAddCart(child);
              AT_QuickView.init_quickView(child);
              /*Insert to DOM*/

              document.querySelector(settings.content).insertAdjacentElement("beforeend", child);
            });
            var updateCounter = doc.querySelector(settings.infiniteCounter);
            var old = +document.querySelector(settings.infiniteCounter).innerHTML.trim();
            old += +updateCounter.innerHTML.trim();
            AT_Collection.updateCurrentView(old);
            AT_Collection.updateButton(doc);
          });
        },
        filterEvent: function filterEvent() {
          var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
          var settings = AT_Collection.settings;
          var filterElem = container.querySelectorAll(settings.filterElem);
          filterElem.forEach(function (element) {
            element.setAttribute("data-filter", "active");
            var link = element.querySelector("a");
            link.addEventListener("click", function (e) {
              e.preventDefault();
              var _this = e.currentTarget;

              var url = location.origin + _this.getAttribute("href");

              if (_this.hasAttribute("data-clear-filter") && !url.includes("?") && location.href.includes("?")) {
                url += location.search;
              }

              AT_Collection.filter(url, element);
              AT_Collection.filterEvent.loading();

              _this.closest("[data-prefix]").classList.add("filter-loading");

              AT_Collection.filterEvent.loading();
            });
          });

          AT_Collection.filterEvent.loading = function () {
            var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

            if (bool) {
              document.body.classList.add("ajax-running");
              return;
            }

            document.body.classList.remove("ajax-running");
            return;
          };
        },
        filter: function filter(url, filterElement) {
          var settings = AT_Collection.settings;
          AT_Main.ajaxCall(url, function (resp) {
            var parser = new DOMParser();
            var body = parser.parseFromString(resp, "text/html"),
              productContainer = body.querySelector(settings.content),
              counter = 0;
            window.history.replaceState(
              {
                path: url,
              },
              "",
              url
            );
            /*Update URL*/

            document.querySelector(settings.content).innerHTML = "";
            productContainer.querySelectorAll(":scope > *").forEach(function (child) {
              /***
               *
               * Add event for new Element
               *
               ***/
              AT_Cart.buttonAddCart(child);
              AT_QuickView.init_quickView(child);
              /*Insert to DOM*/

              document.querySelector(settings.content).insertAdjacentElement("beforeend", child);
              counter++;
            });
            AT_Collection.filterEvent.loading(false);
            AT_Collection.updateCurrentView(counter);
            AT_Collection.updateButton(body);
            /* Update New Content */

            var filterArr = body.querySelectorAll("[data-prefix]");
            filterArr.length &&
              filterArr.forEach(function (f) {
                var prefix = f.getAttribute("data-prefix"),
                  target = document.body.querySelector('[data-prefix="'.concat(prefix, '"]'));
                target.replaceWith(f);
                AT_Collection.filterEvent(f);
              });
            document.head.querySelector("title").replaceWith(body.querySelector("title"));
            var dynamicContent = body.querySelectorAll(settings.dynamicContent),
              dynamicID = AT_Main.removeSquareBracket(settings.dynamicContent);
            dynamicContent.length &&
              dynamicContent.forEach(function (f) {
                var value = f.getAttribute(dynamicID),
                  target = document.body.querySelector("[".concat(dynamicID, '="').concat(value, '"]'));
                target.replaceWith(f);
              });
          });
        },
        init: function init(container) {
          AT_Collection.filterEvent();
          AT_Collection.handleGridList();
          var settings = AT_Collection.settings;
          var popupClick = container.querySelector("a[data-target]");
          AT_Main.isExist(popupClick) && AT_Main.clickModal(popupClick, document.body);
          /*Infinite Event Click*/

          var btnLoadMore = document.querySelector(settings.infiniteBtn);
          AT_Main.isExist(btnLoadMore) &&
            btnLoadMore.addEventListener("click", function (e) {
              e.preventDefault();
              var _this = e.currentTarget;

              var url = location.origin + _this.getAttribute("href");

              _this.closest("div").classList.add("loading");

              AT_Collection.loadContent(url);
            });
        },
      };
      var AT_QuickView = {
        settings:
          ((_settings = {
            dialog: "#quickView",
            id: "[item-id]",
            url: "[item-url]",
            title: "[item-title]",
            vendor: "[item-vendor]",
            option: "[item-option]",
            price_sale: "[item-price-sale]",
            price_compare: "[item-price-compare]",
            price: "[item-price-single]",
            soldout: "[item-soldout]",
            quantity: "[item-quantity]",
            mainMedia: "[item-main-media]",
            thumbMedia: "[item-media-thumbnail]",
            navMainMedia: "[item-main-nav]",
            navThumbMedia: "[item-thumb-nav]",
          }),
          defineProperty_default()(_settings, "navThumbMedia", "[item-thumb-nav]"),
          defineProperty_default()(_settings, "actionCart", "[item-cart]"),
          defineProperty_default()(_settings, "tag", "[item-tag]"),
          defineProperty_default()(_settings, "sku", "[item-sku]"),
          defineProperty_default()(_settings, "quickViewSlide_main", null),
          defineProperty_default()(_settings, "quickViewSlide_thumb", null),
          defineProperty_default()(_settings, "mainFigure", "#qs-main-figure"),
          defineProperty_default()(_settings, "thumnailFigure", "#qs-thumnail-figure"),
          defineProperty_default()(_settings, "currentProduct", null),
          _settings),
        init_quickView: function init_quickView() {
          var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
          var $this = this,
            settings = AT_QuickView.settings,
            quickViewButton = container.querySelectorAll("[data-quick-view]"),
            quickView = document.querySelector(settings.dialog),
            formElement = quickView.querySelector("[data-product-form]");

          if (!AT_Main.isExist(quickView)) {
            return;
          }

          quickViewButton.length &&
            quickViewButton.forEach(function (element) {
              element.addEventListener("click", function (e) {
                e.preventDefault();

                var _this = e.currentTarget,
                  handle = _this.querySelector("input").value;

                formElement.setAttribute("data-product-handle", handle);
                fetch("/products/".concat(handle, ".js"))
                  .then(function (response) {
                    return response.json();
                  })
                  .then(function (productJSON) {
                    $this.quickView_handle(quickView, productJSON);
                    $this.quickView_slide(quickView, productJSON);
                  });
              });
            });
        },
        quickView_handle: function quickView_handle(target, productJSON) {
          var _this = this,
            settings = _this.settings,
            productSelected = productJSON.variants[0],
            itemTag = target.querySelector(settings.tag),
            itemSKU = target.querySelector(settings.sku),
            itemOption = target.querySelector(settings.option),
            actionCart = target.querySelector(settings.actionCart);

          target.querySelector(settings.url).setAttribute("href", productJSON.url);
          target.querySelector(settings.title).innerHTML = productJSON.title;
          target.querySelector(settings.vendor).innerHTML = productJSON.vendor;
          target.querySelector(settings.quantity).value = 1;
          settings.currentProduct = productJSON;
          /* Product Tags */

          if (productJSON.tags.length) {
            itemTag.innerHTML = productJSON.tags.join(", ");
            itemTag.closest("div").classList.remove("hide");
          } else {
            itemTag.closest("div").classList.add("hide");
          }
          /* Product SKU */

          if (productSelected.sku.length) {
            itemSKU.innerHTML = productSelected.sku;
            itemSKU.closest("div").classList.remove("hide");
          } else {
            itemSKU.closest("div").classList.add("hide");
          }
          /* Product Select */

          var variantSelect = "";
          productJSON.variants.forEach(function (variant) {
            variantSelect += '<option value="'
              .concat(variant.id, '"')
              .concat(variant == productSelected ? 'selected="selected"' : "", ">")
              .concat(variant.title, "</option>");
          });
          var variantHTML = '<select name="id" class="hide">'.concat(variantSelect, "</select>");

          if (
            productJSON.variants.length > 1 &&
            !productJSON.variants.some(function (v) {
              return v.title == "Default Title";
            })
          ) {
            /* Product Options */
            var optionHTML = "",
              swatchHTML = "";
            productJSON.options.forEach(function (option) {
              var optionNameHandle = AT_Main.handle(option.name),
                optionSelect = "",
                swatchItem = "";
              option.values.forEach(function (value) {
                var selected = productSelected.options.includes(value) ? 'selected="selected"' : "";
                optionSelect += '<option value="'
                  .concat(AT_Main.escape(value), '"')
                  .concat(selected, ">")
                  .concat(value, "</option>");
                selected = productSelected.options.includes(value) ? 'checked="checked"' : "";

                if (option.name.toLowerCase().includes("color")) {
                  swatchItem += '<div class="swatch-item">\n\t\t\t\t\t\t<input type="radio" class="swt-type-color" name="qsSwatch'
                    .concat(optionNameHandle.toUpperCase(), '" id="qsSWT')
                    .concat(option.position, "_")
                    .concat(AT_Main.handle(value), '" value="')
                    .concat(AT_Main.escape(value), '"')
                    .concat(selected, '>\n\t\t\t\t\t\t<label for="qsSWT')
                    .concat(option.position, "_")
                    .concat(AT_Main.handle(value), '" class="swt-color customColor-')
                    .concat(AT_Main.handle(value), '"></label>\n\t\t\t\t\t\t<span class="tooltip">')
                    .concat(value, "</span>\n\t\t\t\t\t\t</div>");
                } else {
                  swatchItem += '<div class="swatch-item">\n\t\t\t\t\t\t<input type="radio" class="swt-type-button" name="qsSwatch'
                    .concat(optionNameHandle.toUpperCase(), '" id="qsSWT')
                    .concat(option.position, "_")
                    .concat(AT_Main.handle(value), '" value="')
                    .concat(AT_Main.escape(value), '"')
                    .concat(selected, '>\n\t\t\t\t\t\t<label for="qsSWT')
                    .concat(option.position, "_")
                    .concat(AT_Main.handle(value), '" class="swt-button">')
                    .concat(value, "</label>\n\t\t\t\t\t\t</div>");
                }
              });
              optionHTML += '<div class="select-option js-enabled" data-option="'
                .concat(optionNameHandle, '">\n\t\t\t\t<label for="Option')
                .concat(option.position, '">')
                .concat(option.name, '</label>\n\t\t\t\t<select id="qsOption')
                .concat(option.position, '" name="options[')
                .concat(AT_Main.escape(option.name), ']">')
                .concat(optionSelect, "</select>\n\t\t\t\t</div>");
              swatchHTML += '<div class="swatch-option" data-target="#qsOption'
                .concat(option.position, '">\n\t\t\t\t<div class="swatch-header"><p>')
                .concat(option.name, '</p></div>\n\t\t\t\t<div class="swatch-container d-flex">')
                .concat(swatchItem, "</div>\n\t\t\t\t</div><style>")
                .concat(settings.dialog, ' .select-option[data-option="')
                .concat(optionNameHandle, '"]{display: none;}</style>');
            });
            itemOption.innerHTML = '<div class="swatch-variants-wrapper" data-swatch-wrapper>'
              .concat(swatchHTML, '</div><div class="variants-wrapper">')
              .concat(optionHTML, "</div>");
            itemOption.insertAdjacentHTML("beforeend", variantHTML);
            itemOption.classList.remove("hide");
            var formElement = document.querySelector(settings.dialog).querySelector("[data-product-form]");
            AT_Main.initSwatch(document.querySelector(settings.dialog));
            var qsProductForm = new ProductForm(formElement, productJSON, {
              onOptionChange: AT_QuickView.quickView_variants,
            });
          } else {
            itemOption.classList.add("hide");
            itemOption.innerHTML = variantHTML;
          }

          productSelected.available ? actionCart.classList.remove("hide") : actionCart.classList.add("hide");
          /* Product Price */

          AT_Main.changePrice(productSelected, target, settings);
          AT_Main.triggerDialog(settings.dialog);
        },
        quickView_variants: function quickView_variants(e) {
          var variant = e.dataset.variant,
            settings = AT_QuickView.settings,
            target = document.querySelector(settings.dialog),
            formSelect = e.target.closest("[data-product-form]"),
            container = formSelect.closest(settings.dialog),
            productJSON = settings.currentProduct,
            addCartBtn = target.querySelector('button[type="submit"]'),
            actionCart = target.querySelector(settings.actionCart),
            soldout = target.querySelector(settings.soldout);

          if (variant === null) {
            addCartBtn.setAttribute("disabled", "disabled");
            actionCart.classList.add("hide");
            soldout.innerHTML = theme.cart.unavailable;
          } else if (variant) {
            var _settings2 = AT_QuickView.settings,
              itemSKU = target.querySelector(_settings2.sku),
              itemURL = getUrlWithVariant(productJSON.url, variant.id),
              selectedID = target.querySelector('[name="id"]');
            selectedID.value = variant.id;
            /* Product Featured Image */

            if (variant.featured_media) {
              var thumbnailSelect = container.querySelector(
                '[data-media-thumbnail-id="'.concat(variant.featured_media.id, '"]')
              );
              AT_Main.isExist(thumbnailSelect) && thumbnailSelect.click();
            }
            /* Product URL */

            target.querySelector(_settings2.url).setAttribute("href", itemURL);
            /* Product SKU */

            if (variant.sku.length) {
              itemSKU.innerHTML = variant.sku;
              itemSKU.closest("div").classList.remove("hide");
            } else {
              itemSKU.closest("div").classList.add("hide");
            }
            /* Update Button add cart */

            soldout.innerHTML = variant.available ? theme.cart.available : theme.cart.soldout;

            if (!variant.available) {
              target.querySelector(_settings2.soldout).classList.remove("hide");
              addCartBtn.setAttribute("disabled", "disabled");
              actionCart.classList.add("hide");
            } else if (variant.available) {
              addCartBtn.removeAttribute("disabled");
              actionCart.classList.remove("hide");
            }
          }
          /* Product Price */

          AT_Main.changePrice(variant, target, settings);
        },
        quickView_slide: function quickView_slide(target, productJSON) {
          var _this = this,
            settings = _this.settings;

          settings.quickViewSlide_main != null && settings.quickViewSlide_main.destroy();
          settings.quickViewSlide_thumb != null && settings.quickViewSlide_thumb.destroy();
          var productGallery = "",
            thumbnailGallery = "",
            mainMedia = target.querySelector(settings.mainMedia),
            mainMediaNav = target.querySelector("[item-main-nav]"),
            thumbnailMediaNav = target.querySelector("[item-thumb-nav]"),
            thumbnailMedia = target.querySelector(settings.thumbMedia),
            startIndex = 0,
            featuredIMG = productJSON.variants[0].featured_media
              ? productJSON.variants[0].featured_media.id
              : productJSON.media[0]
              ? productJSON.media[0].id
              : 0;
          productJSON.media.forEach(function (m, index) {
            if (m.media_type == "image") {
              var ratio = ((1 / m.aspect_ratio) * 100).toFixed(2),
                active = "";
              ratio > 100 && (ratio = 100);

              if (m.id == featuredIMG) {
                active = " active";
                startIndex = index;
              }

              productGallery += '<div class="feature-product-media'
                .concat(active, '" data-media-id="')
                .concat(
                  m.id,
                  '">\n\t\t\t\t<figure>\n\t\t\t\t<span class="image__style" style="display: block;position: relative;padding-top: '
                )
                .concat(ratio, '%;">\n\t\t\t\t<img class="overlay-ui w-100 h-100 lazyload"\n\t\t\t\tdata-src="')
                .concat(images_cjs["getSizedImageUrl"](m.src, "1024x"), '" alt="')
                .concat(
                  m.alt || productJSON.title,
                  '"\n\t\t\t\tdata-sizes="auto"\n\t\t\t\tdata-optimumx="1.5"\n\t\t\t\tdata-expand="30"\n\t\t\t\tdata-parent-fit="cover">\n\t\t\t\t</span>\n\t\t\t\t</figure>\n\t\t\t\t</div>'
                );
              thumbnailGallery += '<div class="thumbnail-media '
                .concat(
                  target.querySelector(settings.thumbMedia).getAttribute("data-class"),
                  '" data-media-thumbnail-id="'
                )
                .concat(
                  m.id,
                  '">\n\t\t\t\t<figure>\n\t\t\t\t<span class="image__style" style="display: block;position: relative;padding-top: '
                )
                .concat(ratio, '%;">\n\t\t\t\t<img class="overlay-ui w-100 h-100 lazyload"\n\t\t\t\tdata-src="')
                .concat(images_cjs["getSizedImageUrl"](m.src, "200x"), '" alt="')
                .concat(
                  m.alt || productJSON.title,
                  '"\n\t\t\t\tdata-sizes="auto"\n\t\t\t\tdata-optimumx="1.5"\n\t\t\t\tdata-expand="30"\n\t\t\t\tdata-parent-fit="cover">\n\t\t\t\t</span>\n\t\t\t\t</figure>\n\t\t\t\t</div>'
                );
            }
          });
          target.querySelector(settings.mainMedia).innerHTML = productGallery;
          target.querySelector(settings.thumbMedia).innerHTML = thumbnailGallery;
          AT_Main.isExist(mainMediaNav) && (mainMediaNav.style.display = null);
          var mainTNS = tns({
            container: mainMedia,
            items: 1,
            mouseDrag: true,
            startIndex: startIndex,
            slideBy: "page",
            speed: 400,
            controls: true,
            controlsPosition: "bottom",
            controlsContainer: target.querySelector(settings.navMainMedia),
            navContainer: thumbnailMedia,
            navAsThumbnails: true,
            gutter: 30,
            loop: false,
          });
          mainTNS.events.on("transitionStart", function (info, eventName) {
            mainMedia.classList.add("is-sliding");
          });
          mainTNS.events.on("transitionEnd", function (info, eventName) {
            mainMedia.classList.remove("is-sliding");
          });
          settings.quickViewSlide_main = mainTNS;
          thumbnailMedia.classList.remove("row", "d-grid");
          var conf = target.querySelector('input[name="sectionSlideConfig"]'),
            items = conf.getAttribute("data-items").split(","),
            nav = conf.getAttribute("data-dot") ? JSON.parse(conf.getAttribute("data-dot")) : false,
            gutters = conf.getAttribute("data-gutters") || "",
            itemClass = conf.getAttribute("data-item-class");
          gutters = gutters.replace(/[^\d.,]/g, "").split(",");

          if (itemClass != "") {
            for (var i = 0; i < thumbnailMedia.children.length; i++) {
              thumbnailMedia.children[i].className = itemClass;
            }
          }

          var responsive = {
            0: {
              items: +items[5] || +items[0],
              gutter: +gutters[5] || +gutters[0],
            },
            375: {
              items: +items[4] || +items[0],
              gutter: +gutters[4] || +gutters[0],
            },
            576: {
              items: +items[3] || +items[0],
              gutter: +gutters[3] || +gutters[0],
            },
            768: {
              items: +items[2] || +items[0],
              gutter: +gutters[2] || +gutters[0],
            },
            992: {
              items: +items[1] || +items[0],
              gutter: +gutters[1] || +gutters[0],
            },
            1200: {
              items: +items[0] || +items[0],
              gutter: +gutters[0] || +gutters[0],
            },
          };
          AT_Main.isExist(thumbnailMediaNav) && (thumbnailMediaNav.style.display = null);
          var thumbTNS = tns({
            container: thumbnailMedia,
            items: items[5],
            slideBy: "page",
            loop: false,
            mouseDrag: true,
            swipeAngle: 30,
            controls: true,
            controlsPosition: "bottom",
            controlsContainer: target.querySelector(settings.navThumbMedia),
            nav: nav,
            responsive: responsive,
            preventActionWhenRunning: true,
            onInit: function onInit() {
              if (productJSON.media.length > 1) {
                thumbnailMedia.classList.remove("hide");
                thumbnailMedia.style.display = "block";
              } else {
                thumbnailMedia.classList.add("hide");
              }
            },
          });
          thumbTNS.events.on("transitionStart", function (info, eventName) {
            thumbnailMedia.classList.add("is-sliding");
          });
          thumbTNS.events.on("transitionEnd", function (info, eventName) {
            thumbnailMedia.classList.remove("is-sliding");
          });
          settings.quickViewSlide_thumb = thumbTNS;
        },
      };
      var AT_Cart = {
        settings: {
          dialog: "#cartNoti",
          cartDrawer: "#cartShopping",
          cartCount: "[data-cart-count]",
          cartCount_text: "[data-cart-item-text]",
          total: "[data-cart-total]",
          removeItem: "[data-item-remove]",
          removeAll: "[data-cart-remove-all]",
          waitingClass: "cart-waiting",
          productCard: "#productCardLayout",
          cartLineItem: "#cartItemHTML",
          cartBody: "[data-cart-body]",
          lineItem: "[data-line-item]",
          itemID: "[data-item-id]",
          itemKey: "[data-item-key]",
          itemImage: "[data-item-image]",
          itemURL: "[data-item-url]",
          itemTitle: "[data-item-title]",
          itemOption: "[data-item-option]",
          itemPrice: "[data-item-price]",
          itemComparePrice: "[data-item-price-compare]",
          itemLinePrice: "[data-item-line-price]",
          itemCartBtnLabel: "[data-item-cart-button-label]",
          itemQty: "[data-item-qty]",
          itemInputQty: 'input[name="quantity"]',
          itemQtyLabel: "[data-item-qty-label]",
          itemReview: "[data-item-review]",
          suggestContent: "[data-cart-suggest]",
          replaceContent: "[data-cart-replace]",
        },
        eventHandle: function eventHandle() {
          var settings = AT_Cart.settings;
          AT_Cart.buttonAddCart();
          AT_Cart.clearItem();
          AT_Cart.qtyClick();
          AT_Main.onClick(".btn-link-cart:not(.soldout)", function (e) {
            e.preventDefault();

            var _this = e.currentTarget,
              container = _this.closest("[data-product-card]");

            AT_Cart.buttonLoading(_this);

            if (!AT_Main.isExist(container)) {
              return;
            }

            var button = container.querySelector('form button[type="submit"]');
            AT_Main.isExist(button) && button.click();
          });
          /***
           *
           * Clear All
           *
           ***/

          AT_Main.onClick(".clear-cart-items", function (e) {
            e.preventDefault();
            clearItems().then(function (state) {
              AT_Cart.updateCart(state);
            });
          });
          /***
           *
           * Cart Drawer
           *
           ***/

          AT_Main.onClick("[data-cart]", function (e) {
            e.preventDefault();

            if (!AT_Main.isExist(document.querySelector("#cartShopping"))) {
              return;
            }

            document.querySelector("#cartShopping").classList.add("active");
            AT_Main.disablePageScroll(true);
          });
          AT_Main.onClick("[data-close-cart]", function (e) {
            e.preventDefault();

            if (!AT_Main.isExist(document.querySelector("#cartShopping"))) {
              return;
            }

            document.querySelector("#cartShopping").classList.remove("active");
            AT_Main.disablePageScroll(false);
          });
        },
        buttonAddCart: function buttonAddCart() {
          var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
          container.querySelectorAll(".btn-add-to-cart").length &&
            container.querySelectorAll(".btn-add-to-cart").forEach(function (element) {
              element.addEventListener("click", function (e) {
                if (!theme.cart.ajax) {
                  return;
                }

                e.preventDefault();

                if (AT_Main.isExist(e.currentTarget.closest(AT_Cart.settings.replaceContent))) {
                  var key = e.currentTarget
                    .closest(AT_Cart.settings.replaceContent)
                    .getAttribute(AT_Cart.settings.replaceContent.replace(/\[|\]/g, ""), "");
                  removeItem(key)
                    .then(function (state) {
                      AT_Cart.updateCart(state);
                    })
                    .then(function (e) {
                      AT_Cart.addCart(element);
                    });
                } else AT_Cart.addCart(element);
              });
            });
        },
        qtyClick: function qtyClick() {
          var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
          var settings = AT_Cart.settings,
            qtyWrapper = container.querySelectorAll("[data-quantity] a.qty-plus, [data-quantity] a.qty-minus"),
            inputQty = container.querySelectorAll("[data-quantity] input");
          inputQty.length &&
            inputQty.forEach(function (qty) {
              qty.addEventListener(
                "keydown",
                AT_Main.debounceTime(300, function (e) {
                  e.preventDefault();
                  var input = qty,
                    oldValue = +input.value || 1,
                    currentValue = +input.value || 1,
                    min = +input.getAttribute("min") || 0;

                  if (input.hasAttribute("disabled")) {
                    return;
                  }

                  currentValue < min && (input.value = min);

                  if (
                    input.hasAttribute(settings.itemKey.replace(/\[|\]/g, ""), "") &&
                    currentValue >= min &&
                    oldValue != currentValue
                  ) {
                    AT_Cart.qtyChange(input);
                  }
                })
              );
            });
          qtyWrapper.length &&
            qtyWrapper.forEach(function (qty) {
              qty.addEventListener("click", function (e) {
                e.preventDefault();

                var _this = e.currentTarget,
                  input = _this.closest("[data-quantity]").querySelector("input"),
                  oldValue = +input.value,
                  currentValue = +input.value,
                  min = +input.getAttribute("min") || 0;

                if (input.hasAttribute("disabled")) {
                  return;
                }

                if (_this.classList.contains("qty-plus")) {
                  currentValue += 1;
                } else {
                  currentValue > min && (currentValue -= 1);
                }

                input.value = currentValue;

                if (
                  input.hasAttribute(settings.itemKey.replace(/\[|\]/g, ""), "") &&
                  currentValue >= min &&
                  oldValue != currentValue
                ) {
                  AT_Cart.qtyChange(input);
                }
              });
            });
        },
        clearItem: function clearItem() {
          var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
          AT_Main.onClick(
            AT_Cart.settings.removeItem,
            function (e) {
              e.preventDefault();

              var _this = e.currentTarget,
                key = _this.getAttribute("data-item-key");

              removeItem(key).then(function (state) {
                var clear = new Promise(function (resolve, reject) {
                  resolve(AT_Main.fadeOut(_this.closest(AT_Cart.settings.lineItem)));
                });
                clear
                  .then(function (e) {
                    _this.closest(AT_Cart.settings.lineItem).remove();
                  })
                  .then(function () {
                    AT_Cart.updateCart(state);
                  });
              });
            },
            container
          );
        },
        addCart: function addCart(selector) {
          var form = selector.closest("[data-product-form]"),
            settings = AT_Cart.settings,
            modal = document.querySelector(settings.dialog);

          if (!AT_Main.isExist(form)) {
            return;
          }

          AT_Cart.buttonLoading(selector);
          var formData = new FormData(form);
          addItemFromForm(form)
            .then(
              /*#__PURE__*/ (function () {
                var _ref = asyncToGenerator_default()(
                  /*#__PURE__*/ regenerator_default.a.mark(function _callee(item) {
                    var isReplace, image;
                    return regenerator_default.a.wrap(function _callee$(_context) {
                      while (1) {
                        switch ((_context.prev = _context.next)) {
                          case 0:
                            if (AT_Main.isExist(modal)) {
                              _context.next = 2;
                              break;
                            }

                            return _context.abrupt("return");

                          case 2:
                            AT_Main.triggerDialog(settings.dialog, "close");
                            modal.setAttribute("data-cart-type", "normal");
                            _context.next = 6;
                            return AT_Cart.replaceCart(formData);

                          case 6:
                            isReplace = _context.sent;

                            if (isReplace) {
                              document
                                .querySelector(settings.replaceContent)
                                .setAttribute(settings.replaceContent.replace(/\[|\]/g, ""), item.key);
                            } else {
                              AT_Cart.suggestCart(formData);
                              document
                                .querySelector(settings.replaceContent)
                                .setAttribute(settings.replaceContent.replace(/\[|\]/g, ""), "");
                            }

                            image = item.image || theme.product.default_image;
                            image &&
                              modal
                                .querySelector(settings.itemImage)
                                .setAttribute("src", images_cjs["getSizedImageUrl"](image, "280x"));
                            modal.querySelector(settings.itemImage).setAttribute("alt", item.title);
                            modal.querySelector(settings.itemTitle).innerHTML = item.title;
                            modal.querySelector(settings.itemPrice).innerHTML = currency_cjs["formatMoney"](
                              item.price,
                              theme.currency.moneyFormat
                            );
                            modal.querySelector(settings.itemLinePrice).innerHTML = currency_cjs["formatMoney"](
                              item.line_price,
                              theme.currency.moneyFormat
                            );
                            modal.querySelector(settings.itemQty).innerHTML = item.quantity;
                            getState().then(function (cart) {
                              AT_Cart.updateCart(cart);
                              var cartCounter_label = document.querySelectorAll(settings.cartCount_text);
                              cartCounter_label.length &&
                                cartCounter_label.forEach(function (e) {
                                  e.innerHTML = cart.item_count > 1 ? theme.cart.items : theme.cart.item;
                                });
                              AT_Main.triggerDialog(settings.dialog);
                            });

                          case 16:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  })
                );

                return function (_x) {
                  return _ref.apply(this, arguments);
                };
              })(),
              function (error) {
                AT_Cart.cartError();
              }
            )
            .then(function () {
              document.querySelectorAll("." + settings.waitingClass).forEach(function (e) {
                return AT_Cart.buttonLoading(e, false);
              });
            });
        },
        buttonLoading: function buttonLoading(button) {
          var bool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          if (bool) button.classList.add(AT_Cart.settings.waitingClass);
          else button.classList.remove(AT_Cart.settings.waitingClass);
          return;
        },
        updateCart: function updateCart(cart) {
          var settings = AT_Cart.settings,
            cartDrawer = document.querySelector(settings.cartDrawer),
            cartCounter = document.querySelectorAll(settings.cartCount),
            totalPrice = document.querySelectorAll(settings.total);
          cartCounter.length &&
            cartCounter.forEach(function (e) {
              e.innerHTML = cart.item_count;
            });
          totalPrice.length &&
            totalPrice.forEach(function (e) {
              e.innerHTML = currency_cjs["formatMoney"](cart.total_price, theme.currency.moneyFormat);
            });

          if (theme.template == "cart") {
            if (cart.items.length) {
              cart.items.forEach(function (item) {
                var line = document.querySelector(settings.itemKey.replace("]", '="'.concat(item.key, '"]')));

                if (AT_Main.isExist(line)) {
                  line = line.closest(settings.lineItem);
                  var itemLinePrice = line.querySelector(settings.itemLinePrice);
                  AT_Main.isExist(line) &&
                    (itemLinePrice.innerHTML = currency_cjs["formatMoney"](
                      item.line_price,
                      theme.currency.moneyFormat
                    ));
                }
              });
            } else {
              var body = document.querySelector(settings.cartBody);
              body.innerHTML = theme.cartPage.empty || "";
            }
          } else if (AT_Main.isExist(cartDrawer)) {
            if (cart.item_count == 0) {
              cartDrawer.querySelector(settings.cartBody).innerHTML = theme.cart.empty;
              cartDrawer.querySelector(settings.removeAll).classList.add("hide");
            } else {
              AT_Cart.updateCartDrawer(cart.items);
              cartDrawer.querySelector(settings.removeAll).classList.remove("hide");
            }
          }
        },
        updateCartDrawer: function updateCartDrawer(items) {
          var settings = AT_Cart.settings,
            cartDrawer = document.querySelector(settings.cartDrawer),
            lineItem = document.querySelector(settings.cartLineItem);

          if (!AT_Main.isExist(cartDrawer)) {
            return;
          }

          var bodyDrawer = cartDrawer.querySelector(settings.cartBody);

          if (!items.length) {
            return;
          }

          bodyDrawer.innerHTML = "";
          items.forEach(function (item, index) {
            var itemQty = lineItem.querySelector(settings.itemQty),
              itemQtyLabel = lineItem.querySelector(settings.itemQtyLabel),
              itemInputQty = lineItem.querySelector(settings.itemInputQty);
            lineItem.querySelector(settings.itemTitle).innerHTML = item.title;
            lineItem.querySelector(settings.itemPrice).innerHTML = currency_cjs["formatMoney"](
              item.price,
              theme.currency.moneyFormat
            );
            lineItem.querySelector(settings.itemComparePrice).innerHTML = currency_cjs["formatMoney"](
              item.compare_at_price,
              theme.currency.moneyFormat
            );
            AT_Main.isExist(itemInputQty) &&
              lineItem.querySelector(settings.itemInputQty).setAttribute("value", item.quantity);
            AT_Main.isExist(itemQty) && (itemQty.innerHTML = item.quantity);
            AT_Main.isExist(itemQtyLabel) &&
              (itemQtyLabel.innerHTML = item.quantity == 1 ? theme.cart.item : theme.cart.items);
            lineItem.querySelectorAll(settings.itemKey).forEach(function (e) {
              e.setAttribute(settings.itemKey.replace(/\[|\]/g, ""), item.key);
            });
            lineItem.querySelectorAll(settings.itemURL).forEach(function (e) {
              e.setAttribute("href", item.url);
            });
            item.variant_title && lineItem.querySelector(settings.itemOption) == item.variant_title;
            var ratio = "100%";

            if (item.featured_image) {
              ratio = item.featured_image.aspect_ratio
                ? ((1 / item.featured_image.aspect_ratio) * 100).toFixed(2) + "%"
                : ratio;
              lineItem
                .querySelector(settings.itemImage)
                .setAttribute(
                  "src",
                  images_cjs["getSizedImageUrl"](item.featured_image.url || theme.product.default_image, "280x")
                );
              lineItem.querySelector(settings.itemImage).setAttribute("alt", item.title);
            } else {
              lineItem.querySelector(settings.itemImage).classList.add("hide");
            }

            var HTML = lineItem.innerHTML
              .replace("animation-fade-index-init", "animation-fade-index-".concat(index))
              .replace("100.0%", ratio);
            bodyDrawer.insertAdjacentHTML("beforeend", HTML);
          });
          AT_Cart.clearItem(bodyDrawer);
          AT_Cart.qtyClick(bodyDrawer);
        },
        qtyChange: function qtyChange(input) {
          var settings = AT_Cart.settings,
            key = input.getAttribute(settings.itemKey.replace(/\[|\]/g, "")),
            qty = +input.value;
          updateItem(key, {
            quantity: qty,
          }).then(function (cart) {
            var itemQty = cart.items.find(function (i) {
              return i.key == key;
            }).quantity;

            if (itemQty == qty) {
              AT_Cart.updateCart(cart);
            } else {
              input.setAttribute("value", itemQty);
              input.value = itemQty;
              AT_Cart.cartError();
            }
          });
        },
        suggestCart: function suggestCart(formData) {
          var arrayHandle = formData.get("c_f.cart_suggest"),
            settings = AT_Cart.settings,
            modal = document.querySelector(settings.dialog),
            wrapper = document.querySelector(settings.suggestContent);
          wrapper.innerHTML = "";

          if (arrayHandle == null) {
            return;
          }

          arrayHandle = arrayHandle.trim().split("|");
          modal.setAttribute("data-cart-type", "suggest");

          if (arrayHandle.length == 1) {
            wrapper.classList.add("grid-1-item");
            wrapper.classList.remove("grid-3-item");
          } else {
            wrapper.classList.add("grid-3-item");
            wrapper.classList.remove("grid-1-item");
          }

          arrayHandle.forEach(
            /*#__PURE__*/ (function () {
              var _ref2 = asyncToGenerator_default()(
                /*#__PURE__*/ regenerator_default.a.mark(function _callee2(i, index) {
                  var data;
                  return regenerator_default.a.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch ((_context2.prev = _context2.next)) {
                        case 0:
                          _context2.next = 2;
                          return AT_Cart.getItems([i]);

                        case 2:
                          data = _context2.sent;
                          AT_Cart.renderItem(data, settings.suggestContent);
                          index == arrayHandle.length - 1 &&
                            AT_Cart.buttonAddCart(document.querySelector(settings.dialog));

                        case 5:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })
              );

              return function (_x2, _x3) {
                return _ref2.apply(this, arguments);
              };
            })()
          );
        },
        replaceCart: (function () {
          var _replaceCart = asyncToGenerator_default()(
            /*#__PURE__*/ regenerator_default.a.mark(function _callee3(formData) {
              var handle, settings, modal, wrapper, data;
              return regenerator_default.a.wrap(function _callee3$(_context3) {
                while (1) {
                  switch ((_context3.prev = _context3.next)) {
                    case 0:
                      (handle = formData.get("c_f.cart_replace")),
                        (settings = AT_Cart.settings),
                        (modal = document.querySelector(settings.dialog)),
                        (wrapper = document.querySelector(settings.replaceContent));
                      wrapper.innerHTML = "";

                      if (!(handle == null)) {
                        _context3.next = 4;
                        break;
                      }

                      return _context3.abrupt("return", false);

                    case 4:
                      modal.setAttribute("data-cart-type", "replace");
                      _context3.next = 7;
                      return AT_Cart.getItems([handle]);

                    case 7:
                      data = _context3.sent;
                      wrapper.classList.add("grid-1-item");
                      AT_Cart.renderItem(data, settings.replaceContent);
                      AT_Cart.buttonAddCart(document.querySelector(settings.dialog));
                      return _context3.abrupt("return", true);

                    case 12:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            })
          );

          function replaceCart(_x4) {
            return _replaceCart.apply(this, arguments);
          }

          return replaceCart;
        })(),
        getItems: (function () {
          var _getItems = asyncToGenerator_default()(
            /*#__PURE__*/ regenerator_default.a.mark(function _callee4(arrayHandle) {
              var index,
                _args4 = arguments;
              return regenerator_default.a.wrap(function _callee4$(_context4) {
                while (1) {
                  switch ((_context4.prev = _context4.next)) {
                    case 0:
                      index = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : 0;

                      if (!(index >= arrayHandle.length)) {
                        _context4.next = 3;
                        break;
                      }

                      return _context4.abrupt("return");

                    case 3:
                      return _context4.abrupt(
                        "return",
                        fetch("/products/".concat(arrayHandle[index], ".js"))
                          .then(function (response) {
                            return response.json();
                          })
                          .then(
                            function (productJSON) {
                              AT_Cart.getItems(arrayHandle, index + 1);
                              return productJSON;
                            },
                            function (error) {
                              console.error(error);
                            }
                          )
                      );

                    case 4:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            })
          );

          function getItems(_x5) {
            return _getItems.apply(this, arguments);
          }

          return getItems;
        })(),
        renderItem: function renderItem(item, target) {
          var settings = AT_Cart.settings,
            selector = document.querySelector(settings.productCard),
            wrapper = document.querySelector(target);

          if (!AT_Main.isExist(selector) || !AT_Main.isExist(wrapper)) {
            return;
          }

          var productSelected = item.variants[0],
            btnAddCart_label = selector.querySelector(settings.itemCartBtnLabel),
            btnAddCart = btnAddCart_label.closest(".btn");
          selector.querySelectorAll(settings.itemURL).forEach(function (e) {
            e.setAttribute("href", item.url);
          });
          selector.querySelector(settings.itemID).value = productSelected.id;
          selector.querySelector(settings.itemTitle).innerHTML = item.title;
          selector.querySelector(settings.itemPrice).innerHTML = currency_cjs["formatMoney"](
            item.price,
            theme.currency.moneyFormat
          );
          selector.querySelector(settings.itemComparePrice).innerHTML = currency_cjs["formatMoney"](
            item.compare_at_price,
            theme.currency.moneyFormat
          );
          selector
            .querySelector(settings.itemImage)
            .setAttribute("src", images_cjs["getSizedImageUrl"](item.featured_image, "280x"));
          selector.querySelector(settings.itemImage).setAttribute("alt", item.title);
          productSelected.available
            ? btnAddCart.removeAttribute("disabled")
            : btnAddCart.setAttribute("disabled", "disabled");

          if (target == settings.suggestContent) {
            btnAddCart_label.innerHTML = productSelected.available ? theme.cart.available : theme.cart.soldout;
          } else {
            btnAddCart_label.innerHTML = theme.cart.replace;
          }

          if (item.compare_at_price == null) selector.querySelector(settings.itemComparePrice).classList.add("hide");
          else selector.querySelector(settings.itemComparePrice).classList.remove("hide");
          wrapper.insertAdjacentHTML("beforeend", selector.innerHTML);
        },
        cartError: function cartError() {
          var content = document.querySelector(dialog.error);

          if (!AT_Main.isExist(content)) {
            return;
          }

          content = content.querySelector("[data-notify-content]");
          content.innerHTML = theme.cart.error_add_cart;
          AT_Main.triggerDialog(dialog.error);
        },
        init: function init() {
          this.eventHandle();
        },
      };
      var AT_Search = {
        settings: {
          resultLayout: "#searchResultLayout",
          searchDialog: "#searchModal",
          container: "[data-search-container]",
          resultTarget: "[data-search-result]",
          type: "[data-result-type]",
          item: ".search-result-item",
          title: "[data-item-title]",
          url: "[data-item-url]",
          image: "[data-item-image]",
          imageWrapper: ".result-item-image",
          price: "[data-item-price]",
          soldout: "[data-item-soldout]",
          submit: "[data-search-submit]",
        },
        refreshSearch: function refreshSearch() {
          var searchActive = document.querySelectorAll(".search-is-active, .search-is-typing");
          searchActive.length &&
            searchActive.forEach(function (e) {
              e.classList.remove("search-is-active", "search-is-typing");
            });
        },
        handleEvent: function handleEvent() {
          var searchInput = document.querySelectorAll('input[name="q"]'),
            settings = AT_Search.settings,
            searchDialog = document.querySelector(settings.searchDialog);
          searchInput.length &&
            searchInput.forEach(function (searchElement) {
              var searchContainer = searchElement.closest(settings.container);
              searchElement.addEventListener("focus", function (e) {
                AT_Search.refreshSearch();
                searchContainer.classList.add("search-is-active");
                searchElement.value.length
                  ? searchContainer.classList.add("search-is-typing")
                  : searchContainer.classList.remove("search-is-typing");

                if (AT_Main.getWidthBrowser() < 992 && !AT_Main.isExist(searchElement.closest(settings.searchDialog))) {
                  AT_Main.triggerDialog(settings.searchDialog);
                  searchDialog.querySelector('input[name="q"]').focus();
                }
              });
              searchElement.addEventListener(
                "keyup",
                AT_Main.debounceTime(500, function (e) {
                  if (e.keyCode == 13) {
                    return;
                  }

                  AT_Search.fetchData(searchElement, searchElement.value);
                  searchElement.value.length
                    ? searchContainer.classList.add("search-is-typing")
                    : searchContainer.classList.remove("search-is-typing");
                })
              );
            });
          AT_Main.isExist(searchDialog.querySelector(".btn-search-clear")) &&
            searchDialog.querySelector(".btn-search-clear").addEventListener("click", function (e) {
              e.preventDefault();
              var input = searchDialog.querySelector('input[name="q"]');
              var searchContainer = input.closest(settings.container);
              searchDialog.querySelector(settings.resultTarget).innerHTML = "";
              input.value = "";
              input.focus();
              searchContainer.classList.remove("search-is-typing");
            });
          document.body.addEventListener("click", function (e) {
            var searchActive = document.querySelectorAll(".search-is-active");
            searchActive.length &&
              !AT_Main.isExist(e.target.closest(".search-is-active")) &&
              searchActive.forEach(function (e) {
                e.classList.remove("search-is-active");
              });
          });
        },
        fetchData: function fetchData(selector, value) {
          var config = theme.search,
            settings = AT_Search.settings,
            container = selector.closest(settings.container),
            resultSelector = container.querySelector(settings.resultTarget);

          if (!container.classList.contains("search-is-active")) {
            AT_Search.refreshSearch();
            container.classList.add("search-is-active");
          }

          container.classList.add("search-loading");
          /***
           *
           * If keyword length smaller than 2 > notify and return
           *
           ***/

          if (selector.value.length == 0) {
            resultSelector.innerHTML = "";
            return;
          }

          if (selector.value.length > 0 && selector.value.length < 2) {
            resultSelector.innerHTML = '<li class="result-notify">'.concat(config.notify_character, "</li>");
            return;
          }

          var type = config.type == "product" ? ["product"] : ["product", "article", "page", "collection"];
          fetch(
            "/search/suggest.json?q="
              .concat(value, "&resources[type]=")
              .concat(type, "&resources[limit]=")
              .concat(config.limit, "&resources[options][unavailable_products]=")
              .concat(config.unavailable_result)
          )
            .then(function (response) {
              return response.json();
            })
            .then(function (suggestions) {
              var rs = suggestions.resources.results,
                resultHTML = "";

              if (type.length == 1) {
                resultHTML += AT_Search.renderResult(rs.products, type[0]);
              } else {
                for (var i in rs) {
                  rs[i].length > 0 && (resultHTML += AT_Search.renderResult(rs[i], i));
                }
              }

              var lastestIem = document.querySelector(settings.resultLayout + " .search-redirect");
              AT_Main.isExist(lastestIem) && resultHTML != "" && (resultHTML += lastestIem.outerHTML);
              resultSelector.innerHTML =
                resultHTML != "" ? resultHTML : '<li class="result-notify">'.concat(config.no_result, "</li>");
              container.classList.remove("search-loading");
              AT_Main.isExist(document.querySelector(settings.submit)) &&
                document.querySelector(settings.submit).addEventListener("click", function (e) {
                  e.preventDefault();

                  var _container = e.currentTarget.closest(settings.container);

                  if (!AT_Main.isExist(_container)) {
                    return;
                  }

                  var form = _container.querySelector("form");

                  AT_Main.isExist(form) && form.submit();
                });
            });
        },
        renderResult: function renderResult(data, type) {
          var html = "",
            settings = AT_Search.settings,
            resultSelector = document.querySelector(settings.resultLayout);

          if (!AT_Main.isExist(resultSelector)) {
            return;
          }

          if (!data.length) {
            return html;
          }

          var itemLayout = resultSelector.querySelector(settings.item);
          html += '<li class="result-item-type">'.concat(type, "</li>");

          var _loop = function _loop(index) {
            var item = data[index];
            itemLayout.setAttribute("data-item-type", type);
            itemLayout.querySelector(settings.title).innerHTML = item.title;
            itemLayout.querySelectorAll(settings.url).forEach(function (e) {
              return e.setAttribute("href", item.url);
            });

            if (item.featured_image) {
              itemLayout
                .querySelector(settings.image)
                .setAttribute("src", images_cjs["getSizedImageUrl"](item.featured_image.url, "280x"));
              itemLayout.querySelector(settings.image).closest(settings.imageWrapper).classList.remove("hide");
            } else {
              itemLayout.querySelector(settings.image).closest(settings.imageWrapper).classList.add("hide");
            }

            if (type == "products") {
              if (item.available) {
                var price = JSON.parse(theme.currency.active) ? item.price + ".00" : item.price;
                itemLayout.querySelector(settings.price).innerHTML = currency_cjs["formatMoney"](
                  price,
                  theme.currency.moneyFormat
                );
                itemLayout.querySelector(settings.price).classList.remove("hide");
                itemLayout.querySelector(settings.soldout).classList.add("hide");
              } else {
                itemLayout.querySelector(settings.price).classList.add("hide");
                itemLayout.querySelector(settings.soldout).classList.remove("hide");
              }
            } else {
              itemLayout.querySelector(settings.price).classList.add("hide");
              itemLayout.querySelector(settings.soldout).classList.add("hide");
            }

            html += itemLayout.outerHTML;
          };

          for (var index in data) {
            _loop(index);
          }

          return html;
        },
        init: function init() {
          theme.template != "search" && this.handleEvent();
        },
      };
      var AT_Currency = {
        initEvents: function initEvents() {
          var btnCurrency = document.querySelectorAll(".btn-currency"),
            formCurrency = document.querySelector("form.shopify-currency-form");
          btnCurrency.length &&
            btnCurrency.forEach(function (c) {
              c.addEventListener("click", function (e) {
                e.preventDefault();

                if (!AT_Main.isExist(formCurrency)) {
                  return;
                }

                var type = formCurrency.querySelector('input[name="currencyType"]').value,
                  value = e.currentTarget.getAttribute("data-value");
                var optionSelect = formCurrency.querySelector("select");
                optionSelect.value = value;
                optionSelect.dispatchEvent(new Event("change"));
                formCurrency.submit();
              });
            });
        },
        init: function init() {
          AT_Currency.initEvents();
        },
      };
      // CONCATENATED MODULE: ./app/scripts/arn-theme.js

      var AT_Section = {
        registerSections: function registerSections() {
          register("header", {
            onLoad: function onLoad() {
              AT_Main.header(this.container);
            },
          });
          register("slideshow", {
            onLoad: function onLoad() {
              AT_Main.initSlideShow(this.container);
            },
          });
          register("featured-slide", {
            onLoad: function onLoad() {
              AT_Main.initSlider(this.container);
            },
          });
          register("instagram", {
            onLoad: function onLoad() {
              AT_Main.initSlider(this.container);
            },
          });
          register("featured-blog", {
            onLoad: function onLoad() {
              AT_Main.initSlider(this.container);
            },
          });
          register("featured-gallery", {
            onLoad: function onLoad() {
              AT_Main.initSlider_forGallery(this.container);
            },
          });
          register("featured-testimonials", {
            onLoad: function onLoad() {
              var _container = this.container;
              AT_Main.initSlider(_container);
            },
          });
          register("featured-megamenu", {
            onLoad: function onLoad() {
              var _container = this.container;
              AT_Main.megaMega_setPosition();
              AT_Main.initMegaMenu();
              AT_Main.initSlider(_container);
            },
            onSelect: function onSelect() {
              var _target = document.querySelector(".shopify-mega-menu");

              if (!AT_Main.isExist(_target)) {
                return;
              }

              _target.classList.add("active", "is-live");

              document.body.classList.add("megamenu-is-hover");
            },
            onDeselect: function onDeselect() {
              var _target = document.querySelector(".shopify-mega-menu");

              if (!AT_Main.isExist(_target)) {
                return;
              }

              _target.classList.remove("active", "is-live");

              document.body.classList.remove("megamenu-is-hover");
            },
          });
          register("featured-product", {
            onLoad: function onLoad() {
              AT_Main.initSlider(this.container);
            },
          });
          register("custom-content", {
            onLoad: function onLoad() {
              AT_Main.initSlider(this.container);
              AT_Main.initVideo(this.container);
            },
          });
          register("featured-product-tab", {
            onLoad: function onLoad() {
              var _container = this.container;
              AT_Main.tabPanel_init(_container);
              AT_Main.initSlider(_container);
            },
            onBlockSelect: function onBlockSelect(e) {
              var _this = e.target.querySelector("a");
            },
          });
          register("mobile-bar", {
            onLoad: function onLoad() {
              AT_Main.mobileBar();
            },
            onSelect: function onSelect() {
              document.getElementById("mobile-bar").classList.add("d-block");
            },
            onDeselect: function onDeselect() {
              document.getElementById("mobile-bar").classList.remove("d-block");
            },
            onBlockSelect: function onBlockSelect() {
              document.getElementById("mobile-bar").classList.add("d-block");
            },
            onBlockDeselect: function onBlockDeselect() {
              document.getElementById("mobile-bar").classList.add("d-block");
            },
          });
          register("footer-widget", {
            onLoad: function onLoad() {
              var $container = this.container,
                menuTarget = $container.querySelector(".navElement"),
                closeButton = $container.querySelector(".footerNav_mobile-close");
              AT_Main.clickModal(menuTarget, $container);
              AT_Main.closeModal(closeButton);
            },
          });
          register("collection", {
            onLoad: function onLoad() {
              var $container = this.container;
              AT_Main.initSlider($container);
              AT_Collection.init($container);
            },
          });
          register("product", {
            onLoad: function onLoad() {
              var container = this.container;
              AT_Main.tabPanel_init(container);
              AT_Main.themeProduct_slide(container);
              AT_Main.themeProduct(container);
            },
          });
          register("blog-page", {
            onLoad: function onLoad() {
              var container = this.container,
                popupClick = container.querySelector("a[data-mobile-sidebar]");
              AT_Main.isExist(popupClick) && AT_Main.clickModal(popupClick, document.body);
              AT_Main.initSlider(container);
            },
          });
          register("contact-page", {
            onLoad: function onLoad() {
              var container = this.container;
              AT_Main.initSlider(container);
            },
          });
          register("about-page", {
            onLoad: function onLoad() {
              var container = this.container;
              AT_Main.initSlider(container);
              AT_Main.initVideo(container);
            },
          });
          register("sidebar", {
            onLoad: function onLoad() {},
          });
        },
        init: function init() {
          this.registerSections();
          load("*");
        },
      };
      window.addEventListener("DOMContentLoaded", function (e) {
        AT_Main.init();
        AT_Section.init();
        AT_Currency.init();
        AT_Cart.init();
        AT_Search.init();
      });

      /***/
    },
    /******/
  ]
);
